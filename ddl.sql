create database gis;

create sequence event_id_seq;

alter sequence event_id_seq owner to postgres;

create sequence order_event_id_seq;

alter sequence order_event_id_seq owner to postgres;

-- Unknown how to generate base type type

alter type spheroid owner to postgres;

-- Unknown how to generate base type type

comment on type geometry is 'postgis type: The type representing spatial features with planar coordinate systems.';

alter type geometry owner to postgres;

-- Unknown how to generate base type type

comment on type box3d is 'postgis type: The type representing a 3-dimensional bounding box.';

alter type box3d owner to postgres;

-- Unknown how to generate base type type

comment on type box2d is 'postgis type: The type representing a 2-dimensional bounding box.';

alter type box2d owner to postgres;

-- Unknown how to generate base type type

alter type box2df owner to postgres;

-- Unknown how to generate base type type

alter type gidx owner to postgres;

create type geometry_dump as
    (
    path integer[],
    geom geometry
    );

comment on type geometry_dump is 'postgis type: A composite type used to describe the parts of complex geometry.';

alter type geometry_dump owner to postgres;

create type valid_detail as
    (
    valid    boolean,
    reason   varchar,
    location geometry
    );

alter type valid_detail owner to postgres;

-- Unknown how to generate base type type

comment on type geography is 'postgis type: The type representing spatial features with geodetic (ellipsoidal) coordinate systems.';

alter type geography owner to postgres;

-- Unknown how to generate base type type

comment on type raster is 'postgis raster type: raster spatial data type.';

alter type raster owner to postgres;

create type rastbandarg as
    (
    rast  raster,
    nband integer
    );

comment on type rastbandarg is 'postgis raster type: A composite type for use when needing to express a raster and a band index of that raster.';

alter type rastbandarg owner to postgres;

create type geomval as
    (
    geom geometry,
    val  double precision
    );

comment on type geomval is 'postgis raster type: A spatial datatype with two fields - geom (holding a geometry object) and val (holding a double precision pixel value from a raster band).';

alter type geomval owner to postgres;

create type addbandarg as
    (
    index        integer,
    pixeltype    text,
    initialvalue double precision,
    nodataval    double precision
    );

comment on type addbandarg is 'postgis raster type: A composite type used as input into the ST_AddBand function defining the attributes and initial value of the new band.';

alter type addbandarg owner to postgres;

create type summarystats as
    (
    count  bigint,
    sum    double precision,
    mean   double precision,
    stddev double precision,
    min    double precision,
    max    double precision
    );

comment on type summarystats is 'postgis raster type: A composite type returned by the ST_SummaryStats and ST_SummaryStatsAgg functions.';

alter type summarystats owner to postgres;

create type agg_count as
    (
    count                bigint,
    nband                integer,
    exclude_nodata_value boolean,
    sample_percent       double precision
    );

alter type agg_count owner to postgres;

create type reclassarg as
    (
    nband       integer,
    reclassexpr text,
    pixeltype   text,
    nodataval   double precision
    );

comment on type reclassarg is 'postgis raster type: A composite type used as input into the ST_Reclass function defining the behavior of reclassification.';

alter type reclassarg owner to postgres;

create type agg_samealignment as
    (
    refraster raster,
    aligned   boolean
    );

alter type agg_samealignment owner to postgres;

create type unionarg as
    (
    nband     integer,
    uniontype text
    );

comment on type unionarg is 'postgis raster type: A composite type used as input into the ST_Union function defining the bands to be processed and behavior of the UNION operation.';

alter type unionarg owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.aclitem is 'access control list';

-- Unknown how to generate base type type

comment on type pg_catalog.bit is 'fixed-length bit string';

-- Unknown how to generate base type type

comment on type pg_catalog.bool is 'boolean, ''true''/''false''';

-- Unknown how to generate base type type

comment on type pg_catalog.box is 'geometric box ''(lower left,upper right)''';

-- Unknown how to generate base type type

comment on type pg_catalog.bpchar is 'char(length), blank-padded string, fixed storage length';

-- Unknown how to generate base type type

comment on type pg_catalog.bytea is 'variable-length string, binary values escaped';

-- Unknown how to generate base type type

comment on type pg_catalog.char is 'single character';

-- Unknown how to generate base type type

comment on type pg_catalog.cid is 'command identifier type, sequence in transaction id';

-- Unknown how to generate base type type

comment on type pg_catalog.cidr is 'network IP address/netmask, network address';

-- Unknown how to generate base type type

comment on type pg_catalog.circle is 'geometric circle ''(center,radius)''';

-- Unknown how to generate base type type

comment on type pg_catalog.date is 'date';

-- Unknown how to generate base type type

comment on type pg_catalog.float4 is 'single-precision floating point number, 4-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.float8 is 'double-precision floating point number, 8-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.gtsvector is 'GiST index internal text representation for text search';

-- Unknown how to generate base type type

comment on type pg_catalog.inet is 'IP address/netmask, host address, netmask optional';

-- Unknown how to generate base type type

comment on type pg_catalog.int2 is '-32 thousand to 32 thousand, 2-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.int4 is '-2 billion to 2 billion integer, 4-byte storage';

create domain information_schema.cardinal_number as integer
    constraint cardinal_number_domain_check check ((VALUE >= 0));

-- Unknown how to generate base type type

comment on type pg_catalog.int8 is '~18 digit integer, 8-byte storage';

-- Unknown how to generate base type type

comment on type pg_catalog.interval is '@ <number> <units>, time interval';

-- Unknown how to generate base type type

comment on type pg_catalog.json is 'JSON stored as text';

-- Unknown how to generate base type type

comment on type pg_catalog.jsonb is 'Binary JSON';

-- Unknown how to generate base type type

comment on type pg_catalog.jsonpath is 'JSON path';

-- Unknown how to generate base type type

comment on type pg_catalog.line is 'geometric line';

-- Unknown how to generate base type type

comment on type pg_catalog.lseg is 'geometric line segment ''(pt1,pt2)''';

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr is 'XX:XX:XX:XX:XX:XX, MAC address';

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr8 is 'XX:XX:XX:XX:XX:XX:XX:XX, MAC address';

-- Unknown how to generate base type type

comment on type pg_catalog.money is 'monetary amounts, $d,ddd.cc';

-- Unknown how to generate base type type

comment on type pg_catalog.name is '63-byte type for storing system identifiers';

-- Unknown how to generate base type type

comment on type pg_catalog.numeric is 'numeric(precision, decimal), arbitrary precision number';

-- Unknown how to generate base type type

comment on type pg_catalog.oid is 'object identifier(oid), maximum 4 billion';

-- Unknown how to generate base type type

comment on type pg_catalog.path is 'geometric path ''(pt1,...)''';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_dependencies is 'multivariate dependencies';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_lsn is 'PostgreSQL LSN datatype';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_mcv_list is 'multivariate MCV list';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_ndistinct is 'multivariate ndistinct coefficients';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_node_tree is 'string representing an internal node tree';

-- Unknown how to generate base type type

comment on type pg_catalog.pg_snapshot is 'snapshot';

-- Unknown how to generate base type type

comment on type pg_catalog.point is 'geometric point ''(x, y)''';

-- Unknown how to generate base type type

comment on type pg_catalog.polygon is 'geometric polygon ''(pt1,...)''';

-- Unknown how to generate base type type

comment on type pg_catalog.refcursor is 'reference to cursor (portal name)';

-- Unknown how to generate base type type

comment on type pg_catalog.regclass is 'registered class';

-- Unknown how to generate base type type

comment on type pg_catalog.regcollation is 'registered collation';

-- Unknown how to generate base type type

comment on type pg_catalog.regconfig is 'registered text search configuration';

-- Unknown how to generate base type type

comment on type pg_catalog.regdictionary is 'registered text search dictionary';

-- Unknown how to generate base type type

comment on type pg_catalog.regnamespace is 'registered namespace';

-- Unknown how to generate base type type

comment on type pg_catalog.regoper is 'registered operator';

-- Unknown how to generate base type type

comment on type pg_catalog.regoperator is 'registered operator (with args)';

-- Unknown how to generate base type type

comment on type pg_catalog.regproc is 'registered procedure';

-- Unknown how to generate base type type

comment on type pg_catalog.regprocedure is 'registered procedure (with args)';

-- Unknown how to generate base type type

comment on type pg_catalog.regrole is 'registered role';

-- Unknown how to generate base type type

comment on type pg_catalog.regtype is 'registered type';

create domain information_schema.sql_identifier as name;

-- Unknown how to generate base type type

comment on type pg_catalog.text is 'variable-length string, no limit specified';

-- Unknown how to generate base type type

comment on type pg_catalog.tid is '(block, offset), physical location of tuple';

-- Unknown how to generate base type type

comment on type pg_catalog.time is 'time of day';

-- Unknown how to generate base type type

comment on type pg_catalog.timestamp is 'date and time';

-- Unknown how to generate base type type

comment on type pg_catalog.timestamptz is 'date and time with time zone';

create domain information_schema.time_stamp as timestamp(2) with time zone
    default CURRENT_TIMESTAMP(2);

-- Unknown how to generate base type type

comment on type pg_catalog.timetz is 'time of day with time zone';

-- Unknown how to generate base type type

comment on type pg_catalog.tsquery is 'query representation for text search';

-- Unknown how to generate base type type

comment on type pg_catalog.tsvector is 'text representation for text search';

-- Unknown how to generate base type type

comment on type pg_catalog.txid_snapshot is 'txid snapshot';

-- Unknown how to generate base type type

comment on type pg_catalog.uuid is 'UUID datatype';

-- Unknown how to generate base type type

comment on type pg_catalog.varbit is 'variable-length bit string';

-- Unknown how to generate base type type

comment on type pg_catalog.varchar is 'varchar(length), non-blank-padded string, variable storage length';

create domain information_schema.character_data as varchar;

-- Unknown how to generate base type type

comment on type pg_catalog.xid is 'transaction id';

-- Unknown how to generate base type type

comment on type pg_catalog.xid8 is 'full transaction id';

-- Unknown how to generate base type type

comment on type pg_catalog.xml is 'XML content';

create domain information_schema.yes_or_no as varchar(3)
    constraint yes_or_no_check check (((VALUE)::text = ANY
    ((ARRAY ['YES'::character varying, 'NO'::character varying])::text[])));

create table spatial_ref_sys
(
    srid      integer not null
        primary key
        constraint spatial_ref_sys_srid_check
            check ((srid > 0) AND (srid <= 998999)),
    auth_name varchar(256),
    auth_srid integer,
    srtext    varchar(2048),
    proj4text varchar(2048)
);

alter table spatial_ref_sys
    owner to postgres;

grant select on spatial_ref_sys to public;

create table user_tests
(
    geom      geometry,
    geom_test geometry
);

alter table user_tests
    owner to postgres;

create table user_orders
(
    id              bigserial
        constraint user_orders_pkey_1
            primary key,
    created_at      timestamp with time zone,
    updated_at      timestamp with time zone,
    deleted_at      timestamp with time zone,
    code            text,
    area            numeric,
    satellite_code  varchar(50),
    amount          bigint,
    status          bigint,
    product_level   varchar(50),
    user_id         bigint,
    type            bigint,
    product_type    bigint,
    start_time      timestamp with time zone,
    end_time        timestamp with time zone,
    latitude        numeric,
    sensor          text,
    longitude       numeric,
    satellite_name  varchar(50),
    spatial_id      bigint,
    name            text,
    order_from      bigint,
    process_status  bigint,
    image_type      bigint,
    resolution      numeric,
    cloud           bigint,
    target          text,
    target_location text
);

alter table user_orders
    owner to postgres;

create index idx_user_orders_deleted_at_1
    on user_orders (deleted_at);

create index idx_user_orders_deleted_at
    on user_orders (deleted_at);

create table user_order_product
(
);

alter table user_order_product
    owner to postgres;

create table user_order_event
(
    id          integer default nextval('order_event_id_seq'::regclass) not null
        constraint user_order_event_pkey_1
            primary key,
    order_id    integer,
    event_code  varchar(50),
    message     varchar(500),
    status      integer,
    event_time  timestamp with time zone,
    operator    varchar(50),
    run_task_id integer,
    create_at   timestamp with time zone,
    begin_time  timestamp with time zone,
    end_time    timestamp with time zone,
    event_name  varchar(255),
    req_id      varchar(64),
    step        integer
);

comment on column user_order_event.order_id is '订单id';

comment on column user_order_event.event_code is '事件code';

comment on column user_order_event.message is '消息描述';

comment on column user_order_event.status is '事件状态';

comment on column user_order_event.event_time is '时间';

comment on column user_order_event.operator is '操作者';

comment on column user_order_event.run_task_id is '运行的任务id';

comment on column user_order_event.create_at is '创建时间';

comment on column user_order_event.event_name is '事件名';

comment on column user_order_event.req_id is '需求id';

alter table user_order_event
    owner to postgres;

create table the_catalogs
(
    id          bigserial
        constraint the_catalogs_pkey_1
            primary key,
    created_at  timestamp with time zone,
    updated_at  timestamp with time zone,
    deleted_at  timestamp with time zone,
    name        varchar(32),
    pid         bigint default 0,
    icon        text,
    level       bigint default 0,
    report_path text,
    date        timestamp with time zone,
    hk_name     text,
    sort        bigint
);

comment on column the_catalogs.pid is '父级id';

alter table the_catalogs
    owner to postgres;

create index idx_the_catalogs_deleted_at_1
    on the_catalogs (deleted_at);

create index idx_the_catalogs_deleted_at
    on the_catalogs (deleted_at);

create table the_catalog_observations
(
    id           bigserial
        constraint the_catalog_observations_pkey_1
            primary key,
    created_at   timestamp with time zone,
    updated_at   timestamp with time zone,
    deleted_at   timestamp with time zone,
    name         varchar(32),
    pid          bigint default 0,
    path         text,
    tif          text,
    detect_type  bigint,
    tif_origin   bigint,
    extent       character varying[],
    introduction text,
    geo_image    text
);

comment on column the_catalog_observations.pid is 'TheCatalog中对应父级id';

comment on column the_catalog_observations.extent is 'tif经纬度边界';

alter table the_catalog_observations
    owner to postgres;

create index idx_the_catalog_observations_deleted_at_1
    on the_catalog_observations (deleted_at);

create index idx_the_catalog_observations_deleted_at
    on the_catalog_observations (deleted_at);

create table the_catalog_observation_tags
(
    id          bigserial
        constraint the_catalog_observation_tags_pkey_1
            primary key,
    created_at  timestamp with time zone,
    updated_at  timestamp with time zone,
    deleted_at  timestamp with time zone,
    name        text,
    geo_json    geometry,
    location    geometry,
    area        text,
    pid         bigint default 0,
    tag_type    bigint default 0,
    color       character varying[],
    inner_color character varying[],
    insar       character varying[]
);

comment on column the_catalog_observation_tags.pid is 'TheCatalog中对应父级id';

comment on column the_catalog_observation_tags.tag_type is '标注的类型';

comment on column the_catalog_observation_tags.color is '矢量边框颜色';

comment on column the_catalog_observation_tags.inner_color is '矢量内部颜色';

comment on column the_catalog_observation_tags.insar is '地表形变速率';

alter table the_catalog_observation_tags
    owner to postgres;

create index idx_the_catalog_observation_tags_deleted_at_1
    on the_catalog_observation_tags (deleted_at);

create index idx_the_catalog_observation_tags_deleted_at
    on the_catalog_observation_tags (deleted_at);

create table the_catalog_observation_reports
(
    id               bigserial
        constraint the_catalog_observation_reports_pkey_1
            primary key,
    created_at       timestamp with time zone,
    updated_at       timestamp with time zone,
    deleted_at       timestamp with time zone,
    name             text,
    date             text,
    conclusion       text,
    tif              text,
    tile             text,
    description      text,
    pid              bigint,
    extent           character varying[],
    report_path      text,
    img_path         text,
    tif_origin       bigint default 1,
    description_path text,
    geo_image        text
);

comment on column the_catalog_observation_reports.extent is 'tif经纬度边界';

alter table the_catalog_observation_reports
    owner to postgres;

create index idx_the_catalog_observation_reports_deleted_at_1
    on the_catalog_observation_reports (deleted_at);

create index idx_the_catalog_observation_reports_deleted_at
    on the_catalog_observation_reports (deleted_at);

create table the_catalog_observation_report_changes
(
    id         bigserial
        constraint the_catalog_observation_report_changes_pkey_1
            primary key,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone,
    change     text,
    analysis   text,
    pid        bigint,
    tag_id     bigint
);

alter table the_catalog_observation_report_changes
    owner to postgres;

create index idx_the_catalog_observation_report_changes_deleted_at_1
    on the_catalog_observation_report_changes (deleted_at);

create index idx_the_catalog_observation_report_changes_deleted_at
    on the_catalog_observation_report_changes (deleted_at);

create table sys_users
(
    id           bigserial
        constraint sys_users_pkey_1
            primary key,
    created_at   timestamp(6) with time zone,
    updated_at   timestamp(6) with time zone,
    deleted_at   timestamp(6) with time zone,
    uuid         text,
    username     text,
    password     text,
    nick_name    text        default '系统用户'::text,
    side_mode    text        default 'dark'::text,
    header_img   text        default 'https://qmplusimg.henrongyi.top/gva_header.jpg'::text,
    base_color   text        default '#fff'::text,
    active_color text        default '#1890ff'::text,
    authority_id varchar(90) default '888'::character varying
);

alter table sys_users
    owner to postgres;

create index idx_sys_users_deleted_at_1
    on sys_users (deleted_at);

create index idx_sys_users_deleted_at
    on sys_users (deleted_at);

create table sys_user_authority
(
    sys_user_id                bigint      not null,
    sys_authority_authority_id varchar(90) not null,
    constraint sys_user_authority_pkey_1
        primary key (sys_user_id, sys_authority_authority_id)
);

alter table sys_user_authority
    owner to postgres;

create table sys_target_observation_configs
(
    id                bigserial
        constraint sys_target_observation_configs_pkey_1
            primary key,
    created_at        timestamp with time zone,
    updated_at        timestamp with time zone,
    deleted_at        timestamp with time zone,
    longitude         numeric,
    latitude          numeric,
    height            numeric,
    name              text,
    images            character varying[],
    infos             text,
    offset_latitude   numeric,
    offset_longitude  numeric,
    offset_duration   numeric,
    observation_level bigint default 0,
    order_flag        bigint,
    duration          numeric,
    hold              numeric,
    level             numeric
);

alter table sys_target_observation_configs
    owner to postgres;

create index idx_sys_target_observation_configs_deleted_at_1
    on sys_target_observation_configs (deleted_at);

create index idx_sys_target_observation_configs_deleted_at
    on sys_target_observation_configs (deleted_at);

create table sys_operation_records
(
    id            bigserial
        constraint sys_operation_records_pkey_1
            primary key,
    created_at    timestamp(6) with time zone,
    updated_at    timestamp(6) with time zone,
    deleted_at    timestamp(6) with time zone,
    ip            text,
    method        text,
    path          text,
    status        bigint,
    latency       bigint,
    agent         text,
    error_message text,
    body          text,
    resp          text,
    user_id       bigint
);

alter table sys_operation_records
    owner to postgres;

create index idx_sys_operation_records_deleted_at_1
    on sys_operation_records (deleted_at);

create index idx_sys_operation_records_deleted_at
    on sys_operation_records (deleted_at);

create table sys_issue_consults
(
    id         bigserial
        constraint sys_issue_consults_pkey_1
            primary key,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone,
    name       text,
    phone      text,
    issue_desc text
);

alter table sys_issue_consults
    owner to postgres;

create index idx_sys_issue_consults_deleted_at_1
    on sys_issue_consults (deleted_at);

create index idx_sys_issue_consults_deleted_at
    on sys_issue_consults (deleted_at);

create table sys_dictionary_details
(
    id                bigserial
        constraint sys_dictionary_details_pkey_1
            primary key,
    created_at        timestamp(6) with time zone,
    updated_at        timestamp(6) with time zone,
    deleted_at        timestamp(6) with time zone,
    label             text,
    value             bigint,
    status            boolean,
    sort              bigint,
    sys_dictionary_id bigint
);

alter table sys_dictionary_details
    owner to postgres;

create index idx_sys_dictionary_details_deleted_at_1
    on sys_dictionary_details (deleted_at);

create index idx_sys_dictionary_details_deleted_at
    on sys_dictionary_details (deleted_at);

create table sys_dictionaries
(
    id         bigserial
        constraint sys_dictionaries_pkey_1
            primary key,
    created_at timestamp(6) with time zone,
    updated_at timestamp(6) with time zone,
    deleted_at timestamp(6) with time zone,
    name       text,
    type       text,
    status     boolean,
    "desc"     text
);

alter table sys_dictionaries
    owner to postgres;

create index idx_sys_dictionaries_deleted_at_1
    on sys_dictionaries (deleted_at);

create index idx_sys_dictionaries_deleted_at
    on sys_dictionaries (deleted_at);

create table sys_data_authority_id
(
    sys_authority_authority_id     varchar(90) not null,
    data_authority_id_authority_id varchar(90) not null,
    constraint sys_data_authority_id_pkey_1
        primary key (sys_authority_authority_id, data_authority_id_authority_id)
);

alter table sys_data_authority_id
    owner to postgres;

create table sys_base_menus
(
    id           bigserial
        constraint sys_base_menus_pkey_1
            primary key,
    created_at   timestamp(6) with time zone,
    updated_at   timestamp(6) with time zone,
    deleted_at   timestamp(6) with time zone,
    menu_level   bigint,
    parent_id    text,
    path         text,
    name         text,
    hidden       boolean,
    component    text,
    sort         bigint,
    keep_alive   boolean,
    default_menu boolean,
    title        text,
    icon         text,
    close_tab    boolean,
    title_cht    text,
    title_en     text
);

alter table sys_base_menus
    owner to postgres;

create index idx_sys_base_menus_deleted_at_1
    on sys_base_menus (deleted_at);

create index idx_sys_base_menus_deleted_at
    on sys_base_menus (deleted_at);

create table sys_auto_code_histories
(
    id             bigserial
        constraint sys_auto_code_histories_pkey_1
            primary key,
    created_at     timestamp(6) with time zone,
    updated_at     timestamp(6) with time zone,
    deleted_at     timestamp(6) with time zone,
    table_name     text,
    request_meta   text,
    auto_code_path text,
    injection_meta text,
    struct_name    text,
    struct_cn_name text,
    api_ids        text,
    flag           bigint
);

alter table sys_auto_code_histories
    owner to postgres;

create index idx_sys_auto_code_histories_deleted_at_1
    on sys_auto_code_histories (deleted_at);

create index idx_sys_auto_code_histories_deleted_at
    on sys_auto_code_histories (deleted_at);

create table sys_authority_menus
(
    sys_authority_authority_id varchar(90) not null,
    sys_base_menu_id           bigint      not null,
    constraint sys_authority_menus_pkey_2
        primary key (sys_authority_authority_id, sys_base_menu_id)
);

alter table sys_authority_menus
    owner to postgres;

create table sys_authorities
(
    created_at     timestamp(6) with time zone,
    updated_at     timestamp(6) with time zone,
    deleted_at     timestamp(6) with time zone,
    authority_id   varchar(90) not null
        constraint sys_authorities_pkey_1
            primary key,
    authority_name text,
    parent_id      text,
    default_router text default 'dashboard'::text
);

alter table sys_authorities
    owner to postgres;

create table sys_apis
(
    id          bigserial
        constraint sys_apis_pkey_1
            primary key,
    created_at  timestamp(6) with time zone,
    updated_at  timestamp(6) with time zone,
    deleted_at  timestamp(6) with time zone,
    path        text,
    description text,
    api_group   text,
    method      text default 'POST'::text
);

alter table sys_apis
    owner to postgres;

create index idx_sys_apis_deleted_at_1
    on sys_apis (deleted_at);

create index idx_sys_apis_deleted_at
    on sys_apis (deleted_at);

create table stations
(
    id               bigserial
        constraint stations_pkey_1
            primary key,
    created_at       timestamp with time zone,
    updated_at       timestamp with time zone,
    deleted_at       timestamp with time zone,
    code             varchar(50),
    address          varchar(50),
    longitude        numeric,
    latitude         numeric,
    frequency_band   varchar(50),
    antenna_aperture numeric,
    g_t              numeric,
    e_i_r_p          numeric,
    type             bigint,
    home             bigint,
    network          bigint,
    accept_distance  varchar(50),
    storage          varchar(50),
    name             varchar(50)
);

alter table stations
    owner to postgres;

create index idx_stations_deleted_at_1
    on stations (deleted_at);

create index idx_stations_deleted_at
    on stations (deleted_at);

create table spatials
(
    id               bigserial
        constraint spatials_pkey_1
            primary key,
    created_at       timestamp with time zone,
    updated_at       timestamp with time zone,
    deleted_at       timestamp with time zone,
    level            varchar(10),
    product_type     varchar(64),
    format           varchar(64),
    gen_time         timestamp with time zone,
    scene_id         varchar(64),
    segment_id       varchar(64),
    satellite_code   varchar(64),
    orbit_number     varchar(255),
    orbit_direction  varchar(255),
    image_mode       varchar(64),
    sensor_code      varchar(64),
    product_name     varchar(255),
    product_size     bigint,
    product_path     varchar(255),
    browse_image     varchar(255),
    scene_end_time   timestamp with time zone,
    scene_start_time timestamp with time zone,
    thumb_image      varchar(255),
    image_width      bigint,
    image_height     bigint,
    pixel_size_x     numeric(20, 2),
    pixel_size_y     numeric(20, 2),
    center_latitude  numeric(20, 8),
    center_longitude numeric(20, 8),
    range            geography,
    is_public        bigint default 1,
    public_time      timestamp with time zone,
    product_status   bigint default 1,
    origin_data_path varchar(255),
    earth_model      varchar(64),
    country          varchar(64),
    channels         varchar(64),
    province         varchar(64),
    city             varchar(64),
    area             varchar(64),
    town             varchar(64),
    village          varchar(64),
    cloud_amount     numeric(20, 2),
    satellite_name   varchar(64),
    sensor_name      varchar(64),
    resolution       numeric(10, 2),
    product_uuid     varchar(64),
    product_id       varchar(64),
    tile_path        varchar(255)
);

alter table spatials
    owner to postgres;

create table spatial_req_relations
(
    spatial_id bigint,
    req_id     varchar(64)
);

alter table spatial_req_relations
    owner to postgres;

create unique index idx_spatial_req_1
    on spatial_req_relations (spatial_id, req_id);

create unique index idx_spatial_req
    on spatial_req_relations (spatial_id, req_id);

create table satellite_equipments
(
    id             bigserial
        constraint satellite_equipments_pkey_1
            primary key,
    satellite_name varchar(64),
    satellite_code varchar(64),
    bit_depth      bigint,
    channels       character varying[],
    sensor_code    character varying[],
    sensor_name    character varying[]
);

alter table satellite_equipments
    owner to postgres;

create table product_downloads
(
    id             bigserial
        constraint product_downloads_pkey_1
            primary key,
    created_at     timestamp with time zone,
    updated_at     timestamp with time zone,
    deleted_at     timestamp with time zone,
    product_id     bigint,
    user_id        bigint,
    download_times bigint,
    status         bigint
);

alter table product_downloads
    owner to postgres;

create table product_download_ropes
(
    id                   bigserial
        constraint product_download_ropes_pkey_1
            primary key,
    created_at           timestamp with time zone,
    updated_at           timestamp with time zone,
    deleted_at           timestamp with time zone,
    user_id              bigint,
    call_available_times bigint default 99,
    remarks              text,
    status               bigint default 0,
    review               text,
    purpose              varchar(255)
);

alter table product_download_ropes
    owner to postgres;

create table product_download_rope_summaries
(
    id                   bigserial
        constraint product_download_rope_summaries_pkey_1
            primary key,
    created_at           timestamp with time zone,
    updated_at           timestamp with time zone,
    deleted_at           timestamp with time zone,
    user_id              bigint,
    call_available_times bigint default 99
);

alter table product_download_rope_summaries
    owner to postgres;

create table order_req_relations
(
    order_id bigint,
    req_id   varchar(64)
);

alter table order_req_relations
    owner to postgres;

create unique index idx_order_req_1
    on order_req_relations (order_id, req_id);

create unique index idx_order_req
    on order_req_relations (order_id, req_id);

create table jwt_blacklists
(
    id         bigserial
        constraint jwt_blacklists_pkey_1
            primary key,
    created_at timestamp(6) with time zone,
    updated_at timestamp(6) with time zone,
    deleted_at timestamp(6) with time zone,
    jwt        text
);

alter table jwt_blacklists
    owner to postgres;

create index idx_jwt_blacklists_deleted_at_1
    on jwt_blacklists (deleted_at);

create index idx_jwt_blacklists_deleted_at
    on jwt_blacklists (deleted_at);

create table information_analysis_water_qualities
(
    id         bigserial
        constraint information_analysis_water_qualities_pkey_1
            primary key,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone,
    wid        varchar(36),
    bbox       character varying[],
    img_path   varchar(256) not null,
    date       date,
    "desc"     varchar(1024),
    report     varchar(256),
    color_bar  varchar(256),
    tile       varchar(256)
);

comment on column information_analysis_water_qualities.wid is '唯一UUID';

comment on column information_analysis_water_qualities.bbox is '经纬度范围';

comment on column information_analysis_water_qualities.img_path is '图片结果路径';

comment on column information_analysis_water_qualities.date is '日期';

comment on column information_analysis_water_qualities."desc" is '介绍';

comment on column information_analysis_water_qualities.report is '整个pdf报告路径';

comment on column information_analysis_water_qualities.color_bar is '颜色bar区间图片路径';

comment on column information_analysis_water_qualities.tile is '瓦片地址';

alter table information_analysis_water_qualities
    owner to postgres;

create index idx_information_analysis_water_qualities_deleted_at_1
    on information_analysis_water_qualities (deleted_at);

create unique index idx_information_analysis_water_qualities_wid_1
    on information_analysis_water_qualities (wid);

create index idx_information_analysis_water_qualities_deleted_at
    on information_analysis_water_qualities (deleted_at);

create unique index idx_information_analysis_water_qualities_wid
    on information_analysis_water_qualities (wid);

create table information_analysis_remote_sensing_images
(
    id         bigserial
        constraint information_analysis_remote_sensing_images_pkey_1
            primary key,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone,
    rid        varchar(36) not null,
    name       varchar(256),
    filepath   varchar(256),
    tile_path  varchar(256),
    coord      json        not null,
    thumb_path varchar(256),
    type       bigint      not null,
    date       date        not null,
    region     text,
    "desc"     text,
    size       varchar(36),
    accurate   numeric(12, 2) default 1.000000
);

comment on column information_analysis_remote_sensing_images.rid is '唯一id';

comment on column information_analysis_remote_sensing_images.name is '影像名称';

comment on column information_analysis_remote_sensing_images.filepath is '文件路径,/data/demo/demo.tif';

comment on column information_analysis_remote_sensing_images.tile_path is '切片路径,/tiles/demo/';

comment on column information_analysis_remote_sensing_images.coord is '经纬度信息';

comment on column information_analysis_remote_sensing_images.thumb_path is '拇指图';

comment on column information_analysis_remote_sensing_images.type is '1光学，2:SAR';

comment on column information_analysis_remote_sensing_images.date is '日期';

comment on column information_analysis_remote_sensing_images.region is '地区';

comment on column information_analysis_remote_sensing_images."desc" is '描述';

comment on column information_analysis_remote_sensing_images.size is '分辨率';

comment on column information_analysis_remote_sensing_images.accurate is '精确';

alter table information_analysis_remote_sensing_images
    owner to postgres;

create index idx_information_analysis_remote_sensing_images_deleted_at_1
    on information_analysis_remote_sensing_images (deleted_at);

create unique index idx_information_analysis_remote_sensing_images_name_1
    on information_analysis_remote_sensing_images (name);

create unique index idx_information_analysis_remote_sensing_images_rid_1
    on information_analysis_remote_sensing_images (rid);

create index idx_information_analysis_remote_sensing_images_deleted_at
    on information_analysis_remote_sensing_images (deleted_at);

create unique index idx_information_analysis_remote_sensing_images_rid
    on information_analysis_remote_sensing_images (rid);

create unique index idx_information_analysis_remote_sensing_images_name
    on information_analysis_remote_sensing_images (name);

create table information_analysis_recognition_results
(
    id             bigserial
        constraint information_analysis_recognition_results_pkey_1
            primary key,
    created_at     timestamp with time zone,
    updated_at     timestamp with time zone,
    deleted_at     timestamp with time zone,
    rid            varchar(36),
    name           varchar(256) not null,
    bbox           character varying[],
    img_path       varchar(256) not null,
    count          bigint default 0,
    situation      text,
    human_traffic  bigint default 0,
    unloading_vo   bigint,
    loading_vo     bigint,
    conclusion     text,
    thumbnail      text,
    thumbnail_path text,
    tiff_path      varchar(256)
);

comment on column information_analysis_recognition_results.rid is '唯一UUID';

comment on column information_analysis_recognition_results.name is '名称';

comment on column information_analysis_recognition_results.bbox is '识别的经纬度范围';

comment on column information_analysis_recognition_results.img_path is '图片结果路径';

comment on column information_analysis_recognition_results.count is '识别出的总数量';

comment on column information_analysis_recognition_results.situation is '疫情情况';

comment on column information_analysis_recognition_results.human_traffic is '人流量';

comment on column information_analysis_recognition_results.unloading_vo is '卸货量';

comment on column information_analysis_recognition_results.loading_vo is '装货量';

comment on column information_analysis_recognition_results.conclusion is '结论分析';

comment on column information_analysis_recognition_results.thumbnail is '缩略图,10kb';

comment on column information_analysis_recognition_results.thumbnail_path is '缩略图,512x512';

comment on column information_analysis_recognition_results.tiff_path is 'tiff图片结果路径';

alter table information_analysis_recognition_results
    owner to postgres;

create index idx_information_analysis_recognition_results_deleted_at_1
    on information_analysis_recognition_results (deleted_at);

create unique index idx_information_analysis_recognition_results_rid_1
    on information_analysis_recognition_results (rid);

create index idx_information_analysis_recognition_results_deleted_at
    on information_analysis_recognition_results (deleted_at);

create unique index idx_information_analysis_recognition_results_rid
    on information_analysis_recognition_results (rid);

create table information_analysis_file_details
(
    id            bigserial
        constraint information_analysis_file_details_pkey_1
            primary key,
    created_at    timestamp with time zone,
    updated_at    timestamp with time zone,
    deleted_at    timestamp with time zone,
    filename      varchar(256),
    filepath      varchar(256),
    date          date,
    city          varchar(256),
    is_url        boolean,
    fid           text,
    class_ids     bigint[],
    tile_path     text,
    img_type      bigint,
    thumb         varchar(256),
    center        varchar(64),
    primary_class integer[],
    bbox          character varying[],
    name          text,
    thumbnail     text
);

comment on column information_analysis_file_details.filename is '文件名称，唯一存在';

comment on column information_analysis_file_details.filepath is '文件路径或者url';

comment on column information_analysis_file_details.date is '日期';

comment on column information_analysis_file_details.city is '城市';

comment on column information_analysis_file_details.is_url is 'true：filePath为url';

comment on column information_analysis_file_details.fid is '唯一uuid';

comment on column information_analysis_file_details.class_ids is '分类id，属于哪个分类下的图片';

comment on column information_analysis_file_details.tile_path is '切片路径';

comment on column information_analysis_file_details.img_type is '图像类别，1遥感图，2雷达图';

comment on column information_analysis_file_details.thumb is '缩略图路径';

comment on column information_analysis_file_details.center is '中心经纬度';

comment on column information_analysis_file_details.primary_class is '1地物分类，2目标提取，3变化监测';

comment on column information_analysis_file_details.bbox is '图片经纬度左上左下右下右上';

comment on column information_analysis_file_details.name is '文件名称';

comment on column information_analysis_file_details.thumbnail is '缩略图,250x256';

alter table information_analysis_file_details
    owner to postgres;

create unique index idx_date_city_1
    on information_analysis_file_details (date, city);

create index idx_information_analysis_file_details_deleted_at_1
    on information_analysis_file_details (deleted_at);

create unique index idx_information_analysis_file_details_f_id_1
    on information_analysis_file_details (fid);

create unique index idx_information_analysis_file_details_filename_1
    on information_analysis_file_details (filename);

create unique index idx_information_analysis_file_details_name_1
    on information_analysis_file_details (name);

create table information_analysis_classes
(
    id         bigserial
        constraint information_analysis_classes_pkey_1
            primary key,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone,
    c_id       varchar(36),
    class_name varchar(16),
    p_id       bigint
);

comment on column information_analysis_classes.c_id is '唯一id';

comment on column information_analysis_classes.class_name is '分类名称唯一';

comment on column information_analysis_classes.p_id is '父级id，为null时为最高级';

alter table information_analysis_classes
    owner to postgres;

create unique index idx_information_analysis_classes_c_id_1
    on information_analysis_classes (c_id);

create unique index idx_information_analysis_classes_class_name_1
    on information_analysis_classes (class_name);

create index idx_information_analysis_classes_deleted_at_1
    on information_analysis_classes (deleted_at);

create table information_analysis_analysis_results
(
    id             bigserial
        constraint information_analysis_analysis_results_pkey_1
            primary key,
    created_at     timestamp with time zone,
    updated_at     timestamp with time zone,
    deleted_at     timestamp with time zone,
    task_id        varchar(36),
    zip            varchar(256),
    bbox           varchar(256),
    f_id           varchar(36),
    result_img     text,
    user_id        varchar(36),
    area           numeric(12, 6),
    name           varchar(256),
    type           bigint,
    download_count bigint,
    primary_type   bigint,
    result_img2    text,
    f_id2          varchar(36),
    detail         json
);

comment on column information_analysis_analysis_results.task_id is '本次识别结果任务id，唯一';

comment on column information_analysis_analysis_results.zip is '结果压缩包路径|链接';

comment on column information_analysis_analysis_results.bbox is '识别范围';

comment on column information_analysis_analysis_results.f_id is '对应的file_detail表唯一id';

comment on column information_analysis_analysis_results.result_img is '图片结果路径|链接';

comment on column information_analysis_analysis_results.user_id is '用户uid';

comment on column information_analysis_analysis_results.area is '识别结果总面积';

comment on column information_analysis_analysis_results.name is '任务名称';

comment on column information_analysis_analysis_results.type is '属于的二级分类';

comment on column information_analysis_analysis_results.download_count is '下载次数';

comment on column information_analysis_analysis_results.primary_type is '分类';

comment on column information_analysis_analysis_results.result_img2 is '图片结果路径|链接';

comment on column information_analysis_analysis_results.f_id2 is '对应的file_detail表唯一id';

comment on column information_analysis_analysis_results.detail is '地物分類私有信息';

alter table information_analysis_analysis_results
    owner to postgres;

create index idx_information_analysis_analysis_results_deleted_at_1
    on information_analysis_analysis_results (deleted_at);

create table geospatial_services
(
    id                   bigserial
        constraint geospatial_services_pkey_1
            primary key,
    created_at           timestamp with time zone,
    updated_at           timestamp with time zone,
    deleted_at           timestamp with time zone,
    user_id              bigint,
    app_name             text,
    call_available_times bigint default 99,
    app_id               text,
    remarks              text,
    status               bigint default 0,
    review               text
);

alter table geospatial_services
    owner to postgres;

create table exa_files
(
    id          bigserial
        constraint exa_files_pkey_1
            primary key,
    created_at  timestamp(6) with time zone,
    updated_at  timestamp(6) with time zone,
    deleted_at  timestamp(6) with time zone,
    file_name   text,
    file_md5    text,
    file_path   text,
    chunk_total bigint,
    is_finish   boolean
);

alter table exa_files
    owner to postgres;

create index idx_exa_files_deleted_at_1
    on exa_files (deleted_at);

create index idx_exa_files_deleted_at
    on exa_files (deleted_at);

create table exa_file_upload_and_downloads
(
    id         bigserial
        constraint exa_file_upload_and_downloads_pkey_1
            primary key,
    created_at timestamp(6) with time zone,
    updated_at timestamp(6) with time zone,
    deleted_at timestamp(6) with time zone,
    name       text,
    url        text,
    tag        text,
    key        text
);

alter table exa_file_upload_and_downloads
    owner to postgres;

create index idx_exa_file_upload_and_downloads_deleted_at_1
    on exa_file_upload_and_downloads (deleted_at);

create index idx_exa_file_upload_and_downloads_deleted_at
    on exa_file_upload_and_downloads (deleted_at);

create table exa_file_chunks
(
    id                bigserial
        constraint exa_file_chunks_pkey_1
            primary key,
    created_at        timestamp(6) with time zone,
    updated_at        timestamp(6) with time zone,
    deleted_at        timestamp(6) with time zone,
    exa_file_id       bigint,
    file_chunk_number bigint,
    file_chunk_path   text
);

alter table exa_file_chunks
    owner to postgres;

create index idx_exa_file_chunks_deleted_at_1
    on exa_file_chunks (deleted_at);

create index idx_exa_file_chunks_deleted_at
    on exa_file_chunks (deleted_at);

create table exa_customers
(
    id                    bigserial
        constraint exa_customers_pkey_1
            primary key,
    created_at            timestamp(6) with time zone,
    updated_at            timestamp(6) with time zone,
    deleted_at            timestamp(6) with time zone,
    customer_name         text,
    customer_phone_data   text,
    sys_user_id           bigint,
    sys_user_authority_id text
);

alter table exa_customers
    owner to postgres;

create index idx_exa_customers_deleted_at_1
    on exa_customers (deleted_at);

create index idx_exa_customers_deleted_at
    on exa_customers (deleted_at);

create table custom_users
(
    id              bigserial
        constraint custom_users_pkey_1
            primary key,
    created_at      timestamp with time zone,
    updated_at      timestamp with time zone,
    deleted_at      timestamp with time zone,
    username        varchar(50),
    password        varchar(50),
    phone           varchar(50),
    status          bigint,
    nick_name       varchar(50),
    level           varchar(50),
    last_login_time timestamp with time zone,
    avatar          text,
    data_auth       text,
    create_time     varchar(50),
    email           varchar(50)
);

alter table custom_users
    owner to postgres;

create index idx_custom_users_deleted_at_1
    on custom_users (deleted_at);

create index idx_custom_users_deleted_at
    on custom_users (deleted_at);

create table ck_targets
(
    id             bigserial
        constraint ck_targets_pkey_1
            primary key,
    created_at     timestamp with time zone,
    updated_at     timestamp with time zone,
    deleted_at     timestamp with time zone,
    name           varchar(32),
    resolution     numeric,
    satellite_name varchar(32),
    longitude      numeric,
    latitude       numeric,
    imaging_time   timestamp with time zone,
    thumb_path     text,
    browser_path   text,
    tile_path      text,
    video_path     text,
    extent         character varying[],
    sensor_name    text,
    status         bigint,
    monitor_range  character varying[],
    bottom_tile    text,
    bottom_extent  character varying[]
);

comment on column ck_targets.extent is 'tile经纬度边界';

comment on column ck_targets.monitor_range is '监测范围';

comment on column ck_targets.bottom_extent is '底图经纬度边界';

alter table ck_targets
    owner to postgres;

create index idx_ck_targets_deleted_at_1
    on ck_targets (deleted_at);

create index idx_ck_targets_deleted_at
    on ck_targets (deleted_at);

create table ck_orders
(
    id             bigserial
        constraint ck_orders_pkey_1
            primary key,
    created_at     timestamp with time zone,
    updated_at     timestamp with time zone,
    deleted_at     timestamp with time zone,
    name           text,
    "reqName"      text,
    code           text,
    user_id        bigint,
    status         bigint,
    process_status bigint,
    satellite_code varchar(50),
    satellite_name varchar(50),
    start_time     timestamp with time zone,
    end_time       timestamp with time zone,
    instruction    text,
    req_name       text,
    instructions   text,
    event          text
);

alter table ck_orders
    owner to postgres;

create index idx_ck_orders_deleted_at_1
    on ck_orders (deleted_at);

create index idx_ck_orders_deleted_at
    on ck_orders (deleted_at);

create table casbin_rule
(
    p_type varchar(100),
    v0     varchar(100),
    v1     varchar(100),
    v2     varchar(100),
    v3     varchar(100),
    v4     varchar(100),
    v5     varchar(100)
);

alter table casbin_rule
    owner to postgres;

create table auto_code_examples
(
    id                      bigserial
        constraint auto_code_examples_pkey_1
            primary key,
    created_at              timestamp with time zone,
    updated_at              timestamp with time zone,
    deleted_at              timestamp with time zone,
    auto_code_example_field text
);

alter table auto_code_examples
    owner to postgres;

create index idx_auto_code_examples_deleted_at_1
    on auto_code_examples (deleted_at);

create index idx_auto_code_examples_deleted_at
    on auto_code_examples (deleted_at);

create table sc_orders
(
    id             bigserial
        primary key,
    created_at     timestamp with time zone,
    updated_at     timestamp with time zone,
    deleted_at     timestamp with time zone,
    name           text,
    req_name       text,
    code           text,
    user_id        bigint,
    status         bigint,
    satellite_code varchar(50),
    satellite_name varchar(50),
    event          text,
    start_time     timestamp with time zone,
    end_time       timestamp with time zone
);

alter table sc_orders
    owner to postgres;

create index idx_sc_orders_deleted_at
    on sc_orders (deleted_at);

create table sys_base_menu_parameters
(
    id               bigserial
        primary key,
    created_at       timestamp with time zone,
    updated_at       timestamp with time zone,
    deleted_at       timestamp with time zone,
    sys_base_menu_id bigint,
    type             text,
    key              text,
    value            text
);

alter table sys_base_menu_parameters
    owner to postgres;

create index idx_sys_base_menu_parameters_deleted_at
    on sys_base_menu_parameters (deleted_at);

create table spatials_copy1
(
    id               bigint default nextval('spatials_id_seq'::regclass) not null
        primary key,
    created_at       timestamp(6) with time zone,
    updated_at       timestamp(6) with time zone,
    deleted_at       timestamp(6) with time zone,
    level            varchar(10),
    product_type     varchar(64),
    format           varchar(64),
    gen_time         timestamp(6) with time zone,
    scene_id         varchar(64),
    segment_id       varchar(64),
    satellite_code   varchar(64),
    orbit_number     varchar(255),
    orbit_direction  varchar(255),
    image_mode       varchar(64),
    sensor_code      varchar(64),
    product_name     varchar(255),
    product_size     bigint,
    product_path     varchar(255),
    browse_image     varchar(255),
    scene_end_time   timestamp(6) with time zone,
    scene_start_time timestamp(6) with time zone,
    thumb_image      varchar(255),
    image_width      bigint,
    image_height     bigint,
    pixel_size_x     numeric(20, 2),
    pixel_size_y     numeric(20, 2),
    center_latitude  numeric(20, 8),
    center_longitude numeric(20, 8),
    range            geography,
    is_public        bigint default 1,
    public_time      timestamp(6) with time zone,
    product_status   bigint default 1,
    origin_data_path varchar(255),
    earth_model      varchar(64),
    country          varchar(64),
    channels         varchar(64),
    province         varchar(64),
    city             varchar(64),
    area             varchar(64),
    town             varchar(64),
    village          varchar(64),
    cloud_amount     numeric(20, 2),
    satellite_name   varchar(64),
    sensor_name      varchar(64),
    resolution       numeric(10, 2),
    product_uuid     varchar(64),
    product_id       varchar(64),
    tile_path        varchar(255)
);

alter table spatials_copy1
    owner to postgres;

create table pg_catalog.pg_aggregate
(
    aggfnoid         regproc  not null,
    aggkind          "char"   not null,
    aggnumdirectargs smallint not null,
    aggtransfn       regproc  not null,
    aggfinalfn       regproc  not null,
    aggcombinefn     regproc  not null,
    aggserialfn      regproc  not null,
    aggdeserialfn    regproc  not null,
    aggmtransfn      regproc  not null,
    aggminvtransfn   regproc  not null,
    aggmfinalfn      regproc  not null,
    aggfinalextra    boolean  not null,
    aggmfinalextra   boolean  not null,
    aggfinalmodify   "char"   not null,
    aggmfinalmodify  "char"   not null,
    aggsortop        oid      not null,
    aggtranstype     oid      not null,
    aggtransspace    integer  not null,
    aggmtranstype    oid      not null,
    aggmtransspace   integer  not null,
    agginitval       text,
    aggminitval      text
);

create unique index pg_aggregate_fnoid_index
    on pg_catalog.pg_aggregate (aggfnoid);

create table pg_catalog.pg_am
(
    oid       oid                               not null,
    amname    information_schema.sql_identifier not null,
    amhandler regproc                           not null,
    amtype    "char"                            not null
);

create unique index pg_am_name_index
    on pg_catalog.pg_am (amname collate "C");

create unique index pg_am_oid_index
    on pg_catalog.pg_am (oid);

create table pg_catalog.pg_amop
(
    oid            oid      not null,
    amopfamily     oid      not null,
    amoplefttype   oid      not null,
    amoprighttype  oid      not null,
    amopstrategy   smallint not null,
    amoppurpose    "char"   not null,
    amopopr        oid      not null,
    amopmethod     oid      not null,
    amopsortfamily oid      not null
);

create unique index pg_amop_fam_strat_index
    on pg_catalog.pg_amop (amopfamily, amoplefttype, amoprighttype, amopstrategy);

create unique index pg_amop_oid_index
    on pg_catalog.pg_amop (oid);

create unique index pg_amop_opr_fam_index
    on pg_catalog.pg_amop (amopopr, amoppurpose, amopfamily);

create table pg_catalog.pg_amproc
(
    oid             oid      not null,
    amprocfamily    oid      not null,
    amproclefttype  oid      not null,
    amprocrighttype oid      not null,
    amprocnum       smallint not null,
    amproc          regproc  not null
);

create unique index pg_amproc_fam_proc_index
    on pg_catalog.pg_amproc (amprocfamily, amproclefttype, amprocrighttype, amprocnum);

create unique index pg_amproc_oid_index
    on pg_catalog.pg_amproc (oid);

create table pg_catalog.pg_attrdef
(
    oid     oid          not null,
    adrelid oid          not null,
    adnum   smallint     not null,
    adbin   pg_node_tree not null
);

create unique index pg_attrdef_adrelid_adnum_index
    on pg_catalog.pg_attrdef (adrelid, adnum);

create unique index pg_attrdef_oid_index
    on pg_catalog.pg_attrdef (oid);

create table pg_catalog.pg_attribute
(
    attrelid      oid                               not null,
    attname       information_schema.sql_identifier not null,
    atttypid      oid                               not null,
    attstattarget integer                           not null,
    attlen        smallint                          not null,
    attnum        smallint                          not null,
    attndims      integer                           not null,
    attcacheoff   integer                           not null,
    atttypmod     integer                           not null,
    attbyval      boolean                           not null,
    attstorage    "char"                            not null,
    attalign      "char"                            not null,
    attnotnull    boolean                           not null,
    atthasdef     boolean                           not null,
    atthasmissing boolean                           not null,
    attidentity   "char"                            not null,
    attgenerated  "char"                            not null,
    attisdropped  boolean                           not null,
    attislocal    boolean                           not null,
    attinhcount   integer                           not null,
    attcollation  oid                               not null,
    attacl        aclitem[],
    attoptions    text[],
    attfdwoptions text[],
    attmissingval anyarray
);

create unique index pg_attribute_relid_attnam_index
    on pg_catalog.pg_attribute (attrelid, attname collate "C");

create unique index pg_attribute_relid_attnum_index
    on pg_catalog.pg_attribute (attrelid, attnum);

create table pg_catalog.pg_auth_members
(
    roleid       oid     not null,
    member       oid     not null,
    grantor      oid     not null,
    admin_option boolean not null
)
    tablespace pg_global;

create unique index pg_auth_members_member_role_index
    on pg_catalog.pg_auth_members (member, roleid)
    tablespace pg_global;

create unique index pg_auth_members_role_member_index
    on pg_catalog.pg_auth_members (roleid, member)
    tablespace pg_global;

create table pg_catalog.pg_authid
(
    oid            oid                               not null,
    rolname        information_schema.sql_identifier not null,
    rolsuper       boolean                           not null,
    rolinherit     boolean                           not null,
    rolcreaterole  boolean                           not null,
    rolcreatedb    boolean                           not null,
    rolcanlogin    boolean                           not null,
    rolreplication boolean                           not null,
    rolbypassrls   boolean                           not null,
    rolconnlimit   integer                           not null,
    rolpassword    text,
    rolvaliduntil  timestamp with time zone
)
    tablespace pg_global;

create unique index pg_authid_oid_index
    on pg_catalog.pg_authid (oid)
    tablespace pg_global;

create unique index pg_authid_rolname_index
    on pg_catalog.pg_authid (rolname collate "C")
    tablespace pg_global;

create table pg_catalog.pg_cast
(
    oid         oid    not null,
    castsource  oid    not null,
    casttarget  oid    not null,
    castfunc    oid    not null,
    castcontext "char" not null,
    castmethod  "char" not null
);

create unique index pg_cast_oid_index
    on pg_catalog.pg_cast (oid);

create unique index pg_cast_source_target_index
    on pg_catalog.pg_cast (castsource, casttarget);

create table pg_catalog.pg_class
(
    oid                 oid                               not null,
    relname             information_schema.sql_identifier not null,
    relnamespace        oid                               not null,
    reltype             oid                               not null,
    reloftype           oid                               not null,
    relowner            oid                               not null,
    relam               oid                               not null,
    relfilenode         oid                               not null,
    reltablespace       oid                               not null,
    relpages            integer                           not null,
    reltuples           real                              not null,
    relallvisible       integer                           not null,
    reltoastrelid       oid                               not null,
    relhasindex         boolean                           not null,
    relisshared         boolean                           not null,
    relpersistence      "char"                            not null,
    relkind             "char"                            not null,
    relnatts            smallint                          not null,
    relchecks           smallint                          not null,
    relhasrules         boolean                           not null,
    relhastriggers      boolean                           not null,
    relhassubclass      boolean                           not null,
    relrowsecurity      boolean                           not null,
    relforcerowsecurity boolean                           not null,
    relispopulated      boolean                           not null,
    relreplident        "char"                            not null,
    relispartition      boolean                           not null,
    relrewrite          oid                               not null,
    relfrozenxid        xid                               not null,
    relminmxid          xid                               not null,
    relacl              aclitem[],
    reloptions          text[],
    relpartbound        pg_node_tree
);

create unique index pg_class_oid_index
    on pg_catalog.pg_class (oid);

create unique index pg_class_relname_nsp_index
    on pg_catalog.pg_class (relname collate "C", relnamespace);

create index pg_class_tblspc_relfilenode_index
    on pg_catalog.pg_class (reltablespace, relfilenode);

create table pg_catalog.pg_collation
(
    oid                 oid                               not null,
    collname            information_schema.sql_identifier not null,
    collnamespace       oid                               not null,
    collowner           oid                               not null,
    collprovider        "char"                            not null,
    collisdeterministic boolean                           not null,
    collencoding        integer                           not null,
    collcollate         information_schema.sql_identifier not null,
    collctype           information_schema.sql_identifier not null,
    collversion         text
);

create unique index pg_collation_name_enc_nsp_index
    on pg_catalog.pg_collation (collname collate "C", collencoding, collnamespace);

create unique index pg_collation_oid_index
    on pg_catalog.pg_collation (oid);

create table pg_catalog.pg_constraint
(
    oid           oid                               not null,
    conname       information_schema.sql_identifier not null,
    connamespace  oid                               not null,
    contype       "char"                            not null,
    condeferrable boolean                           not null,
    condeferred   boolean                           not null,
    convalidated  boolean                           not null,
    conrelid      oid                               not null,
    contypid      oid                               not null,
    conindid      oid                               not null,
    conparentid   oid                               not null,
    confrelid     oid                               not null,
    confupdtype   "char"                            not null,
    confdeltype   "char"                            not null,
    confmatchtype "char"                            not null,
    conislocal    boolean                           not null,
    coninhcount   integer                           not null,
    connoinherit  boolean                           not null,
    conkey        smallint[],
    confkey       smallint[],
    conpfeqop     oid[],
    conppeqop     oid[],
    conffeqop     oid[],
    conexclop     oid[],
    conbin        pg_node_tree
);

create index pg_constraint_conname_nsp_index
    on pg_catalog.pg_constraint (conname collate "C", connamespace);

create index pg_constraint_conparentid_index
    on pg_catalog.pg_constraint (conparentid);

create unique index pg_constraint_conrelid_contypid_conname_index
    on pg_catalog.pg_constraint (conrelid, contypid, conname collate "C");

create index pg_constraint_contypid_index
    on pg_catalog.pg_constraint (contypid);

create unique index pg_constraint_oid_index
    on pg_catalog.pg_constraint (oid);

create table pg_catalog.pg_conversion
(
    oid            oid                               not null,
    conname        information_schema.sql_identifier not null,
    connamespace   oid                               not null,
    conowner       oid                               not null,
    conforencoding integer                           not null,
    contoencoding  integer                           not null,
    conproc        regproc                           not null,
    condefault     boolean                           not null
);

create unique index pg_conversion_default_index
    on pg_catalog.pg_conversion (connamespace, conforencoding, contoencoding, oid);

create unique index pg_conversion_name_nsp_index
    on pg_catalog.pg_conversion (conname collate "C", connamespace);

create unique index pg_conversion_oid_index
    on pg_catalog.pg_conversion (oid);

create table pg_catalog.pg_database
(
    oid           oid                               not null,
    datname       information_schema.sql_identifier not null,
    datdba        oid                               not null,
    encoding      integer                           not null,
    datcollate    information_schema.sql_identifier not null,
    datctype      information_schema.sql_identifier not null,
    datistemplate boolean                           not null,
    datallowconn  boolean                           not null,
    datconnlimit  integer                           not null,
    datlastsysoid oid                               not null,
    datfrozenxid  xid                               not null,
    datminmxid    xid                               not null,
    dattablespace oid                               not null,
    datacl        aclitem[]
)
    tablespace pg_global;

create unique index pg_database_datname_index
    on pg_catalog.pg_database (datname collate "C")
    tablespace pg_global;

create unique index pg_database_oid_index
    on pg_catalog.pg_database (oid)
    tablespace pg_global;

create table pg_catalog.pg_db_role_setting
(
    setdatabase oid not null,
    setrole     oid not null,
    setconfig   text[]
)
    tablespace pg_global;

create unique index pg_db_role_setting_databaseid_rol_index
    on pg_catalog.pg_db_role_setting (setdatabase, setrole)
    tablespace pg_global;

create table pg_catalog.pg_default_acl
(
    oid             oid       not null,
    defaclrole      oid       not null,
    defaclnamespace oid       not null,
    defaclobjtype   "char"    not null,
    defaclacl       aclitem[] not null
);

create unique index pg_default_acl_oid_index
    on pg_catalog.pg_default_acl (oid);

create unique index pg_default_acl_role_nsp_obj_index
    on pg_catalog.pg_default_acl (defaclrole, defaclnamespace, defaclobjtype);

create table pg_catalog.pg_depend
(
    classid     oid     not null,
    objid       oid     not null,
    objsubid    integer not null,
    refclassid  oid     not null,
    refobjid    oid     not null,
    refobjsubid integer not null,
    deptype     "char"  not null
);

create index pg_depend_depender_index
    on pg_catalog.pg_depend (classid, objid, objsubid);

create index pg_depend_reference_index
    on pg_catalog.pg_depend (refclassid, refobjid, refobjsubid);

create table pg_catalog.pg_description
(
    objoid      oid     not null,
    classoid    oid     not null,
    objsubid    integer not null,
    description text    not null
);

create unique index pg_description_o_c_o_index
    on pg_catalog.pg_description (objoid, classoid, objsubid);

create table pg_catalog.pg_enum
(
    oid           oid                               not null,
    enumtypid     oid                               not null,
    enumsortorder real                              not null,
    enumlabel     information_schema.sql_identifier not null
);

create unique index pg_enum_oid_index
    on pg_catalog.pg_enum (oid);

create unique index pg_enum_typid_label_index
    on pg_catalog.pg_enum (enumtypid, enumlabel collate "C");

create unique index pg_enum_typid_sortorder_index
    on pg_catalog.pg_enum (enumtypid, enumsortorder);

create table pg_catalog.pg_event_trigger
(
    oid        oid                               not null,
    evtname    information_schema.sql_identifier not null,
    evtevent   information_schema.sql_identifier not null,
    evtowner   oid                               not null,
    evtfoid    oid                               not null,
    evtenabled "char"                            not null,
    evttags    text[]
);

create unique index pg_event_trigger_evtname_index
    on pg_catalog.pg_event_trigger (evtname collate "C");

create unique index pg_event_trigger_oid_index
    on pg_catalog.pg_event_trigger (oid);

create table pg_catalog.pg_extension
(
    oid            oid                               not null,
    extname        information_schema.sql_identifier not null,
    extowner       oid                               not null,
    extnamespace   oid                               not null,
    extrelocatable boolean                           not null,
    extversion     text                              not null,
    extconfig      oid[],
    extcondition   text[]
);

create unique index pg_extension_name_index
    on pg_catalog.pg_extension (extname collate "C");

create unique index pg_extension_oid_index
    on pg_catalog.pg_extension (oid);

create table pg_catalog.pg_foreign_data_wrapper
(
    oid          oid                               not null,
    fdwname      information_schema.sql_identifier not null,
    fdwowner     oid                               not null,
    fdwhandler   oid                               not null,
    fdwvalidator oid                               not null,
    fdwacl       aclitem[],
    fdwoptions   text[]
);

create unique index pg_foreign_data_wrapper_name_index
    on pg_catalog.pg_foreign_data_wrapper (fdwname collate "C");

create unique index pg_foreign_data_wrapper_oid_index
    on pg_catalog.pg_foreign_data_wrapper (oid);

create table pg_catalog.pg_foreign_server
(
    oid        oid                               not null,
    srvname    information_schema.sql_identifier not null,
    srvowner   oid                               not null,
    srvfdw     oid                               not null,
    srvtype    text,
    srvversion text,
    srvacl     aclitem[],
    srvoptions text[]
);

create unique index pg_foreign_server_name_index
    on pg_catalog.pg_foreign_server (srvname collate "C");

create unique index pg_foreign_server_oid_index
    on pg_catalog.pg_foreign_server (oid);

create table pg_catalog.pg_foreign_table
(
    ftrelid   oid not null,
    ftserver  oid not null,
    ftoptions text[]
);

create unique index pg_foreign_table_relid_index
    on pg_catalog.pg_foreign_table (ftrelid);

create table pg_catalog.pg_index
(
    indexrelid     oid        not null,
    indrelid       oid        not null,
    indnatts       smallint   not null,
    indnkeyatts    smallint   not null,
    indisunique    boolean    not null,
    indisprimary   boolean    not null,
    indisexclusion boolean    not null,
    indimmediate   boolean    not null,
    indisclustered boolean    not null,
    indisvalid     boolean    not null,
    indcheckxmin   boolean    not null,
    indisready     boolean    not null,
    indislive      boolean    not null,
    indisreplident boolean    not null,
    indkey         int2vector not null,
    indcollation   oidvector  not null,
    indclass       oidvector  not null,
    indoption      int2vector not null,
    indexprs       pg_node_tree,
    indpred        pg_node_tree
);

create unique index pg_index_indexrelid_index
    on pg_catalog.pg_index (indexrelid);

create index pg_index_indrelid_index
    on pg_catalog.pg_index (indrelid);

create table pg_catalog.pg_inherits
(
    inhrelid  oid     not null,
    inhparent oid     not null,
    inhseqno  integer not null
);

create index pg_inherits_parent_index
    on pg_catalog.pg_inherits (inhparent);

create unique index pg_inherits_relid_seqno_index
    on pg_catalog.pg_inherits (inhrelid, inhseqno);

create table pg_catalog.pg_init_privs
(
    objoid    oid       not null,
    classoid  oid       not null,
    objsubid  integer   not null,
    privtype  "char"    not null,
    initprivs aclitem[] not null
);

create unique index pg_init_privs_o_c_o_index
    on pg_catalog.pg_init_privs (objoid, classoid, objsubid);

create table pg_catalog.pg_language
(
    oid           oid                               not null,
    lanname       information_schema.sql_identifier not null,
    lanowner      oid                               not null,
    lanispl       boolean                           not null,
    lanpltrusted  boolean                           not null,
    lanplcallfoid oid                               not null,
    laninline     oid                               not null,
    lanvalidator  oid                               not null,
    lanacl        aclitem[]
);

create unique index pg_language_name_index
    on pg_catalog.pg_language (lanname collate "C");

create unique index pg_language_oid_index
    on pg_catalog.pg_language (oid);

create table pg_catalog.pg_largeobject
(
    loid   oid     not null,
    pageno integer not null,
    data   bytea   not null
);

create unique index pg_largeobject_loid_pn_index
    on pg_catalog.pg_largeobject (loid, pageno);

create table pg_catalog.pg_largeobject_metadata
(
    oid      oid not null,
    lomowner oid not null,
    lomacl   aclitem[]
);

create unique index pg_largeobject_metadata_oid_index
    on pg_catalog.pg_largeobject_metadata (oid);

create table pg_catalog.pg_namespace
(
    oid      oid                               not null,
    nspname  information_schema.sql_identifier not null,
    nspowner oid                               not null,
    nspacl   aclitem[]
);

create unique index pg_namespace_nspname_index
    on pg_catalog.pg_namespace (nspname collate "C");

create unique index pg_namespace_oid_index
    on pg_catalog.pg_namespace (oid);

create table pg_catalog.pg_opclass
(
    oid          oid                               not null,
    opcmethod    oid                               not null,
    opcname      information_schema.sql_identifier not null,
    opcnamespace oid                               not null,
    opcowner     oid                               not null,
    opcfamily    oid                               not null,
    opcintype    oid                               not null,
    opcdefault   boolean                           not null,
    opckeytype   oid                               not null
);

create unique index pg_opclass_am_name_nsp_index
    on pg_catalog.pg_opclass (opcmethod, opcname collate "C", opcnamespace);

create unique index pg_opclass_oid_index
    on pg_catalog.pg_opclass (oid);

create table pg_catalog.pg_operator
(
    oid          oid                               not null,
    oprname      information_schema.sql_identifier not null,
    oprnamespace oid                               not null,
    oprowner     oid                               not null,
    oprkind      "char"                            not null,
    oprcanmerge  boolean                           not null,
    oprcanhash   boolean                           not null,
    oprleft      oid                               not null,
    oprright     oid                               not null,
    oprresult    oid                               not null,
    oprcom       oid                               not null,
    oprnegate    oid                               not null,
    oprcode      regproc                           not null,
    oprrest      regproc                           not null,
    oprjoin      regproc                           not null
);

create unique index pg_operator_oid_index
    on pg_catalog.pg_operator (oid);

create unique index pg_operator_oprname_l_r_n_index
    on pg_catalog.pg_operator (oprname collate "C", oprleft, oprright, oprnamespace);

create table pg_catalog.pg_opfamily
(
    oid          oid                               not null,
    opfmethod    oid                               not null,
    opfname      information_schema.sql_identifier not null,
    opfnamespace oid                               not null,
    opfowner     oid                               not null
);

create unique index pg_opfamily_am_name_nsp_index
    on pg_catalog.pg_opfamily (opfmethod, opfname collate "C", opfnamespace);

create unique index pg_opfamily_oid_index
    on pg_catalog.pg_opfamily (oid);

create table pg_catalog.pg_partitioned_table
(
    partrelid     oid        not null,
    partstrat     "char"     not null,
    partnatts     smallint   not null,
    partdefid     oid        not null,
    partattrs     int2vector not null,
    partclass     oidvector  not null,
    partcollation oidvector  not null,
    partexprs     pg_node_tree
);

create unique index pg_partitioned_table_partrelid_index
    on pg_catalog.pg_partitioned_table (partrelid);

create table pg_catalog.pg_policy
(
    oid           oid                               not null,
    polname       information_schema.sql_identifier not null,
    polrelid      oid                               not null,
    polcmd        "char"                            not null,
    polpermissive boolean                           not null,
    polroles      oid[]                             not null,
    polqual       pg_node_tree,
    polwithcheck  pg_node_tree
);

create unique index pg_policy_oid_index
    on pg_catalog.pg_policy (oid);

create unique index pg_policy_polrelid_polname_index
    on pg_catalog.pg_policy (polrelid, polname collate "C");

create table pg_catalog.pg_proc
(
    oid             oid                               not null,
    proname         information_schema.sql_identifier not null,
    pronamespace    oid                               not null,
    proowner        oid                               not null,
    prolang         oid                               not null,
    procost         real                              not null,
    prorows         real                              not null,
    provariadic     oid                               not null,
    prosupport      regproc                           not null,
    prokind         "char"                            not null,
    prosecdef       boolean                           not null,
    proleakproof    boolean                           not null,
    proisstrict     boolean                           not null,
    proretset       boolean                           not null,
    provolatile     "char"                            not null,
    proparallel     "char"                            not null,
    pronargs        smallint                          not null,
    pronargdefaults smallint                          not null,
    prorettype      oid                               not null,
    proargtypes     oidvector                         not null,
    proallargtypes  oid[],
    proargmodes     "char"[],
    proargnames     text[],
    proargdefaults  pg_node_tree,
    protrftypes     oid[],
    prosrc          text                              not null,
    probin          text,
    proconfig       text[],
    proacl          aclitem[]
);

create unique index pg_proc_oid_index
    on pg_catalog.pg_proc (oid);

create unique index pg_proc_proname_args_nsp_index
    on pg_catalog.pg_proc (proname collate "C", proargtypes, pronamespace);

create table pg_catalog.pg_publication
(
    oid          oid                               not null,
    pubname      information_schema.sql_identifier not null,
    pubowner     oid                               not null,
    puballtables boolean                           not null,
    pubinsert    boolean                           not null,
    pubupdate    boolean                           not null,
    pubdelete    boolean                           not null,
    pubtruncate  boolean                           not null,
    pubviaroot   boolean                           not null
);

create unique index pg_publication_oid_index
    on pg_catalog.pg_publication (oid);

create unique index pg_publication_pubname_index
    on pg_catalog.pg_publication (pubname collate "C");

create table pg_catalog.pg_publication_rel
(
    oid     oid not null,
    prpubid oid not null,
    prrelid oid not null
);

create unique index pg_publication_rel_oid_index
    on pg_catalog.pg_publication_rel (oid);

create unique index pg_publication_rel_prrelid_prpubid_index
    on pg_catalog.pg_publication_rel (prrelid, prpubid);

create table pg_catalog.pg_range
(
    rngtypid     oid     not null,
    rngsubtype   oid     not null,
    rngcollation oid     not null,
    rngsubopc    oid     not null,
    rngcanonical regproc not null,
    rngsubdiff   regproc not null
);

create unique index pg_range_rngtypid_index
    on pg_catalog.pg_range (rngtypid);

create table pg_catalog.pg_replication_origin
(
    roident oid  not null,
    roname  text not null
)
    tablespace pg_global;

create unique index pg_replication_origin_roiident_index
    on pg_catalog.pg_replication_origin (roident)
    tablespace pg_global;

create unique index pg_replication_origin_roname_index
    on pg_catalog.pg_replication_origin (roname collate "C")
    tablespace pg_global;

create table pg_catalog.pg_rewrite
(
    oid        oid                               not null,
    rulename   information_schema.sql_identifier not null,
    ev_class   oid                               not null,
    ev_type    "char"                            not null,
    ev_enabled "char"                            not null,
    is_instead boolean                           not null,
    ev_qual    pg_node_tree                      not null,
    ev_action  pg_node_tree                      not null
);

create unique index pg_rewrite_oid_index
    on pg_catalog.pg_rewrite (oid);

create unique index pg_rewrite_rel_rulename_index
    on pg_catalog.pg_rewrite (ev_class, rulename collate "C");

create table pg_catalog.pg_seclabel
(
    objoid   oid     not null,
    classoid oid     not null,
    objsubid integer not null,
    provider text    not null,
    label    text    not null
);

create unique index pg_seclabel_object_index
    on pg_catalog.pg_seclabel (objoid, classoid, objsubid, provider collate "C");

create table pg_catalog.pg_sequence
(
    seqrelid     oid     not null,
    seqtypid     oid     not null,
    seqstart     bigint  not null,
    seqincrement bigint  not null,
    seqmax       bigint  not null,
    seqmin       bigint  not null,
    seqcache     bigint  not null,
    seqcycle     boolean not null
);

create unique index pg_sequence_seqrelid_index
    on pg_catalog.pg_sequence (seqrelid);

create table pg_catalog.pg_shdepend
(
    dbid       oid     not null,
    classid    oid     not null,
    objid      oid     not null,
    objsubid   integer not null,
    refclassid oid     not null,
    refobjid   oid     not null,
    deptype    "char"  not null
)
    tablespace pg_global;

create index pg_shdepend_depender_index
    on pg_catalog.pg_shdepend (dbid, classid, objid, objsubid)
    tablespace pg_global;

create index pg_shdepend_reference_index
    on pg_catalog.pg_shdepend (refclassid, refobjid)
    tablespace pg_global;

create table pg_catalog.pg_shdescription
(
    objoid      oid  not null,
    classoid    oid  not null,
    description text not null
)
    tablespace pg_global;

create unique index pg_shdescription_o_c_index
    on pg_catalog.pg_shdescription (objoid, classoid)
    tablespace pg_global;

create table pg_catalog.pg_shseclabel
(
    objoid   oid  not null,
    classoid oid  not null,
    provider text not null,
    label    text not null
)
    tablespace pg_global;

create unique index pg_shseclabel_object_index
    on pg_catalog.pg_shseclabel (objoid, classoid, provider collate "C")
    tablespace pg_global;

create table pg_catalog.pg_statistic
(
    starelid    oid      not null,
    staattnum   smallint not null,
    stainherit  boolean  not null,
    stanullfrac real     not null,
    stawidth    integer  not null,
    stadistinct real     not null,
    stakind1    smallint not null,
    stakind2    smallint not null,
    stakind3    smallint not null,
    stakind4    smallint not null,
    stakind5    smallint not null,
    staop1      oid      not null,
    staop2      oid      not null,
    staop3      oid      not null,
    staop4      oid      not null,
    staop5      oid      not null,
    stacoll1    oid      not null,
    stacoll2    oid      not null,
    stacoll3    oid      not null,
    stacoll4    oid      not null,
    stacoll5    oid      not null,
    stanumbers1 real[],
    stanumbers2 real[],
    stanumbers3 real[],
    stanumbers4 real[],
    stanumbers5 real[],
    stavalues1  anyarray,
    stavalues2  anyarray,
    stavalues3  anyarray,
    stavalues4  anyarray,
    stavalues5  anyarray
);

create unique index pg_statistic_relid_att_inh_index
    on pg_catalog.pg_statistic (starelid, staattnum, stainherit);

create table pg_catalog.pg_statistic_ext
(
    oid           oid                               not null,
    stxrelid      oid                               not null,
    stxname       information_schema.sql_identifier not null,
    stxnamespace  oid                               not null,
    stxowner      oid                               not null,
    stxstattarget integer                           not null,
    stxkeys       int2vector                        not null,
    stxkind       "char"[]                          not null
);

create unique index pg_statistic_ext_name_index
    on pg_catalog.pg_statistic_ext (stxname collate "C", stxnamespace);

create unique index pg_statistic_ext_oid_index
    on pg_catalog.pg_statistic_ext (oid);

create index pg_statistic_ext_relid_index
    on pg_catalog.pg_statistic_ext (stxrelid);

create table pg_catalog.pg_statistic_ext_data
(
    stxoid           oid not null,
    stxdndistinct    pg_ndistinct,
    stxddependencies pg_dependencies,
    stxdmcv          pg_mcv_list
);

create unique index pg_statistic_ext_data_stxoid_index
    on pg_catalog.pg_statistic_ext_data (stxoid);

create table pg_catalog.pg_subscription
(
    oid             oid                               not null,
    subdbid         oid                               not null,
    subname         information_schema.sql_identifier not null,
    subowner        oid                               not null,
    subenabled      boolean                           not null,
    subconninfo     text                              not null,
    subslotname     information_schema.sql_identifier,
    subsynccommit   text                              not null,
    subpublications text[]                            not null
)
    tablespace pg_global;

create unique index pg_subscription_oid_index
    on pg_catalog.pg_subscription (oid)
    tablespace pg_global;

create unique index pg_subscription_subname_index
    on pg_catalog.pg_subscription (subdbid, subname collate "C")
    tablespace pg_global;

create table pg_catalog.pg_subscription_rel
(
    srsubid    oid    not null,
    srrelid    oid    not null,
    srsubstate "char" not null,
    srsublsn   pg_lsn
);

create unique index pg_subscription_rel_srrelid_srsubid_index
    on pg_catalog.pg_subscription_rel (srrelid, srsubid);

create table pg_catalog.pg_tablespace
(
    oid        oid                               not null,
    spcname    information_schema.sql_identifier not null,
    spcowner   oid                               not null,
    spcacl     aclitem[],
    spcoptions text[]
)
    tablespace pg_global;

create unique index pg_tablespace_oid_index
    on pg_catalog.pg_tablespace (oid)
    tablespace pg_global;

create unique index pg_tablespace_spcname_index
    on pg_catalog.pg_tablespace (spcname collate "C")
    tablespace pg_global;

create table pg_catalog.pg_transform
(
    oid        oid     not null,
    trftype    oid     not null,
    trflang    oid     not null,
    trffromsql regproc not null,
    trftosql   regproc not null
);

create unique index pg_transform_oid_index
    on pg_catalog.pg_transform (oid);

create unique index pg_transform_type_lang_index
    on pg_catalog.pg_transform (trftype, trflang);

create table pg_catalog.pg_trigger
(
    oid            oid                               not null,
    tgrelid        oid                               not null,
    tgparentid     oid                               not null,
    tgname         information_schema.sql_identifier not null,
    tgfoid         oid                               not null,
    tgtype         smallint                          not null,
    tgenabled      "char"                            not null,
    tgisinternal   boolean                           not null,
    tgconstrrelid  oid                               not null,
    tgconstrindid  oid                               not null,
    tgconstraint   oid                               not null,
    tgdeferrable   boolean                           not null,
    tginitdeferred boolean                           not null,
    tgnargs        smallint                          not null,
    tgattr         int2vector                        not null,
    tgargs         bytea                             not null,
    tgqual         pg_node_tree,
    tgoldtable     information_schema.sql_identifier,
    tgnewtable     information_schema.sql_identifier
);

create unique index pg_trigger_oid_index
    on pg_catalog.pg_trigger (oid);

create index pg_trigger_tgconstraint_index
    on pg_catalog.pg_trigger (tgconstraint);

create unique index pg_trigger_tgrelid_tgname_index
    on pg_catalog.pg_trigger (tgrelid, tgname collate "C");

create table pg_catalog.pg_ts_config
(
    oid          oid                               not null,
    cfgname      information_schema.sql_identifier not null,
    cfgnamespace oid                               not null,
    cfgowner     oid                               not null,
    cfgparser    oid                               not null
);

create unique index pg_ts_config_cfgname_index
    on pg_catalog.pg_ts_config (cfgname collate "C", cfgnamespace);

create unique index pg_ts_config_oid_index
    on pg_catalog.pg_ts_config (oid);

create table pg_catalog.pg_ts_config_map
(
    mapcfg       oid     not null,
    maptokentype integer not null,
    mapseqno     integer not null,
    mapdict      oid     not null
);

create unique index pg_ts_config_map_index
    on pg_catalog.pg_ts_config_map (mapcfg, maptokentype, mapseqno);

create table pg_catalog.pg_ts_dict
(
    oid            oid                               not null,
    dictname       information_schema.sql_identifier not null,
    dictnamespace  oid                               not null,
    dictowner      oid                               not null,
    dicttemplate   oid                               not null,
    dictinitoption text
);

create unique index pg_ts_dict_dictname_index
    on pg_catalog.pg_ts_dict (dictname collate "C", dictnamespace);

create unique index pg_ts_dict_oid_index
    on pg_catalog.pg_ts_dict (oid);

create table pg_catalog.pg_ts_parser
(
    oid          oid                               not null,
    prsname      information_schema.sql_identifier not null,
    prsnamespace oid                               not null,
    prsstart     regproc                           not null,
    prstoken     regproc                           not null,
    prsend       regproc                           not null,
    prsheadline  regproc                           not null,
    prslextype   regproc                           not null
);

create unique index pg_ts_parser_oid_index
    on pg_catalog.pg_ts_parser (oid);

create unique index pg_ts_parser_prsname_index
    on pg_catalog.pg_ts_parser (prsname collate "C", prsnamespace);

create table pg_catalog.pg_ts_template
(
    oid           oid                               not null,
    tmplname      information_schema.sql_identifier not null,
    tmplnamespace oid                               not null,
    tmplinit      regproc                           not null,
    tmpllexize    regproc                           not null
);

create unique index pg_ts_template_oid_index
    on pg_catalog.pg_ts_template (oid);

create unique index pg_ts_template_tmplname_index
    on pg_catalog.pg_ts_template (tmplname collate "C", tmplnamespace);

create table pg_catalog.pg_type
(
    oid            oid                               not null,
    typname        information_schema.sql_identifier not null,
    typnamespace   oid                               not null,
    typowner       oid                               not null,
    typlen         smallint                          not null,
    typbyval       boolean                           not null,
    typtype        "char"                            not null,
    typcategory    "char"                            not null,
    typispreferred boolean                           not null,
    typisdefined   boolean                           not null,
    typdelim       "char"                            not null,
    typrelid       oid                               not null,
    typelem        oid                               not null,
    typarray       oid                               not null,
    typinput       regproc                           not null,
    typoutput      regproc                           not null,
    typreceive     regproc                           not null,
    typsend        regproc                           not null,
    typmodin       regproc                           not null,
    typmodout      regproc                           not null,
    typanalyze     regproc                           not null,
    typalign       "char"                            not null,
    typstorage     "char"                            not null,
    typnotnull     boolean                           not null,
    typbasetype    oid                               not null,
    typtypmod      integer                           not null,
    typndims       integer                           not null,
    typcollation   oid                               not null,
    typdefaultbin  pg_node_tree,
    typdefault     text,
    typacl         aclitem[]
);

create unique index pg_type_oid_index
    on pg_catalog.pg_type (oid);

create unique index pg_type_typname_nsp_index
    on pg_catalog.pg_type (typname collate "C", typnamespace);

create table pg_catalog.pg_user_mapping
(
    oid       oid not null,
    umuser    oid not null,
    umserver  oid not null,
    umoptions text[]
);

create unique index pg_user_mapping_oid_index
    on pg_catalog.pg_user_mapping (oid);

create unique index pg_user_mapping_user_server_index
    on pg_catalog.pg_user_mapping (umuser, umserver);

create table information_schema.sql_features
(
    feature_id       information_schema.character_data,
    feature_name     information_schema.character_data,
    sub_feature_id   information_schema.character_data,
    sub_feature_name information_schema.character_data,
    is_supported     information_schema.yes_or_no,
    is_verified_by   information_schema.character_data,
    comments         information_schema.character_data
);

create table information_schema.sql_implementation_info
(
    implementation_info_id   information_schema.character_data,
    implementation_info_name information_schema.character_data,
    integer_value            information_schema.cardinal_number,
    character_value          information_schema.character_data,
    comments                 information_schema.character_data
);

create table information_schema.sql_parts
(
    feature_id     information_schema.character_data,
    feature_name   information_schema.character_data,
    is_supported   information_schema.yes_or_no,
    is_verified_by information_schema.character_data,
    comments       information_schema.character_data
);

create table information_schema.sql_sizing
(
    sizing_id       information_schema.cardinal_number,
    sizing_name     information_schema.character_data,
    supported_value information_schema.cardinal_number,
    comments        information_schema.character_data
);

create view geography_columns
            (f_table_catalog, f_table_schema, f_table_name, f_geography_column, coord_dimension, srid, type) as
SELECT current_database()               AS f_table_catalog,
       n.nspname                        AS f_table_schema,
       c.relname                        AS f_table_name,
       a.attname                        AS f_geography_column,
       postgis_typmod_dims(a.atttypmod) AS coord_dimension,
       postgis_typmod_srid(a.atttypmod) AS srid,
       postgis_typmod_type(a.atttypmod) AS type
FROM pg_class c,
     pg_attribute a,
     pg_type t,
     pg_namespace n
WHERE t.typname = 'geography'::name
  AND a.attisdropped = false
  AND a.atttypid = t.oid
  AND a.attrelid = c.oid
  AND c.relnamespace = n.oid
  AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'm'::"char", 'f'::"char", 'p'::"char"]))
  AND NOT pg_is_other_temp_schema(c.relnamespace)
  AND has_table_privilege(c.oid, 'SELECT'::text);

alter table geography_columns
    owner to postgres;

grant select on geography_columns to public;

create view geometry_columns
            (f_table_catalog, f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, type) as
SELECT current_database()::character varying(256)                                                                     AS f_table_catalog,
       n.nspname                                                                                                      AS f_table_schema,
       c.relname                                                                                                      AS f_table_name,
       a.attname                                                                                                      AS f_geometry_column,
       COALESCE(postgis_typmod_dims(a.atttypmod), sn.ndims, 2)                                                        AS coord_dimension,
       COALESCE(NULLIF(postgis_typmod_srid(a.atttypmod), 0), sr.srid,
                0)                                                                                                    AS srid,
       replace(replace(COALESCE(NULLIF(upper(postgis_typmod_type(a.atttypmod)), 'GEOMETRY'::text), st.type,
                                'GEOMETRY'::text), 'ZM'::text, ''::text), 'Z'::text,
               ''::text)::character varying(30)                                                                       AS type
FROM pg_class c
         JOIN pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped
         JOIN pg_namespace n ON c.relnamespace = n.oid
         JOIN pg_type t ON a.atttypid = t.oid
         LEFT JOIN (SELECT s.connamespace,
                           s.conrelid,
                           s.conkey,
                           replace(split_part(s.consrc, ''''::text, 2), ')'::text, ''::text) AS type
                    FROM (SELECT pg_constraint.connamespace,
                                 pg_constraint.conrelid,
                                 pg_constraint.conkey,
                                 pg_get_constraintdef(pg_constraint.oid) AS consrc
                          FROM pg_constraint) s
                    WHERE s.consrc ~~* '%geometrytype(% = %'::text) st
                   ON st.connamespace = n.oid AND st.conrelid = c.oid AND (a.attnum = ANY (st.conkey))
         LEFT JOIN (SELECT s.connamespace,
                           s.conrelid,
                           s.conkey,
                           replace(split_part(s.consrc, ' = '::text, 2), ')'::text, ''::text)::integer AS ndims
                    FROM (SELECT pg_constraint.connamespace,
                                 pg_constraint.conrelid,
                                 pg_constraint.conkey,
                                 pg_get_constraintdef(pg_constraint.oid) AS consrc
                          FROM pg_constraint) s
                    WHERE s.consrc ~~* '%ndims(% = %'::text) sn
                   ON sn.connamespace = n.oid AND sn.conrelid = c.oid AND (a.attnum = ANY (sn.conkey))
         LEFT JOIN (SELECT s.connamespace,
                           s.conrelid,
                           s.conkey,
                           replace(replace(split_part(s.consrc, ' = '::text, 2), ')'::text, ''::text), '('::text,
                                   ''::text)::integer AS srid
                    FROM (SELECT pg_constraint.connamespace,
                                 pg_constraint.conrelid,
                                 pg_constraint.conkey,
                                 pg_get_constraintdef(pg_constraint.oid) AS consrc
                          FROM pg_constraint) s
                    WHERE s.consrc ~~* '%srid(% = %'::text) sr
                   ON sr.connamespace = n.oid AND sr.conrelid = c.oid AND (a.attnum = ANY (sr.conkey))
WHERE (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'm'::"char", 'f'::"char", 'p'::"char"]))
  AND NOT c.relname = 'raster_columns'::name
  AND t.typname = 'geometry'::name
  AND NOT pg_is_other_temp_schema(c.relnamespace)
  AND has_table_privilege(c.oid, 'SELECT'::text);

alter table geometry_columns
    owner to postgres;

CREATE RULE geometry_columns_insert AS
    ON INSERT TO geometry_columns DO INSTEAD NOTHING;

CREATE RULE geometry_columns_update AS
    ON UPDATE TO geometry_columns DO INSTEAD NOTHING;

CREATE RULE geometry_columns_delete AS
    ON DELETE TO geometry_columns DO INSTEAD NOTHING;

grant select on geometry_columns to public;

create view raster_columns
            (r_table_catalog, r_table_schema, r_table_name, r_raster_column, srid, scale_x, scale_y, blocksize_x,
             blocksize_y, same_alignment, regular_blocking, num_bands, pixel_types, nodata_values, out_db, extent,
             spatial_index)
as
SELECT current_database()                                                                            AS r_table_catalog,
       n.nspname                                                                                     AS r_table_schema,
       c.relname                                                                                     AS r_table_name,
       a.attname                                                                                     AS r_raster_column,
       COALESCE(_raster_constraint_info_srid(n.nspname, c.relname, a.attname),
           (SELECT st_srid('010100000000000000000000000000000000000000'::geometry) AS st_srid)) AS srid,
        _raster_constraint_info_scale(n.nspname, c.relname, a.attname, 'x'::bpchar)                   AS scale_x,
        _raster_constraint_info_scale(n.nspname, c.relname, a.attname, 'y'::bpchar)                   AS scale_y,
        _raster_constraint_info_blocksize(n.nspname, c.relname, a.attname, 'width'::text)             AS blocksize_x,
        _raster_constraint_info_blocksize(n.nspname, c.relname, a.attname, 'height'::text)            AS blocksize_y,
        COALESCE(_raster_constraint_info_alignment(n.nspname, c.relname, a.attname), false)           AS same_alignment,
        COALESCE(_raster_constraint_info_regular_blocking(n.nspname, c.relname, a.attname),
        false)                                                                               AS regular_blocking,
        _raster_constraint_info_num_bands(n.nspname, c.relname, a.attname)                            AS num_bands,
        _raster_constraint_info_pixel_types(n.nspname, c.relname, a.attname)                          AS pixel_types,
        _raster_constraint_info_nodata_values(n.nspname, c.relname, a.attname)                        AS nodata_values,
        _raster_constraint_info_out_db(n.nspname, c.relname, a.attname)                               AS out_db,
        _raster_constraint_info_extent(n.nspname, c.relname, a.attname)                               AS extent,
        COALESCE(_raster_constraint_info_index(n.nspname, c.relname, a.attname), false)               AS spatial_index
        FROM pg_class c,
        pg_attribute a,
        pg_type t,
        pg_namespace n
        WHERE t.typname = 'raster'::name
        AND a.attisdropped = false
        AND a.atttypid = t.oid
        AND a.attrelid = c.oid
        AND c.relnamespace = n.oid
        AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'm'::"char", 'f'::"char", 'p'::"char"]))
        AND NOT pg_is_other_temp_schema(c.relnamespace)
        AND has_table_privilege(c.oid, 'SELECT'::text);

alter table raster_columns
    owner to postgres;

grant select on raster_columns to public;

create view raster_overviews
            (o_table_catalog, o_table_schema, o_table_name, o_raster_column, r_table_catalog, r_table_schema,
             r_table_name, r_raster_column, overview_factor)
as
SELECT current_database()                                                         AS o_table_catalog,
       n.nspname                                                                  AS o_table_schema,
       c.relname                                                                  AS o_table_name,
       a.attname                                                                  AS o_raster_column,
       current_database()                                                         AS r_table_catalog,
       split_part(split_part(s.consrc, '''::name'::text, 1), ''''::text, 2)::name AS r_table_schema,
        split_part(split_part(s.consrc, '''::name'::text, 2), ''''::text, 2)::name AS r_table_name,
        split_part(split_part(s.consrc, '''::name'::text, 3), ''''::text, 2)::name AS r_raster_column,
        btrim(split_part(s.consrc, ','::text, 2))::integer                         AS overview_factor
FROM pg_class c,
     pg_attribute a,
     pg_type t,
     pg_namespace n,
     (SELECT pg_constraint.connamespace,
             pg_constraint.conrelid,
             pg_constraint.conkey,
             pg_get_constraintdef(pg_constraint.oid) AS consrc
      FROM pg_constraint) s
WHERE t.typname = 'raster'::name
  AND a.attisdropped = false
  AND a.atttypid = t.oid
  AND a.attrelid = c.oid
  AND c.relnamespace = n.oid
  AND (c.relkind::text = ANY
       (ARRAY ['r'::character(1), 'v'::character(1), 'm'::character(1), 'f'::character(1)]::text[]))
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND s.consrc ~~ '%_overview_constraint(%'::text
  AND NOT pg_is_other_temp_schema(c.relnamespace)
  AND has_table_privilege(c.oid, 'SELECT'::text);

alter table raster_overviews
    owner to postgres;

grant select on raster_overviews to public;

create view authority_menu
            (id, path, name, icon, sort, title, title_en, title_cht, hidden, parent_id, component, keep_alive,
             created_at, updated_at, deleted_at, menu_level, default_menu, close_tab, menu_id, authority_id)
as
SELECT sys_base_menus.id,
       sys_base_menus.path,
       sys_base_menus.name,
       sys_base_menus.icon,
       sys_base_menus.sort,
       sys_base_menus.title,
       sys_base_menus.title_en,
       sys_base_menus.title_cht,
       sys_base_menus.hidden,
       sys_base_menus.parent_id,
       sys_base_menus.component,
       sys_base_menus.keep_alive,
       sys_base_menus.created_at,
       sys_base_menus.updated_at,
       sys_base_menus.deleted_at,
       sys_base_menus.menu_level,
       sys_base_menus.default_menu,
       sys_base_menus.close_tab,
       sys_authority_menus.sys_base_menu_id           AS menu_id,
       sys_authority_menus.sys_authority_authority_id AS authority_id
FROM sys_authority_menus
         JOIN sys_base_menus ON sys_authority_menus.sys_base_menu_id = sys_base_menus.id;

alter table authority_menu
    owner to postgres;

create view information_schema._pg_foreign_data_wrappers
            (oid, fdwowner, fdwoptions, foreign_data_wrapper_catalog, foreign_data_wrapper_name,
             authorization_identifier, foreign_data_wrapper_language)
as
-- missing source code
;

create view information_schema._pg_foreign_servers
            (oid, srvoptions, foreign_server_catalog, foreign_server_name, foreign_data_wrapper_catalog,
             foreign_data_wrapper_name, foreign_server_type, foreign_server_version, authorization_identifier)
as
-- missing source code
;

create view information_schema._pg_foreign_table_columns(nspname, relname, attname, attfdwoptions) as
-- missing source code
;

create view information_schema._pg_foreign_tables
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, ftoptions, foreign_server_catalog,
             foreign_server_name, authorization_identifier)
as
-- missing source code
;

create view information_schema._pg_user_mappings
            (oid, umoptions, umuser, authorization_identifier, foreign_server_catalog, foreign_server_name, srvowner) as
-- missing source code
;

create view information_schema.administrable_role_authorizations(grantee, role_name, is_grantable) as
-- missing source code
;

create view information_schema.applicable_roles(grantee, role_name, is_grantable) as
-- missing source code
;

create view information_schema.attributes
            (udt_catalog, udt_schema, udt_name, attribute_name, ordinal_position, attribute_default, is_nullable,
             data_type, character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             attribute_udt_catalog, attribute_udt_schema, attribute_udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, is_derived_reference_attribute)
as
-- missing source code
;

create view information_schema.character_sets
            (character_set_catalog, character_set_schema, character_set_name, character_repertoire, form_of_use,
             default_collate_catalog, default_collate_schema, default_collate_name)
as
-- missing source code
;

create view information_schema.check_constraint_routine_usage
            (constraint_catalog, constraint_schema, constraint_name, specific_catalog, specific_schema,
             specific_name) as
-- missing source code
;

create view information_schema.check_constraints(constraint_catalog, constraint_schema, constraint_name, check_clause) as
-- missing source code
;

create view information_schema.collation_character_set_applicability
            (collation_catalog, collation_schema, collation_name, character_set_catalog, character_set_schema,
             character_set_name) as
-- missing source code
;

create view information_schema.collations(collation_catalog, collation_schema, collation_name, pad_attribute) as
-- missing source code
;

create view information_schema.column_column_usage
            (table_catalog, table_schema, table_name, column_name, dependent_column) as
-- missing source code
;

create view information_schema.column_domain_usage
            (domain_catalog, domain_schema, domain_name, table_catalog, table_schema, table_name, column_name) as
-- missing source code
;

create view information_schema.column_options
            (table_catalog, table_schema, table_name, column_name, option_name, option_value) as
-- missing source code
;

create view information_schema.column_privileges
            (grantor, grantee, table_catalog, table_schema, table_name, column_name, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.column_udt_usage
            (udt_catalog, udt_schema, udt_name, table_catalog, table_schema, table_name, column_name) as
-- missing source code
;

create view information_schema.columns
            (table_catalog, table_schema, table_name, column_name, ordinal_position, column_default, is_nullable,
             data_type, character_maximum_length, character_octet_length, numeric_precision, numeric_precision_radix,
             numeric_scale, datetime_precision, interval_type, interval_precision, character_set_catalog,
             character_set_schema, character_set_name, collation_catalog, collation_schema, collation_name,
             domain_catalog, domain_schema, domain_name, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema,
             scope_name, maximum_cardinality, dtd_identifier, is_self_referencing, is_identity, identity_generation,
             identity_start, identity_increment, identity_maximum, identity_minimum, identity_cycle, is_generated,
             generation_expression, is_updatable)
as
-- missing source code
;

create view information_schema.constraint_column_usage
            (table_catalog, table_schema, table_name, column_name, constraint_catalog, constraint_schema,
             constraint_name) as
-- missing source code
;

create view information_schema.constraint_table_usage
            (table_catalog, table_schema, table_name, constraint_catalog, constraint_schema, constraint_name) as
-- missing source code
;

create view information_schema.data_type_privileges
            (object_catalog, object_schema, object_name, object_type, dtd_identifier) as
-- missing source code
;

create view information_schema.domain_constraints
            (constraint_catalog, constraint_schema, constraint_name, domain_catalog, domain_schema, domain_name,
             is_deferrable, initially_deferred)
as
-- missing source code
;

create view information_schema.domain_udt_usage
            (udt_catalog, udt_schema, udt_name, domain_catalog, domain_schema, domain_name) as
-- missing source code
;

create view information_schema.domains
            (domain_catalog, domain_schema, domain_name, data_type, character_maximum_length, character_octet_length,
             character_set_catalog, character_set_schema, character_set_name, collation_catalog, collation_schema,
             collation_name, numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision,
             interval_type, interval_precision, domain_default, udt_catalog, udt_schema, udt_name, scope_catalog,
             scope_schema, scope_name, maximum_cardinality, dtd_identifier)
as
-- missing source code
;

create view information_schema.element_types
            (object_catalog, object_schema, object_name, object_type, collection_type_identifier, data_type,
             character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             domain_default, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier)
as
-- missing source code
;

create view information_schema.enabled_roles(role_name) as
-- missing source code
;

create view information_schema.foreign_data_wrapper_options
            (foreign_data_wrapper_catalog, foreign_data_wrapper_name, option_name, option_value) as
-- missing source code
;

create view information_schema.foreign_data_wrappers
            (foreign_data_wrapper_catalog, foreign_data_wrapper_name, authorization_identifier, library_name,
             foreign_data_wrapper_language)
as
-- missing source code
;

create view information_schema.foreign_server_options
            (foreign_server_catalog, foreign_server_name, option_name, option_value) as
-- missing source code
;

create view information_schema.foreign_servers
            (foreign_server_catalog, foreign_server_name, foreign_data_wrapper_catalog, foreign_data_wrapper_name,
             foreign_server_type, foreign_server_version, authorization_identifier)
as
-- missing source code
;

create view information_schema.foreign_table_options
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, option_name, option_value) as
-- missing source code
;

create view information_schema.foreign_tables
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, foreign_server_catalog,
             foreign_server_name) as
-- missing source code
;

create view information_schema.information_schema_catalog_name(catalog_name) as
-- missing source code
;

create view information_schema.key_column_usage
            (constraint_catalog, constraint_schema, constraint_name, table_catalog, table_schema, table_name,
             column_name, ordinal_position, position_in_unique_constraint)
as
-- missing source code
;

create view information_schema.parameters
            (specific_catalog, specific_schema, specific_name, ordinal_position, parameter_mode, is_result, as_locator,
             parameter_name, data_type, character_maximum_length, character_octet_length, character_set_catalog,
             character_set_schema, character_set_name, collation_catalog, collation_schema, collation_name,
             numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision, interval_type,
             interval_precision, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, parameter_default)
as
-- missing source code
;

create view pg_catalog.pg_available_extension_versions
            (name, version, installed, superuser, trusted, relocatable, schema, requires, comment) as
-- missing source code
;

create view pg_catalog.pg_available_extensions(name, default_version, installed_version, comment) as
-- missing source code
;

create view pg_catalog.pg_config(name, setting) as
-- missing source code
;

create view pg_catalog.pg_cursors(name, statement, is_holdable, is_binary, is_scrollable, creation_time) as
-- missing source code
;

create view pg_catalog.pg_file_settings(sourcefile, sourceline, seqno, name, setting, applied, error) as
-- missing source code
;

create view pg_catalog.pg_group(groname, grosysid, grolist) as
-- missing source code
;

create view pg_catalog.pg_hba_file_rules
            (line_number, type, database, user_name, address, netmask, auth_method, options, error) as
-- missing source code
;

create view pg_catalog.pg_indexes(schemaname, tablename, indexname, tablespace, indexdef) as
-- missing source code
;

create view pg_catalog.pg_locks
            (locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid,
             virtualtransaction, pid, mode, granted, fastpath)
as
-- missing source code
;

create view pg_catalog.pg_matviews
            (schemaname, matviewname, matviewowner, tablespace, hasindexes, ispopulated, definition) as
-- missing source code
;

create view pg_catalog.pg_policies (schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check) as
-- missing source code
;

create view pg_catalog.pg_prepared_statements(name, statement, prepare_time, parameter_types, from_sql) as
-- missing source code
;

create view pg_catalog.pg_prepared_xacts(transaction, gid, prepared, owner, database) as
-- missing source code
;

create view pg_catalog.pg_publication_tables(pubname, schemaname, tablename) as
-- missing source code
;

create view pg_catalog.pg_replication_origin_status(local_id, external_id, remote_lsn, local_lsn) as
-- missing source code
;

create view pg_catalog.pg_replication_slots
            (slot_name, plugin, slot_type, datoid, database, temporary, active, active_pid, xmin, catalog_xmin,
             restart_lsn, confirmed_flush_lsn, wal_status, safe_wal_size)
as
-- missing source code
;

create view pg_catalog.pg_roles
            (rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb, rolcanlogin, rolreplication, rolconnlimit,
             rolpassword, rolvaliduntil, rolbypassrls, rolconfig, oid)
as
-- missing source code
;

create view pg_catalog.pg_rules(schemaname, tablename, rulename, definition) as
-- missing source code
;

create view pg_catalog.pg_seclabels (objoid, classoid, objsubid, objtype, objnamespace, objname, provider, label) as
-- missing source code
;

create view pg_catalog.pg_sequences
            (schemaname, sequencename, sequenceowner, data_type, start_value, min_value, max_value, increment_by, cycle,
             cache_size, last_value)
as
-- missing source code
;

create view pg_catalog.pg_settings
            (name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val,
             enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart)
as
-- missing source code
;

create rule pg_catalog.pg_settings_n as
    on update to pg_catalog.pg_settings
                  do instead -- missing source code
;

create rule pg_catalog.pg_settings_u as
    on update to pg_catalog.pg_settings
                  do also -- missing source code
;

create view pg_catalog.pg_shadow
            (usename, usesysid, usecreatedb, usesuper, userepl, usebypassrls, passwd, valuntil, useconfig) as
-- missing source code
;

create view pg_catalog.pg_shmem_allocations(name, "off", size, allocated_size) as
-- missing source code
;

create view pg_catalog.pg_stat_activity
            (datid, datname, pid, leader_pid, usesysid, usename, application_name, client_addr, client_hostname,
             client_port, backend_start, xact_start, query_start, state_change, wait_event_type, wait_event, state,
             backend_xid, backend_xmin, query, backend_type)
as
-- missing source code
;

create view pg_catalog.pg_stat_all_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
-- missing source code
;

create view pg_catalog.pg_stat_all_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, n_ins_since_vacuum, last_vacuum,
             last_autovacuum, last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
             autoanalyze_count)
as
-- missing source code
;

create view pg_catalog.pg_stat_archiver
            (archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal, last_failed_time,
             stats_reset) as
-- missing source code
;

create view pg_catalog.pg_stat_bgwriter
            (checkpoints_timed, checkpoints_req, checkpoint_write_time, checkpoint_sync_time, buffers_checkpoint,
             buffers_clean, maxwritten_clean, buffers_backend, buffers_backend_fsync, buffers_alloc, stats_reset)
as
-- missing source code
;

create view pg_catalog.pg_stat_database
            (datid, datname, numbackends, xact_commit, xact_rollback, blks_read, blks_hit, tup_returned, tup_fetched,
             tup_inserted, tup_updated, tup_deleted, conflicts, temp_files, temp_bytes, deadlocks, checksum_failures,
             checksum_last_failure, blk_read_time, blk_write_time, stats_reset)
as
-- missing source code
;

create view pg_catalog.pg_stat_database_conflicts
            (datid, datname, confl_tablespace, confl_lock, confl_snapshot, confl_bufferpin, confl_deadlock) as
-- missing source code
;

create view pg_catalog.pg_stat_gssapi(pid, gss_authenticated, principal, encrypted) as
-- missing source code
;

create view pg_catalog.pg_stat_progress_analyze
            (pid, datid, datname, relid, phase, sample_blks_total, sample_blks_scanned, ext_stats_total,
             ext_stats_computed, child_tables_total, child_tables_done, current_child_table_relid)
as
-- missing source code
;

create view pg_catalog.pg_stat_progress_basebackup
            (pid, phase, backup_total, backup_streamed, tablespaces_total, tablespaces_streamed) as
-- missing source code
;

create view pg_catalog.pg_stat_progress_cluster
            (pid, datid, datname, relid, command, phase, cluster_index_relid, heap_tuples_scanned, heap_tuples_written,
             heap_blks_total, heap_blks_scanned, index_rebuild_count)
as
-- missing source code
;

create view pg_catalog.pg_stat_progress_create_index
            (pid, datid, datname, relid, index_relid, command, phase, lockers_total, lockers_done, current_locker_pid,
             blocks_total, blocks_done, tuples_total, tuples_done, partitions_total, partitions_done)
as
-- missing source code
;

create view pg_catalog.pg_stat_progress_vacuum
            (pid, datid, datname, relid, phase, heap_blks_total, heap_blks_scanned, heap_blks_vacuumed,
             index_vacuum_count, max_dead_tuples, num_dead_tuples)
as
-- missing source code
;

create view pg_catalog.pg_stat_replication
            (pid, usesysid, usename, application_name, client_addr, client_hostname, client_port, backend_start,
             backend_xmin, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag, flush_lag, replay_lag,
             sync_priority, sync_state, reply_time)
as
-- missing source code
;

create view pg_catalog.pg_stat_slru
            (name, blks_zeroed, blks_hit, blks_read, blks_written, blks_exists, flushes, truncates, stats_reset) as
-- missing source code
;

create view pg_catalog.pg_stat_ssl
            (pid, ssl, version, cipher, bits, compression, client_dn, client_serial, issuer_dn) as
-- missing source code
;

create view pg_catalog.pg_stat_subscription
            (subid, subname, pid, relid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn,
             latest_end_time) as
-- missing source code
;

create view pg_catalog.pg_stat_sys_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
-- missing source code
;

create view pg_catalog.pg_stat_sys_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, n_ins_since_vacuum, last_vacuum,
             last_autovacuum, last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
             autoanalyze_count)
as
-- missing source code
;

create view pg_catalog.pg_stat_user_functions(funcid, schemaname, funcname, calls, total_time, self_time) as
-- missing source code
;

create view pg_catalog.pg_stat_user_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
-- missing source code
;

create view pg_catalog.pg_stat_user_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, n_ins_since_vacuum, last_vacuum,
             last_autovacuum, last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
             autoanalyze_count)
as
-- missing source code
;

create view pg_catalog.pg_stat_wal_receiver
            (pid, status, receive_start_lsn, receive_start_tli, written_lsn, flushed_lsn, received_tli,
             last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time, slot_name, sender_host,
             sender_port, conninfo)
as
-- missing source code
;

create view pg_catalog.pg_stat_xact_all_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
-- missing source code
;

create view pg_catalog.pg_stat_xact_sys_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
-- missing source code
;

create view pg_catalog.pg_stat_xact_user_functions(funcid, schemaname, funcname, calls, total_time, self_time) as
-- missing source code
;

create view pg_catalog.pg_stat_xact_user_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
-- missing source code
;

create view pg_catalog.pg_statio_all_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_all_sequences(relid, schemaname, relname, blks_read, blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_all_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
-- missing source code
;

create view pg_catalog.pg_statio_sys_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_sys_sequences(relid, schemaname, relname, blks_read, blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_sys_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
-- missing source code
;

create view pg_catalog.pg_statio_user_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_user_sequences(relid, schemaname, relname, blks_read, blks_hit) as
-- missing source code
;

create view pg_catalog.pg_statio_user_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
-- missing source code
;

create view pg_catalog.pg_stats
            (schemaname, tablename, attname, inherited, null_frac, avg_width, n_distinct, most_common_vals,
             most_common_freqs, histogram_bounds, correlation, most_common_elems, most_common_elem_freqs,
             elem_count_histogram)
as
-- missing source code
;

create view pg_catalog.pg_stats_ext
            (schemaname, tablename, statistics_schemaname, statistics_name, statistics_owner, attnames, kinds,
             n_distinct, dependencies, most_common_vals, most_common_val_nulls, most_common_freqs,
             most_common_base_freqs)
as
-- missing source code
;

create view pg_catalog.pg_tables
            (schemaname, tablename, tableowner, tablespace, hasindexes, hasrules, hastriggers, rowsecurity) as
-- missing source code
;

create view pg_catalog.pg_timezone_abbrevs(abbrev, utc_offset, is_dst) as
-- missing source code
;

create view pg_catalog.pg_timezone_names(name, abbrev, utc_offset, is_dst) as
-- missing source code
;

create view pg_catalog.pg_user
            (usename, usesysid, usecreatedb, usesuper, userepl, usebypassrls, passwd, valuntil, useconfig) as
-- missing source code
;

create view pg_catalog.pg_user_mappings(umid, srvid, srvname, umuser, usename, umoptions) as
-- missing source code
;

create view pg_catalog.pg_views(schemaname, viewname, viewowner, definition) as
-- missing source code
;

create view information_schema.referential_constraints
            (constraint_catalog, constraint_schema, constraint_name, unique_constraint_catalog,
             unique_constraint_schema, unique_constraint_name, match_option, update_rule, delete_rule)
as
-- missing source code
;

create view information_schema.role_column_grants
            (grantor, grantee, table_catalog, table_schema, table_name, column_name, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.role_routine_grants
            (grantor, grantee, specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema,
             routine_name, privilege_type, is_grantable)
as
-- missing source code
;

create view information_schema.role_table_grants
            (grantor, grantee, table_catalog, table_schema, table_name, privilege_type, is_grantable, with_hierarchy) as
-- missing source code
;

create view information_schema.role_udt_grants
            (grantor, grantee, udt_catalog, udt_schema, udt_name, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.role_usage_grants
            (grantor, grantee, object_catalog, object_schema, object_name, object_type, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.routine_privileges
            (grantor, grantee, specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema,
             routine_name, privilege_type, is_grantable)
as
-- missing source code
;

create view information_schema.routines
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name,
             routine_type, module_catalog, module_schema, module_name, udt_catalog, udt_schema, udt_name, data_type,
             character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             type_udt_catalog, type_udt_schema, type_udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, routine_body, routine_definition, external_name, external_language,
             parameter_style, is_deterministic, sql_data_access, is_null_call, sql_path, schema_level_routine,
             max_dynamic_result_sets, is_user_defined_cast, is_implicitly_invocable, security_type,
             to_sql_specific_catalog, to_sql_specific_schema, to_sql_specific_name, as_locator, created, last_altered,
             new_savepoint_level, is_udt_dependent, result_cast_from_data_type, result_cast_as_locator,
             result_cast_char_max_length, result_cast_char_octet_length, result_cast_char_set_catalog,
             result_cast_char_set_schema, result_cast_char_set_name, result_cast_collation_catalog,
             result_cast_collation_schema, result_cast_collation_name, result_cast_numeric_precision,
             result_cast_numeric_precision_radix, result_cast_numeric_scale, result_cast_datetime_precision,
             result_cast_interval_type, result_cast_interval_precision, result_cast_type_udt_catalog,
             result_cast_type_udt_schema, result_cast_type_udt_name, result_cast_scope_catalog,
             result_cast_scope_schema, result_cast_scope_name, result_cast_maximum_cardinality,
             result_cast_dtd_identifier)
as
-- missing source code
;

create view information_schema.schemata
            (catalog_name, schema_name, schema_owner, default_character_set_catalog, default_character_set_schema,
             default_character_set_name, sql_path)
as
-- missing source code
;

create view information_schema.sequences
            (sequence_catalog, sequence_schema, sequence_name, data_type, numeric_precision, numeric_precision_radix,
             numeric_scale, start_value, minimum_value, maximum_value, increment, cycle_option)
as
-- missing source code
;

create view information_schema.table_constraints
            (constraint_catalog, constraint_schema, constraint_name, table_catalog, table_schema, table_name,
             constraint_type, is_deferrable, initially_deferred, enforced)
as
-- missing source code
;

create view information_schema.table_privileges
            (grantor, grantee, table_catalog, table_schema, table_name, privilege_type, is_grantable, with_hierarchy) as
-- missing source code
;

create view information_schema.tables
            (table_catalog, table_schema, table_name, table_type, self_referencing_column_name, reference_generation,
             user_defined_type_catalog, user_defined_type_schema, user_defined_type_name, is_insertable_into, is_typed,
             commit_action)
as
-- missing source code
;

create view information_schema.transforms
            (udt_catalog, udt_schema, udt_name, specific_catalog, specific_schema, specific_name, group_name,
             transform_type) as
-- missing source code
;

create view information_schema.triggered_update_columns
            (trigger_catalog, trigger_schema, trigger_name, event_object_catalog, event_object_schema,
             event_object_table, event_object_column)
as
-- missing source code
;

create view information_schema.triggers
            (trigger_catalog, trigger_schema, trigger_name, event_manipulation, event_object_catalog,
             event_object_schema, event_object_table, action_order, action_condition, action_statement,
             action_orientation, action_timing, action_reference_old_table, action_reference_new_table,
             action_reference_old_row, action_reference_new_row, created)
as
-- missing source code
;

create view information_schema.udt_privileges
            (grantor, grantee, udt_catalog, udt_schema, udt_name, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.usage_privileges
            (grantor, grantee, object_catalog, object_schema, object_name, object_type, privilege_type, is_grantable) as
-- missing source code
;

create view information_schema.user_defined_types
            (user_defined_type_catalog, user_defined_type_schema, user_defined_type_name, user_defined_type_category,
             is_instantiable, is_final, ordering_form, ordering_category, ordering_routine_catalog,
             ordering_routine_schema, ordering_routine_name, reference_type, data_type, character_maximum_length,
             character_octet_length, character_set_catalog, character_set_schema, character_set_name, collation_catalog,
             collation_schema, collation_name, numeric_precision, numeric_precision_radix, numeric_scale,
             datetime_precision, interval_type, interval_precision, source_dtd_identifier, ref_dtd_identifier)
as
-- missing source code
;

create view information_schema.user_mapping_options
            (authorization_identifier, foreign_server_catalog, foreign_server_name, option_name, option_value) as
-- missing source code
;

create view information_schema.user_mappings(authorization_identifier, foreign_server_catalog, foreign_server_name) as
-- missing source code
;

create view information_schema.view_column_usage
            (view_catalog, view_schema, view_name, table_catalog, table_schema, table_name, column_name) as
-- missing source code
;

create view information_schema.view_routine_usage
            (table_catalog, table_schema, table_name, specific_catalog, specific_schema, specific_name) as
-- missing source code
;

create view information_schema.view_table_usage
            (view_catalog, view_schema, view_name, table_catalog, table_schema, table_name) as
-- missing source code
;

create view information_schema.views
            (table_catalog, table_schema, table_name, view_definition, check_option, is_updatable, is_insertable_into,
             is_trigger_updatable, is_trigger_deletable, is_trigger_insertable_into)
as
-- missing source code
;

create function _postgis_deprecate(oldname text, newname text, version text) returns void
    immutable
    strict
    cost 500
    language plpgsql
as
$$
DECLARE
curver_text text;
BEGIN
  --
  -- Raises a NOTICE if it was deprecated in this version,
  -- a WARNING if in a previous version (only up to minor version checked)
  --
    curver_text := '3.2.0';
    IF split_part(curver_text,'.',1)::int > split_part(version,'.',1)::int OR
       ( split_part(curver_text,'.',1) = split_part(version,'.',1) AND
         split_part(curver_text,'.',2) != split_part(version,'.',2) )
    THEN
      RAISE WARNING '% signature was deprecated in %. Please use %', oldname, version, newname;
ELSE
      RAISE DEBUG '% signature was deprecated in %. Please use %', oldname, version, newname;
END IF;
END;
$$;

alter function _postgis_deprecate(text, text, text) owner to postgres;

create function spheroid_in(cstring) returns spheroid
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function spheroid_in(cstring) owner to postgres;

create function spheroid_out(spheroid) returns cstring
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function spheroid_out(spheroid) owner to postgres;

create function geometry_in(cstring) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_in(cstring) owner to postgres;

create function geometry_out(geometry) returns cstring
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_out(geometry) owner to postgres;

create function geometry_typmod_in(cstring[]) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_typmod_in(cstring[]) owner to postgres;

create function geometry_typmod_out(integer) returns cstring
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_typmod_out(integer) owner to postgres;

create function geometry_analyze(internal) returns boolean
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_analyze(internal) owner to postgres;

create function geometry_recv(internal) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_recv(internal) owner to postgres;

create function geometry_send(geometry) returns bytea
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_send(geometry) owner to postgres;

create function geometry(geometry, integer, boolean) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry(geometry, integer, boolean) owner to postgres;

create function geometry(point) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry(point) owner to postgres;

create function point(geometry) returns point
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function point(geometry) owner to postgres;

create function geometry(path) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry(path) owner to postgres;

create function path(geometry) returns path
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function path(geometry) owner to postgres;

create function geometry(polygon) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry(polygon) owner to postgres;

create function polygon(geometry) returns polygon
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function polygon(geometry) owner to postgres;

create function st_x(geometry) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_x(geometry) is 'args: a_point - Returns the X coordinate of a Point.';

alter function st_x(geometry) owner to postgres;

create function st_y(geometry) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_y(geometry) is 'args: a_point - Returns the Y coordinate of a Point.';

alter function st_y(geometry) owner to postgres;

create function st_z(geometry) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_z(geometry) is 'args: a_point - Returns the Z coordinate of a Point.';

alter function st_z(geometry) owner to postgres;

create function st_m(geometry) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_m(geometry) is 'args: a_point - Returns the M coordinate of a Point.';

alter function st_m(geometry) owner to postgres;

create function box3d_in(cstring) returns box3d
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function box3d_in(cstring) owner to postgres;

create function box3d_out(box3d) returns cstring
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function box3d_out(box3d) owner to postgres;

create function box2d_in(cstring) returns box2d
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function box2d_in(cstring) owner to postgres;

create function box2d_out(box2d) returns cstring
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function box2d_out(box2d) owner to postgres;

create function box2df_in(cstring) returns box2df
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function box2df_in(cstring) owner to postgres;

create function box2df_out(box2df) returns cstring
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function box2df_out(box2df) owner to postgres;

create function gidx_in(cstring) returns gidx
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function gidx_in(cstring) owner to postgres;

create function gidx_out(gidx) returns cstring
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function gidx_out(gidx) owner to postgres;

create function geometry_lt(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_lt(geometry, geometry) owner to postgres;

create function geometry_le(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_le(geometry, geometry) owner to postgres;

create function geometry_gt(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gt(geometry, geometry) owner to postgres;

create function geometry_ge(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_ge(geometry, geometry) owner to postgres;

create function geometry_eq(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_eq(geometry, geometry) owner to postgres;

create function geometry_cmp(geom1 geometry, geom2 geometry) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_cmp(geometry, geometry) owner to postgres;

create function geometry_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_sortsupport(internal) owner to postgres;

create function geometry_hash(geometry) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_hash(geometry) owner to postgres;

create function geometry_gist_distance_2d(internal, geometry, integer) returns double precision
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_distance_2d(internal, geometry, integer) owner to postgres;

create function geometry_gist_consistent_2d(internal, geometry, integer) returns boolean
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_consistent_2d(internal, geometry, integer) owner to postgres;

create function geometry_gist_compress_2d(internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_compress_2d(internal) owner to postgres;

create function geometry_gist_penalty_2d(internal, internal, internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_penalty_2d(internal, internal, internal) owner to postgres;

create function geometry_gist_picksplit_2d(internal, internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_picksplit_2d(internal, internal) owner to postgres;

create function geometry_gist_union_2d(bytea, internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_union_2d(bytea, internal) owner to postgres;

create function geometry_gist_same_2d(geom1 geometry, geom2 geometry, internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_same_2d(geometry, geometry, internal) owner to postgres;

create function geometry_gist_decompress_2d(internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_decompress_2d(internal) owner to postgres;

create function geometry_gist_sortsupport_2d(internal) returns void
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_sortsupport_2d(internal) owner to postgres;

create function _postgis_selectivity(tbl regclass, att_name text, geom geometry, mode text default '2'::text) returns double precision
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _postgis_selectivity(regclass, text, geometry, text) owner to postgres;

create function _postgis_join_selectivity(regclass, text, regclass, text, text default '2'::text) returns double precision
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _postgis_join_selectivity(regclass, text, regclass, text, text) owner to postgres;

create function _postgis_stats(tbl regclass, att_name text, text default '2'::text) returns text
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _postgis_stats(regclass, text, text) owner to postgres;

create function _postgis_index_extent(tbl regclass, col text) returns box2d
    stable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _postgis_index_extent(regclass, text) owner to postgres;

create function gserialized_gist_sel_2d(internal, oid, internal, integer) returns double precision
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function gserialized_gist_sel_2d(internal, oid, internal, integer) owner to postgres;

create function gserialized_gist_sel_nd(internal, oid, internal, integer) returns double precision
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function gserialized_gist_sel_nd(internal, oid, internal, integer) owner to postgres;

create function gserialized_gist_joinsel_2d(internal, oid, internal, smallint) returns double precision
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function gserialized_gist_joinsel_2d(internal, oid, internal, smallint) owner to postgres;

create function gserialized_gist_joinsel_nd(internal, oid, internal, smallint) returns double precision
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function gserialized_gist_joinsel_nd(internal, oid, internal, smallint) owner to postgres;

create function geometry_overlaps(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_overlaps(geometry, geometry) owner to postgres;

create function geometry_same(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_same(geometry, geometry) owner to postgres;

create function geometry_distance_centroid(geom1 geometry, geom2 geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_distance_centroid(geometry, geometry) owner to postgres;

create function geometry_distance_box(geom1 geometry, geom2 geometry) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_distance_box(geometry, geometry) owner to postgres;

create function geometry_contains(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_contains(geometry, geometry) owner to postgres;

create function geometry_within(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_within(geometry, geometry) owner to postgres;

create function geometry_left(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_left(geometry, geometry) owner to postgres;

create function geometry_overleft(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_overleft(geometry, geometry) owner to postgres;

create function geometry_below(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_below(geometry, geometry) owner to postgres;

create function geometry_overbelow(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_overbelow(geometry, geometry) owner to postgres;

create function geometry_overright(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_overright(geometry, geometry) owner to postgres;

create function geometry_right(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_right(geometry, geometry) owner to postgres;

create function geometry_overabove(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_overabove(geometry, geometry) owner to postgres;

create function geometry_above(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_above(geometry, geometry) owner to postgres;

create function geometry_gist_consistent_nd(internal, geometry, integer) returns boolean
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_consistent_nd(internal, geometry, integer) owner to postgres;

create function geometry_gist_compress_nd(internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_compress_nd(internal) owner to postgres;

create function geometry_gist_penalty_nd(internal, internal, internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_penalty_nd(internal, internal, internal) owner to postgres;

create function geometry_gist_picksplit_nd(internal, internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_picksplit_nd(internal, internal) owner to postgres;

create function geometry_gist_union_nd(bytea, internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_union_nd(bytea, internal) owner to postgres;

create function geometry_gist_same_nd(geometry, geometry, internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_same_nd(geometry, geometry, internal) owner to postgres;

create function geometry_gist_decompress_nd(internal) returns internal
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_decompress_nd(internal) owner to postgres;

create function geometry_overlaps_nd(geometry, geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_overlaps_nd(geometry, geometry) owner to postgres;

create function geometry_contains_nd(geometry, geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_contains_nd(geometry, geometry) owner to postgres;

create function geometry_within_nd(geometry, geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_within_nd(geometry, geometry) owner to postgres;

create function geometry_same_nd(geometry, geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_same_nd(geometry, geometry) owner to postgres;

create function geometry_distance_centroid_nd(geometry, geometry) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_distance_centroid_nd(geometry, geometry) owner to postgres;

create function geometry_distance_cpa(geometry, geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_distance_cpa(geometry, geometry) owner to postgres;

create function geometry_gist_distance_nd(internal, geometry, integer) returns double precision
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_gist_distance_nd(internal, geometry, integer) owner to postgres;

create function st_shiftlongitude(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_shiftlongitude(geometry) is 'args: geom - Shifts the longitude coordinates of a geometry between -180..180 and 0..360.';

alter function st_shiftlongitude(geometry) owner to postgres;

create function st_wrapx(geom geometry, wrap double precision, move double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_wrapx(geometry, double precision, double precision) is 'args: geom, wrap, move - Wrap a geometry around an X value.';

alter function st_wrapx(geometry, double precision, double precision) owner to postgres;

create function st_xmin(box3d) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_xmin(box3d) is 'args: aGeomorBox2DorBox3D - Returns the X minima of a 2D or 3D bounding box or a geometry.';

alter function st_xmin(box3d) owner to postgres;

create function st_ymin(box3d) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_ymin(box3d) is 'args: aGeomorBox2DorBox3D - Returns the Y minima of a 2D or 3D bounding box or a geometry.';

alter function st_ymin(box3d) owner to postgres;

create function st_zmin(box3d) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_zmin(box3d) is 'args: aGeomorBox2DorBox3D - Returns the Z minima of a 2D or 3D bounding box or a geometry.';

alter function st_zmin(box3d) owner to postgres;

create function st_xmax(box3d) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_xmax(box3d) is 'args: aGeomorBox2DorBox3D - Returns the X maxima of a 2D or 3D bounding box or a geometry.';

alter function st_xmax(box3d) owner to postgres;

create function st_ymax(box3d) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_ymax(box3d) is 'args: aGeomorBox2DorBox3D - Returns the Y maxima of a 2D or 3D bounding box or a geometry.';

alter function st_ymax(box3d) owner to postgres;

create function st_zmax(box3d) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_zmax(box3d) is 'args: aGeomorBox2DorBox3D - Returns the Z maxima of a 2D or 3D bounding box or a geometry.';

alter function st_zmax(box3d) owner to postgres;

create function st_expand(box2d, double precision) returns box2d
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_expand(box2d, double precision) is 'args: box, units_to_expand - Returns a bounding box expanded from another bounding box or a geometry.';

alter function st_expand(box2d, double precision) owner to postgres;

create function st_expand(box box2d, dx double precision, dy double precision) returns box2d
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_expand(box2d, double precision, double precision) is 'args: box, dx, dy - Returns a bounding box expanded from another bounding box or a geometry.';

alter function st_expand(box2d, double precision, double precision) owner to postgres;

create function postgis_getbbox(geometry) returns box2d
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function postgis_getbbox(geometry) owner to postgres;

create function st_makebox2d(geom1 geometry, geom2 geometry) returns box2d
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makebox2d(geometry, geometry) is 'args: pointLowLeft, pointUpRight - Creates a BOX2D defined by two 2D point geometries.';

alter function st_makebox2d(geometry, geometry) owner to postgres;

create function st_estimatedextent(text, text, text, boolean) returns box2d
    stable
    strict
    security definer
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_estimatedextent(text, text, text, boolean) is 'args: schema_name, table_name, geocolumn_name, parent_only - Returns the estimated extent of a spatial table.';

alter function st_estimatedextent(text, text, text, boolean) owner to postgres;

create function st_estimatedextent(text, text, text) returns box2d
    stable
    strict
    security definer
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_estimatedextent(text, text, text) is 'args: schema_name, table_name, geocolumn_name - Returns the estimated extent of a spatial table.';

alter function st_estimatedextent(text, text, text) owner to postgres;

create function st_estimatedextent(text, text) returns box2d
    stable
    strict
    security definer
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_estimatedextent(text, text) is 'args: table_name, geocolumn_name - Returns the estimated extent of a spatial table.';

alter function st_estimatedextent(text, text) owner to postgres;

create function st_findextent(text, text, text) returns box2d
    stable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;
BEGIN
FOR myrec IN EXECUTE 'SELECT public.ST_Extent("' || columnname || '") As extent FROM "' || schemaname || '"."' || tablename || '"' LOOP
		return myrec.extent;
END LOOP;
END;
$$;

alter function st_findextent(text, text, text) owner to postgres;

create function st_findextent(text, text) returns box2d
    stable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
FOR myrec IN EXECUTE 'SELECT public.ST_Extent("' || columnname || '") As extent FROM "' || tablename || '"' LOOP
		return myrec.extent;
END LOOP;
END;
$$;

alter function st_findextent(text, text) owner to postgres;

create function postgis_addbbox(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_addbbox(geometry) is 'args: geomA - Add bounding box to the geometry.';

alter function postgis_addbbox(geometry) owner to postgres;

create function postgis_dropbbox(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_dropbbox(geometry) is 'args: geomA - Drop the bounding box cache from the geometry.';

alter function postgis_dropbbox(geometry) owner to postgres;

create function postgis_hasbbox(geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_hasbbox(geometry) is 'args: geomA - Returns TRUE if the bbox of this geometry is cached, FALSE otherwise.';

alter function postgis_hasbbox(geometry) owner to postgres;

create function st_quantizecoordinates(g geometry, prec_x integer, prec_y integer default NULL::integer, prec_z integer default NULL::integer, prec_m integer default NULL::integer) returns geometry
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_quantizecoordinates(geometry, integer, integer, integer, integer) is 'args: g, prec_x, prec_y, prec_z, prec_m - Sets least significant bits of coordinates to zero';

alter function st_quantizecoordinates(geometry, integer, integer, integer, integer) owner to postgres;

create function st_memsize(geometry) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_memsize(geometry) is 'args: geomA - Returns the amount of memory space a geometry takes.';

alter function st_memsize(geometry) owner to postgres;

create function st_summary(geometry) returns text
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_summary(geometry) is 'args: g - Returns a text summary of the contents of a geometry.';

alter function st_summary(geometry) owner to postgres;

create function st_npoints(geometry) returns integer
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_npoints(geometry) is 'args: g1 - Returns the number of points (vertices) in a geometry.';

alter function st_npoints(geometry) owner to postgres;

create function st_nrings(geometry) returns integer
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_nrings(geometry) is 'args: geomA - Returns the number of rings in a polygonal geometry.';

alter function st_nrings(geometry) owner to postgres;

create function st_3dlength(geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_3dlength(geometry) is 'args: a_3dlinestring - Returns the 3D length of a linear geometry.';

alter function st_3dlength(geometry) owner to postgres;

create function st_length2d(geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_length2d(geometry) is 'args: a_2dlinestring - Returns the 2D length of a linear geometry. Alias for ST_Length';

alter function st_length2d(geometry) owner to postgres;

create function st_length(geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_length(geometry) is 'args: a_2dlinestring - Returns the 2D length of a linear geometry.';

alter function st_length(geometry) owner to postgres;

create function st_lengthspheroid(geometry, spheroid) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_lengthspheroid(geometry, spheroid) is 'args: a_geometry, a_spheroid - Returns the 2D or 3D length/perimeter of a lon/lat geometry on a spheroid.';

alter function st_lengthspheroid(geometry, spheroid) owner to postgres;

create function st_length2dspheroid(geometry, spheroid) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_length2dspheroid(geometry, spheroid) owner to postgres;

create function st_3dperimeter(geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_3dperimeter(geometry) is 'args: geomA - Returns the 3D perimeter of a polygonal geometry.';

alter function st_3dperimeter(geometry) owner to postgres;

create function st_perimeter2d(geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_perimeter2d(geometry) is 'args: geomA - Returns the 2D perimeter of a polygonal geometry. Alias for ST_Perimeter.';

alter function st_perimeter2d(geometry) owner to postgres;

create function st_perimeter(geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_perimeter(geometry) is 'args: g1 - Returns the length of the boundary of a polygonal geometry or geography.';

alter function st_perimeter(geometry) owner to postgres;

create function st_area2d(geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_area2d(geometry) owner to postgres;

create function st_area(geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_area(geometry) is 'args: g1 - Returns the area of a polygonal geometry.';

alter function st_area(geometry) owner to postgres;

create function st_ispolygoncw(geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_ispolygoncw(geometry) is 'args: geom - Tests if Polygons have exterior rings oriented clockwise and interior rings oriented counter-clockwise.';

alter function st_ispolygoncw(geometry) owner to postgres;

create function st_ispolygonccw(geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_ispolygonccw(geometry) is 'args: geom - Tests if Polygons have exterior rings oriented counter-clockwise and interior rings oriented clockwise.';

alter function st_ispolygonccw(geometry) owner to postgres;

create function st_distancespheroid(geom1 geometry, geom2 geometry, spheroid) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_distancespheroid(geometry, geometry, spheroid) is 'args: geomlonlatA, geomlonlatB, measurement_spheroid - Returns the minimum distance between two lon/lat geometries using a spheroidal earth model.';

alter function st_distancespheroid(geometry, geometry, spheroid) owner to postgres;

create function st_distance(geom1 geometry, geom2 geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_distance(geometry, geometry) is 'args: g1, g2 - Returns the distance between two geometry or geography values.';

alter function st_distance(geometry, geometry) owner to postgres;

create function st_pointinsidecircle(geometry, double precision, double precision, double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_pointinsidecircle(geometry, double precision, double precision, double precision) owner to postgres;

create function st_azimuth(geom1 geometry, geom2 geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_azimuth(geometry, geometry) is 'args: pointA, pointB - Returns the north-based azimuth of a line between two points.';

alter function st_azimuth(geometry, geometry) owner to postgres;

create function st_angle(pt1 geometry, pt2 geometry, pt3 geometry, pt4 geometry default '0101000000000000000000F87F000000000000F87F'::geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_angle(geometry, geometry, geometry, geometry) is 'args: point1, point2, point3, point4 - Returns the angle between two vectors defined by 3 or 4 points, or 2 lines.';

alter function st_angle(geometry, geometry, geometry, geometry) owner to postgres;

create function st_force2d(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_force2d(geometry) is 'args: geomA - Force the geometries into a "2-dimensional mode".';

alter function st_force2d(geometry) owner to postgres;

create function st_force3dz(geom geometry, zvalue double precision default 0.0) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_force3dz(geometry, double precision) is 'args: geomA, Zvalue = 0.0 - Force the geometries into XYZ mode.';

alter function st_force3dz(geometry, double precision) owner to postgres;

create function st_force3d(geom geometry, zvalue double precision DEFAULT 0.0) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Force3DZ($1, $2)$$;

comment on function st_force3d(geometry, double precision) is 'args: geomA, Zvalue = 0.0 - Force the geometries into XYZ mode. This is an alias for ST_Force3DZ.';

alter function st_force3d(geometry, double precision) owner to postgres;

create function st_force3dm(geom geometry, mvalue double precision default 0.0) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_force3dm(geometry, double precision) is 'args: geomA, Mvalue = 0.0 - Force the geometries into XYM mode.';

alter function st_force3dm(geometry, double precision) owner to postgres;

create function st_force4d(geom geometry, zvalue double precision default 0.0, mvalue double precision default 0.0) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_force4d(geometry, double precision, double precision) is 'args: geomA, Zvalue = 0.0, Mvalue = 0.0 - Force the geometries into XYZM mode.';

alter function st_force4d(geometry, double precision, double precision) owner to postgres;

create function st_forcecollection(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_forcecollection(geometry) is 'args: geomA - Convert the geometry into a GEOMETRYCOLLECTION.';

alter function st_forcecollection(geometry) owner to postgres;

create function st_collectionextract(geometry, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_collectionextract(geometry, integer) is 'args: collection, type - Given a geometry collection, returns a multi-geometry containing only elements of a specified type.';

alter function st_collectionextract(geometry, integer) owner to postgres;

create function st_collectionextract(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_collectionextract(geometry) is 'args: collection - Given a geometry collection, returns a multi-geometry containing only elements of a specified type.';

alter function st_collectionextract(geometry) owner to postgres;

create function st_collectionhomogenize(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_collectionhomogenize(geometry) is 'args: collection - Returns the simplest representation of a geometry collection.';

alter function st_collectionhomogenize(geometry) owner to postgres;

create function st_multi(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_multi(geometry) is 'args: geom - Return the geometry as a MULTI* geometry.';

alter function st_multi(geometry) owner to postgres;

create function st_forcecurve(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_forcecurve(geometry) is 'args: g - Upcast a geometry into its curved type, if applicable.';

alter function st_forcecurve(geometry) owner to postgres;

create function st_forcesfs(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_forcesfs(geometry) is 'args: geomA - Force the geometries to use SFS 1.1 geometry types only.';

alter function st_forcesfs(geometry) owner to postgres;

create function st_forcesfs(geometry, version text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_forcesfs(geometry, text) is 'args: geomA, version - Force the geometries to use SFS 1.1 geometry types only.';

alter function st_forcesfs(geometry, text) owner to postgres;

create function st_expand(box3d, double precision) returns box3d
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_expand(box3d, double precision) is 'args: box, units_to_expand - Returns a bounding box expanded from another bounding box or a geometry.';

alter function st_expand(box3d, double precision) owner to postgres;

create function st_expand(box box3d, dx double precision, dy double precision, dz double precision default 0) returns box3d
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_expand(box3d, double precision, double precision, double precision) is 'args: box, dx, dy, dz=0 - Returns a bounding box expanded from another bounding box or a geometry.';

alter function st_expand(box3d, double precision, double precision, double precision) owner to postgres;

create function st_expand(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_expand(geometry, double precision) is 'args: geom, units_to_expand - Returns a bounding box expanded from another bounding box or a geometry.';

alter function st_expand(geometry, double precision) owner to postgres;

create function st_expand(geom geometry, dx double precision, dy double precision, dz double precision default 0, dm double precision default 0) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_expand(geometry, double precision, double precision, double precision, double precision) is 'args: geom, dx, dy, dz=0, dm=0 - Returns a bounding box expanded from another bounding box or a geometry.';

alter function st_expand(geometry, double precision, double precision, double precision, double precision) owner to postgres;

create function st_envelope(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_envelope(geometry) is 'args: g1 - Returns a geometry representing the bounding box of a geometry.';

alter function st_envelope(geometry) owner to postgres;

create function st_boundingdiagonal(geom geometry, fits boolean default false) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_boundingdiagonal(geometry, boolean) is 'args: geom, fits=false - Returns the diagonal of a geometrys bounding box.';

alter function st_boundingdiagonal(geometry, boolean) owner to postgres;

create function st_reverse(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_reverse(geometry) is 'args: g1 - Return the geometry with vertex order reversed.';

alter function st_reverse(geometry) owner to postgres;

create function st_scroll(geometry, geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_scroll(geometry, geometry) is 'args: linestring, point - Change start point of a closed LineString.';

alter function st_scroll(geometry, geometry) owner to postgres;

create function st_forcepolygoncw(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_forcepolygoncw(geometry) is 'args: geom - Orients all exterior rings clockwise and all interior rings counter-clockwise.';

alter function st_forcepolygoncw(geometry) owner to postgres;

create function st_forcepolygonccw(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$ SELECT public.ST_Reverse(public.ST_ForcePolygonCW($1)) $$;

comment on function st_forcepolygonccw(geometry) is 'args: geom - Orients all exterior rings counter-clockwise and all interior rings clockwise.';

alter function st_forcepolygonccw(geometry) owner to postgres;

create function st_forcerhr(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_forcerhr(geometry) is 'args: g - Force the orientation of the vertices in a polygon to follow the Right-Hand-Rule.';

alter function st_forcerhr(geometry) owner to postgres;

create function postgis_noop(geometry) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function postgis_noop(geometry) owner to postgres;

create function postgis_geos_noop(geometry) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function postgis_geos_noop(geometry) owner to postgres;

create function st_normalize(geom geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_normalize(geometry) is 'args: geom - Return the geometry in its canonical form.';

alter function st_normalize(geometry) owner to postgres;

create function st_zmflag(geometry) returns smallint
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_zmflag(geometry) is 'args: geomA - Returns a code indicating the ZM coordinate dimension of a geometry.';

alter function st_zmflag(geometry) owner to postgres;

create function st_ndims(geometry) returns smallint
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_ndims(geometry) is 'args: g1 - Returns the coordinate dimension of a geometry.';

alter function st_ndims(geometry) owner to postgres;

create function st_asewkt(geometry) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asewkt(geometry) owner to postgres;

create function st_asewkt(geometry, integer) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asewkt(geometry, integer) owner to postgres;

create function st_astwkb(geom geometry, prec integer default NULL::integer, prec_z integer default NULL::integer, prec_m integer default NULL::integer, with_sizes boolean default NULL::boolean, with_boxes boolean default NULL::boolean) returns bytea
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_astwkb(geometry, integer, integer, integer, boolean, boolean) owner to postgres;

create function st_astwkb(geom geometry[], ids bigint[], prec integer default NULL::integer, prec_z integer default NULL::integer, prec_m integer default NULL::integer, with_sizes boolean default NULL::boolean, with_boxes boolean default NULL::boolean) returns bytea
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_astwkb(geometry[], bigint[], integer, integer, integer, boolean, boolean) owner to postgres;

create function st_asewkb(geometry) returns bytea
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asewkb(geometry) owner to postgres;

create function st_ashexewkb(geometry) returns text
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_ashexewkb(geometry) owner to postgres;

create function st_ashexewkb(geometry, text) returns text
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_ashexewkb(geometry, text) owner to postgres;

create function st_asewkb(geometry, text) returns bytea
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asewkb(geometry, text) owner to postgres;

create function st_aslatlontext(geom geometry, tmpl text default ''::text) returns text
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_aslatlontext(geometry, text) owner to postgres;

create function geomfromewkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geomfromewkb(bytea) owner to postgres;

create function st_geomfromewkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geomfromewkb(bytea) owner to postgres;

create function st_geomfromtwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geomfromtwkb(bytea) owner to postgres;

create function geomfromewkt(text) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geomfromewkt(text) owner to postgres;

create function st_geomfromewkt(text) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geomfromewkt(text) owner to postgres;

create function postgis_cache_bbox() returns trigger
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function postgis_cache_bbox() owner to postgres;

create function st_makepoint(double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makepoint(double precision, double precision) is 'args: x, y - Creates a 2D, 3DZ or 4D Point.';

alter function st_makepoint(double precision, double precision) owner to postgres;

create function st_makepoint(double precision, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makepoint(double precision, double precision, double precision) is 'args: x, y, z - Creates a 2D, 3DZ or 4D Point.';

alter function st_makepoint(double precision, double precision, double precision) owner to postgres;

create function st_makepoint(double precision, double precision, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makepoint(double precision, double precision, double precision, double precision) is 'args: x, y, z, m - Creates a 2D, 3DZ or 4D Point.';

alter function st_makepoint(double precision, double precision, double precision, double precision) owner to postgres;

create function st_makepointm(double precision, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makepointm(double precision, double precision, double precision) is 'args: x, y, m - Creates a Point from X, Y and M values.';

alter function st_makepointm(double precision, double precision, double precision) owner to postgres;

create function st_3dmakebox(geom1 geometry, geom2 geometry) returns box3d
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_3dmakebox(geometry, geometry) is 'args: point3DLowLeftBottom, point3DUpRightTop - Creates a BOX3D defined by two 3D point geometries.';

alter function st_3dmakebox(geometry, geometry) owner to postgres;

create function st_makeline(geometry[]) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makeline(geometry[]) is 'args: geoms_array - Creates a LineString from Point, MultiPoint, or LineString geometries.';

alter function st_makeline(geometry[]) owner to postgres;

create function st_linefrommultipoint(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_linefrommultipoint(geometry) is 'args: aMultiPoint - Creates a LineString from a MultiPoint geometry.';

alter function st_linefrommultipoint(geometry) owner to postgres;

create function st_makeline(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makeline(geometry, geometry) is 'args: geom1, geom2 - Creates a LineString from Point, MultiPoint, or LineString geometries.';

alter function st_makeline(geometry, geometry) owner to postgres;

create function st_addpoint(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_addpoint(geometry, geometry) is 'args: linestring, point - Add a point to a LineString.';

alter function st_addpoint(geometry, geometry) owner to postgres;

create function st_addpoint(geom1 geometry, geom2 geometry, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_addpoint(geometry, geometry, integer) is 'args: linestring, point, position = -1 - Add a point to a LineString.';

alter function st_addpoint(geometry, geometry, integer) owner to postgres;

create function st_removepoint(geometry, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_removepoint(geometry, integer) is 'args: linestring, offset - Remove a point from a linestring.';

alter function st_removepoint(geometry, integer) owner to postgres;

create function st_setpoint(geometry, integer, geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setpoint(geometry, integer, geometry) is 'args: linestring, zerobasedposition, point - Replace point of a linestring with a given point.';

alter function st_setpoint(geometry, integer, geometry) owner to postgres;

create function st_makeenvelope(double precision, double precision, double precision, double precision, integer default 0) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makeenvelope(double precision, double precision, double precision, double precision, integer) is 'args: xmin, ymin, xmax, ymax, srid=unknown - Creates a rectangular Polygon from minimum and maximum coordinates.';

alter function st_makeenvelope(double precision, double precision, double precision, double precision, integer) owner to postgres;

create function st_tileenvelope(zoom integer, x integer, y integer, bounds geometry default '0102000020110F00000200000093107C45F81B73C193107C45F81B73C193107C45F81B734193107C45F81B7341'::geometry, margin double precision default 0.0) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_tileenvelope(integer, integer, integer, geometry, double precision) is 'args: tileZoom, tileX, tileY, bounds=SRID=3857;LINESTRING(-20037508.342789 -20037508.342789,20037508.342789 20037508.342789), margin=0.0 - Creates a rectangular Polygon in Web Mercator (SRID:3857) using the XYZ tile system.';

alter function st_tileenvelope(integer, integer, integer, geometry, double precision) owner to postgres;

create function st_makepolygon(geometry, geometry[]) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makepolygon(geometry, geometry[]) is 'args: outerlinestring, interiorlinestrings - Creates a Polygon from a shell and optional list of holes.';

alter function st_makepolygon(geometry, geometry[]) owner to postgres;

create function st_makepolygon(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makepolygon(geometry) is 'args: linestring - Creates a Polygon from a shell and optional list of holes.';

alter function st_makepolygon(geometry) owner to postgres;

create function st_buildarea(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_buildarea(geometry) is 'args: geom - Creates a polygonal geometry formed by the linework of a geometry.';

alter function st_buildarea(geometry) owner to postgres;

create function st_polygonize(geometry[]) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_polygonize(geometry[]) is 'args: geom_array - Computes a collection of polygons formed from the linework of a set of geometries.';

alter function st_polygonize(geometry[]) owner to postgres;

create function st_clusterintersecting(geometry[]) returns geometry[]
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_clusterintersecting(geometry[]) owner to postgres;

create function st_clusterwithin(geometry[], double precision) returns geometry[]
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_clusterwithin(geometry[], double precision) owner to postgres;

create function st_clusterdbscan(geometry, eps double precision, minpoints integer) returns integer
    immutable
    window
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_clusterdbscan(geometry, double precision, integer) is 'args: geom, eps, minpoints - Window function that returns a cluster id for each input geometry using the DBSCAN algorithm.';

alter function st_clusterdbscan(geometry, double precision, integer) owner to postgres;

create function st_linemerge(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_linemerge(geometry) is 'args: amultilinestring - Return the lines formed by sewing together a MultiLineString.';

alter function st_linemerge(geometry) owner to postgres;

create function st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) is 'args: geomA, a, b, c, d, e, f, g, h, i, xoff, yoff, zoff - Apply a 3D affine transformation to a geometry.';

alter function st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) owner to postgres;

create function st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Affine($1,  $2, $3, 0,  $4, $5, 0,  0, 0, 1,  $6, $7, 0)$$;

comment on function st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) is 'args: geomA, a, b, d, e, xoff, yoff - Apply a 3D affine transformation to a geometry.';

alter function st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision) owner to postgres;

create function st_rotate(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Affine($1,  cos($2), -sin($2), 0,  sin($2), cos($2), 0,  0, 0, 1,  0, 0, 0)$$;

comment on function st_rotate(geometry, double precision) is 'args: geomA, rotRadians - Rotates a geometry about an origin point.';

alter function st_rotate(geometry, double precision) owner to postgres;

create function st_rotate(geometry, double precision, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Affine($1,  cos($2), -sin($2), 0,  sin($2),  cos($2), 0, 0, 0, 1,	$3 - cos($2) * $3 + sin($2) * $4, $4 - sin($2) * $3 - cos($2) * $4, 0)$$;

comment on function st_rotate(geometry, double precision, double precision, double precision) is 'args: geomA, rotRadians, x0, y0 - Rotates a geometry about an origin point.';

alter function st_rotate(geometry, double precision, double precision, double precision) owner to postgres;

create function st_rotate(geometry, double precision, geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Affine($1,  cos($2), -sin($2), 0,  sin($2),  cos($2), 0, 0, 0, 1, public.ST_X($3) - cos($2) * public.ST_X($3) + sin($2) * public.ST_Y($3), public.ST_Y($3) - sin($2) * public.ST_X($3) - cos($2) * public.ST_Y($3), 0)$$;

comment on function st_rotate(geometry, double precision, geometry) is 'args: geomA, rotRadians, pointOrigin - Rotates a geometry about an origin point.';

alter function st_rotate(geometry, double precision, geometry) owner to postgres;

create function st_rotatez(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Rotate($1, $2)$$;

comment on function st_rotatez(geometry, double precision) is 'args: geomA, rotRadians - Rotates a geometry about the Z axis.';

alter function st_rotatez(geometry, double precision) owner to postgres;

create function st_rotatex(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Affine($1, 1, 0, 0, 0, cos($2), -sin($2), 0, sin($2), cos($2), 0, 0, 0)$$;

comment on function st_rotatex(geometry, double precision) is 'args: geomA, rotRadians - Rotates a geometry about the X axis.';

alter function st_rotatex(geometry, double precision) owner to postgres;

create function st_rotatey(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Affine($1,  cos($2), 0, sin($2),  0, 1, 0,  -sin($2), 0, cos($2), 0,  0, 0)$$;

comment on function st_rotatey(geometry, double precision) is 'args: geomA, rotRadians - Rotates a geometry about the Y axis.';

alter function st_rotatey(geometry, double precision) owner to postgres;

create function st_translate(geometry, double precision, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Affine($1, 1, 0, 0, 0, 1, 0, 0, 0, 1, $2, $3, $4)$$;

comment on function st_translate(geometry, double precision, double precision, double precision) is 'args: g1, deltax, deltay, deltaz - Translates a geometry by given offsets.';

alter function st_translate(geometry, double precision, double precision, double precision) owner to postgres;

create function st_translate(geometry, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Translate($1, $2, $3, 0)$$;

comment on function st_translate(geometry, double precision, double precision) is 'args: g1, deltax, deltay - Translates a geometry by given offsets.';

alter function st_translate(geometry, double precision, double precision) owner to postgres;

create function st_scale(geometry, geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_scale(geometry, geometry) is 'args: geom, factor - Scales a geometry by given factors.';

alter function st_scale(geometry, geometry) owner to postgres;

create function st_scale(geometry, geometry, origin geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_scale(geometry, geometry, geometry) is 'args: geom, factor, origin - Scales a geometry by given factors.';

alter function st_scale(geometry, geometry, geometry) owner to postgres;

create function st_scale(geometry, double precision, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Scale($1, public.ST_MakePoint($2, $3, $4))$$;

comment on function st_scale(geometry, double precision, double precision, double precision) is 'args: geomA, XFactor, YFactor, ZFactor - Scales a geometry by given factors.';

alter function st_scale(geometry, double precision, double precision, double precision) owner to postgres;

create function st_scale(geometry, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Scale($1, $2, $3, 1)$$;

comment on function st_scale(geometry, double precision, double precision) is 'args: geomA, XFactor, YFactor - Scales a geometry by given factors.';

alter function st_scale(geometry, double precision, double precision) owner to postgres;

create function st_transscale(geometry, double precision, double precision, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_Affine($1,  $4, 0, 0,  0, $5, 0,
		0, 0, 1,  $2 * $4, $3 * $5, 0)$$;

comment on function st_transscale(geometry, double precision, double precision, double precision, double precision) is 'args: geomA, deltaX, deltaY, XFactor, YFactor - Translates and scales a geometry by given offsets and factors.';

alter function st_transscale(geometry, double precision, double precision, double precision, double precision) owner to postgres;

create function st_dump(geometry) returns setof setof geometry_dump
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_dump(geometry) is 'args: g1 - Returns a set of geometry_dump rows for the components of a geometry.';

alter function st_dump(geometry) owner to postgres;

create function st_dumprings(geometry) returns setof setof geometry_dump
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_dumprings(geometry) is 'args: a_polygon - Returns a set of geometry_dump rows for the exterior and interior rings of a Polygon.';

alter function st_dumprings(geometry) owner to postgres;

create function st_dumppoints(geometry) returns setof setof geometry_dump
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_dumppoints(geometry) is 'args: geom - Returns a set of geometry_dump rows for the coordinates in a geometry.';

alter function st_dumppoints(geometry) owner to postgres;

create function st_dumpsegments(geometry) returns setof setof geometry_dump
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_dumpsegments(geometry) is 'args: geom - Returns a set of geometry_dump rows for the segments in a geometry.';

alter function st_dumpsegments(geometry) owner to postgres;

create function populate_geometry_columns(use_typmod boolean DEFAULT true) returns text
    language plpgsql
as
$$
DECLARE
inserted	integer;
	oldcount	integer;
	probed	  integer;
	stale	   integer;
	gcs		 RECORD;
	gc		  RECORD;
	gsrid	   integer;
	gndims	  integer;
	gtype	   text;
	query	   text;
	gc_is_valid boolean;

BEGIN
SELECT count(*) INTO oldcount FROM public.geometry_columns;
inserted := 0;

	-- Count the number of geometry columns in all tables and views
SELECT count(DISTINCT c.oid) INTO probed
FROM pg_class c,
     pg_attribute a,
     pg_type t,
     pg_namespace n
WHERE c.relkind IN('r','v','f', 'p')
  AND t.typname = 'geometry'
  AND a.attisdropped = false
  AND a.atttypid = t.oid
  AND a.attrelid = c.oid
  AND c.relnamespace = n.oid
  AND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns' ;

-- Iterate through all non-dropped geometry columns
RAISE DEBUG 'Processing Tables.....';

FOR gcs IN
SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
FROM pg_class c,
    pg_attribute a,
    pg_type t,
    pg_namespace n
WHERE c.relkind IN( 'r', 'f', 'p')
  AND t.typname = 'geometry'
  AND a.attisdropped = false
  AND a.atttypid = t.oid
  AND a.attrelid = c.oid
  AND c.relnamespace = n.oid
  AND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns'
    LOOP

    inserted := inserted + public.populate_geometry_columns(gcs.oid, use_typmod);
END LOOP;

	IF oldcount > inserted THEN
		stale = oldcount-inserted;
ELSE
		stale = 0;
END IF;

RETURN 'probed:' ||probed|| ' inserted:'||inserted;
END

$$;

comment on function populate_geometry_columns(boolean) is 'args: use_typmod=true - Ensures geometry columns are defined with type modifiers or have appropriate spatial constraints.';

alter function populate_geometry_columns(boolean) owner to postgres;

create function populate_geometry_columns(tbl_oid oid, use_typmod boolean DEFAULT true) returns integer
    language plpgsql
as
$$
DECLARE
gcs		 RECORD;
	gc		  RECORD;
	gc_old	  RECORD;
	gsrid	   integer;
	gndims	  integer;
	gtype	   text;
	query	   text;
	gc_is_valid boolean;
	inserted	integer;
	constraint_successful boolean := false;

BEGIN
	inserted := 0;

	-- Iterate through all geometry columns in this table
FOR gcs IN
SELECT n.nspname, c.relname, a.attname, c.relkind
FROM pg_class c,
     pg_attribute a,
     pg_type t,
     pg_namespace n
WHERE c.relkind IN('r', 'f', 'p')
  AND t.typname = 'geometry'
  AND a.attisdropped = false
  AND a.atttypid = t.oid
  AND a.attrelid = c.oid
  AND c.relnamespace = n.oid
  AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP

        RAISE DEBUG 'Processing column %.%.%', gcs.nspname, gcs.relname, gcs.attname;

gc_is_valid := true;
        -- Find the srid, coord_dimension, and type of current geometry
        -- in geometry_columns -- which is now a view

SELECT type, srid, coord_dimension, gcs.relkind INTO gc_old
FROM geometry_columns
WHERE f_table_schema = gcs.nspname AND f_table_name = gcs.relname AND f_geometry_column = gcs.attname;

IF upper(gc_old.type) = 'GEOMETRY' THEN
        -- This is an unconstrained geometry we need to do something
        -- We need to figure out what to set the type by inspecting the data
            EXECUTE 'SELECT public.ST_srid(' || quote_ident(gcs.attname) || ') As srid, public.GeometryType(' || quote_ident(gcs.attname) || ') As type, public.ST_NDims(' || quote_ident(gcs.attname) || ') As dims ' ||
                     ' FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) ||
                     ' WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1;'
                INTO gc;
            IF gc IS NULL THEN -- there is no data so we can not determine geometry type
            	RAISE WARNING 'No data in table %.%, so no information to determine geometry type and srid', gcs.nspname, gcs.relname;
RETURN 0;
END IF;
            gsrid := gc.srid; gtype := gc.type; gndims := gc.dims;

            IF use_typmod THEN
BEGIN
EXECUTE 'ALTER TABLE ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || ' ALTER COLUMN ' || quote_ident(gcs.attname) ||
        ' TYPE geometry(' || postgis_type_name(gtype, gndims, true) || ', ' || gsrid::text  || ') ';
inserted := inserted + 1;
EXCEPTION
                        WHEN invalid_parameter_value OR feature_not_supported THEN
                        RAISE WARNING 'Could not convert ''%'' in ''%.%'' to use typmod with srid %, type %: %', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), gsrid, postgis_type_name(gtype, gndims, true), SQLERRM;
                            gc_is_valid := false;
END;

ELSE
                -- Try to apply srid check to column
            	constraint_successful = false;
                IF (gsrid > 0 AND postgis_constraint_srid(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
BEGIN
EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) ||
        ' ADD CONSTRAINT ' || quote_ident('enforce_srid_' || gcs.attname) ||
        ' CHECK (ST_srid(' || quote_ident(gcs.attname) || ') = ' || gsrid || ')';
constraint_successful := true;
EXCEPTION
                        WHEN check_violation THEN
                            RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (st_srid(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gsrid;
                            gc_is_valid := false;
END;
END IF;

                -- Try to apply ndims check to column
                IF (gndims IS NOT NULL AND postgis_constraint_dims(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
BEGIN
EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
                                 ADD CONSTRAINT ' || quote_ident('enforce_dims_' || gcs.attname) || '
                                 CHECK (st_ndims(' || quote_ident(gcs.attname) || ') = '||gndims||')';
constraint_successful := true;
EXCEPTION
                        WHEN check_violation THEN
                            RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (st_ndims(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gndims;
                            gc_is_valid := false;
END;
END IF;

                -- Try to apply geometrytype check to column
                IF (gtype IS NOT NULL AND postgis_constraint_type(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
BEGIN
EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
                        ADD CONSTRAINT ' || quote_ident('enforce_geotype_' || gcs.attname) || '
                        CHECK (geometrytype(' || quote_ident(gcs.attname) || ') = ' || quote_literal(gtype) || ')';
constraint_successful := true;
EXCEPTION
                        WHEN check_violation THEN
                            -- No geometry check can be applied. This column contains a number of geometry types.
                            RAISE WARNING 'Could not add geometry type check (%) to table column: %.%.%', gtype, quote_ident(gcs.nspname),quote_ident(gcs.relname),quote_ident(gcs.attname);
END;
END IF;
                 --only count if we were successful in applying at least one constraint
                IF constraint_successful THEN
                	inserted := inserted + 1;
END IF;
END IF;
END IF;

END LOOP;

RETURN inserted;
END

$$;

comment on function populate_geometry_columns(oid, boolean) is 'args: relation_oid, use_typmod=true - Ensures geometry columns are defined with type modifiers or have appropriate spatial constraints.';

alter function populate_geometry_columns(oid, boolean) owner to postgres;

create function addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) returns text
    strict
    language plpgsql
as
$$
DECLARE
rec RECORD;
	sr varchar;
	real_schema name;
sql text;
	new_srid integer;

BEGIN

	-- Verify geometry type
	IF (postgis_type_name(new_type,new_dim) IS NULL )
	THEN
		RAISE EXCEPTION 'Invalid type name "%(%)" - valid ones are:
	POINT, MULTIPOINT,
	LINESTRING, MULTILINESTRING,
	POLYGON, MULTIPOLYGON,
	CIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,
	CURVEPOLYGON, MULTISURFACE,
	GEOMETRY, GEOMETRYCOLLECTION,
	POINTM, MULTIPOINTM,
	LINESTRINGM, MULTILINESTRINGM,
	POLYGONM, MULTIPOLYGONM,
	CIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM
	CURVEPOLYGONM, MULTISURFACEM, TRIANGLE, TRIANGLEM,
	POLYHEDRALSURFACE, POLYHEDRALSURFACEM, TIN, TINM
	or GEOMETRYCOLLECTIONM', new_type, new_dim;
RETURN 'fail';
END IF;

	-- Verify dimension
	IF ( (new_dim >4) OR (new_dim <2) ) THEN
		RAISE EXCEPTION 'invalid dimension';
RETURN 'fail';
END IF;

	IF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN
		RAISE EXCEPTION 'TypeM needs 3 dimensions';
RETURN 'fail';
END IF;

	-- Verify SRID
	IF ( new_srid_in > 0 ) THEN
		IF new_srid_in > 998999 THEN
			RAISE EXCEPTION 'AddGeometryColumn() - SRID must be <= %', 998999;
END IF;
		new_srid := new_srid_in;
SELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;
IF NOT FOUND THEN
			RAISE EXCEPTION 'AddGeometryColumn() - invalid SRID';
RETURN 'fail';
END IF;
ELSE
		new_srid := public.ST_SRID('POINT EMPTY'::public.geometry);
		IF ( new_srid_in != new_srid ) THEN
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
END IF;
END IF;

	-- Verify schema
	IF ( schema_name IS NOT NULL AND schema_name != '' ) THEN
		sql := 'SELECT nspname FROM pg_namespace ' ||
			'WHERE text(nspname) = ' || quote_literal(schema_name) ||
			'LIMIT 1';
		RAISE DEBUG '%', sql;
EXECUTE sql INTO real_schema;

IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);
RETURN 'fail';
END IF;
END IF;

	IF ( real_schema IS NULL ) THEN
		RAISE DEBUG 'Detecting schema';
sql := 'SELECT n.nspname AS schemaname ' ||
			'FROM pg_catalog.pg_class c ' ||
			  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||
			'WHERE c.relkind = ' || quote_literal('r') ||
			' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||
			' AND pg_catalog.pg_table_is_visible(c.oid)' ||
			' AND c.relname = ' || quote_literal(table_name);
		RAISE DEBUG '%', sql;
EXECUTE sql INTO real_schema;

IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);
RETURN 'fail';
END IF;
END IF;

	-- Add geometry column to table
	IF use_typmod THEN
	     sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry(' || public.postgis_type_name(new_type, new_dim) || ', ' || new_srid::text || ')';
        RAISE DEBUG '%', sql;
ELSE
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry ';
        RAISE DEBUG '%', sql;
END IF;
EXECUTE sql;

IF NOT use_typmod THEN
        -- Add table CHECKs
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_srid_' || column_name)
            || ' CHECK (st_srid(' || quote_ident(column_name) ||
            ') = ' || new_srid::text || ')' ;
        RAISE DEBUG '%', sql;
EXECUTE sql;

sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_dims_' || column_name)
            || ' CHECK (st_ndims(' || quote_ident(column_name) ||
            ') = ' || new_dim::text || ')' ;
        RAISE DEBUG '%', sql;
EXECUTE sql;

IF ( NOT (new_type = 'GEOMETRY')) THEN
            sql := 'ALTER TABLE ' ||
                quote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||
                quote_ident('enforce_geotype_' || column_name) ||
                ' CHECK (GeometryType(' ||
                quote_ident(column_name) || ')=' ||
                quote_literal(new_type) || ' OR (' ||
                quote_ident(column_name) || ') is null)';
            RAISE DEBUG '%', sql;
EXECUTE sql;
END IF;
END IF;

RETURN
        real_schema || '.' ||
        table_name || '.' || column_name ||
        ' SRID:' || new_srid::text ||
		' TYPE:' || new_type ||
		' DIMS:' || new_dim::text || ' ';
END;
$$;

comment on function addgeometrycolumn(varchar, varchar, varchar, varchar, integer, varchar, integer, boolean) is 'args: catalog_name, schema_name, table_name, column_name, srid, type, dimension, use_typmod=true - Adds a geometry column to an existing table.';

alter function addgeometrycolumn(varchar, varchar, varchar, varchar, integer, varchar, integer, boolean) owner to postgres;

create function addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) returns text
    stable
    strict
    language plpgsql
as
$$
DECLARE
ret  text;
BEGIN
SELECT public.AddGeometryColumn('',$1,$2,$3,$4,$5,$6,$7) into ret;
RETURN ret;
END;
$$;

comment on function addgeometrycolumn(varchar, varchar, varchar, integer, varchar, integer, boolean) is 'args: schema_name, table_name, column_name, srid, type, dimension, use_typmod=true - Adds a geometry column to an existing table.';

alter function addgeometrycolumn(varchar, varchar, varchar, integer, varchar, integer, boolean) owner to postgres;

create function addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) returns text
    strict
    language plpgsql
as
$$
DECLARE
ret  text;
BEGIN
SELECT public.AddGeometryColumn('','',$1,$2,$3,$4,$5, $6) into ret;
RETURN ret;
END;
$$;

comment on function addgeometrycolumn(varchar, varchar, integer, varchar, integer, boolean) is 'args: table_name, column_name, srid, type, dimension, use_typmod=true - Adds a geometry column to an existing table.';

alter function addgeometrycolumn(varchar, varchar, integer, varchar, integer, boolean) owner to postgres;

create function dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying) returns text
    strict
    language plpgsql
as
$$
DECLARE
myrec RECORD;
	okay boolean;
	real_schema name;

BEGIN

	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = false;

FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := true;
END LOOP;

		IF ( okay <>  true ) THEN
			RAISE NOTICE 'Invalid schema name - using current_schema()';
SELECT current_schema() into real_schema;
ELSE
			real_schema = schema_name;
END IF;
ELSE
SELECT current_schema() into real_schema;
END IF;

	-- Find out if the column is in the geometry_columns table
	okay = false;
FOR myrec IN SELECT * from public.geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := true;
END LOOP;
	IF (okay <> true) THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
RETURN false;
END IF;

	-- Remove table column
EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' ||
        quote_ident(table_name) || ' DROP COLUMN ' ||
        quote_ident(column_name);

RETURN real_schema || '.' || table_name || '.' || column_name ||' effectively removed.';

END;
$$;

comment on function dropgeometrycolumn(varchar, varchar, varchar, varchar) is 'args: catalog_name, schema_name, table_name, column_name - Removes a geometry column from a spatial table.';

alter function dropgeometrycolumn(varchar, varchar, varchar, varchar) owner to postgres;

create function dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying) returns text
    strict
    language plpgsql
as
$$
DECLARE
ret text;
BEGIN
SELECT public.DropGeometryColumn('',$1,$2,$3) into ret;
RETURN ret;
END;
$$;

comment on function dropgeometrycolumn(varchar, varchar, varchar) is 'args: schema_name, table_name, column_name - Removes a geometry column from a spatial table.';

alter function dropgeometrycolumn(varchar, varchar, varchar) owner to postgres;

create function dropgeometrycolumn(table_name character varying, column_name character varying) returns text
    strict
    language plpgsql
as
$$
DECLARE
ret text;
BEGIN
SELECT public.DropGeometryColumn('','',$1,$2) into ret;
RETURN ret;
END;
$$;

comment on function dropgeometrycolumn(varchar, varchar) is 'args: table_name, column_name - Removes a geometry column from a spatial table.';

alter function dropgeometrycolumn(varchar, varchar) owner to postgres;

create function dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying) returns text
    strict
    language plpgsql
as
$$
DECLARE
real_schema name;

BEGIN

	IF ( schema_name = '' ) THEN
SELECT current_schema() into real_schema;
ELSE
		real_schema = schema_name;
END IF;

	-- TODO: Should we warn if table doesn't exist probably instead just saying dropped
	-- Remove table
EXECUTE 'DROP TABLE IF EXISTS '
    || quote_ident(real_schema) || '.' ||
        quote_ident(table_name) || ' RESTRICT';

RETURN
        real_schema || '.' ||
        table_name ||' dropped.';

END;
$$;

comment on function dropgeometrytable(varchar, varchar, varchar) is 'args: catalog_name, schema_name, table_name - Drops a table and all its references in geometry_columns.';

alter function dropgeometrytable(varchar, varchar, varchar) owner to postgres;

create function dropgeometrytable(schema_name character varying, table_name character varying) returns text
    strict
    language sql
as
$$ SELECT public.DropGeometryTable('',$1,$2) $$;

comment on function dropgeometrytable(varchar, varchar) is 'args: schema_name, table_name - Drops a table and all its references in geometry_columns.';

alter function dropgeometrytable(varchar, varchar) owner to postgres;

create function dropgeometrytable(table_name character varying) returns text
    strict
    language sql
as
$$ SELECT public.DropGeometryTable('','',$1) $$;

comment on function dropgeometrytable(varchar) is 'args: table_name - Drops a table and all its references in geometry_columns.';

alter function dropgeometrytable(varchar) owner to postgres;

create function updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer) returns text
    strict
    language plpgsql
as
$$
DECLARE
myrec RECORD;
	okay boolean;
	cname varchar;
	real_schema name;
	unknown_srid integer;
	new_srid integer := new_srid_in;

BEGIN

	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = false;

FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := true;
END LOOP;

		IF ( okay <> true ) THEN
			RAISE EXCEPTION 'Invalid schema name';
ELSE
			real_schema = schema_name;
END IF;
ELSE
SELECT INTO real_schema current_schema()::text;
END IF;

	-- Ensure that column_name is in geometry_columns
	okay = false;
FOR myrec IN SELECT type, coord_dimension FROM public.geometry_columns WHERE f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := true;
END LOOP;
	IF (NOT okay) THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
RETURN false;
END IF;

	-- Ensure that new_srid is valid
	IF ( new_srid > 0 ) THEN
		IF ( SELECT count(*) = 0 from spatial_ref_sys where srid = new_srid ) THEN
			RAISE EXCEPTION 'invalid SRID: % not found in spatial_ref_sys', new_srid;
RETURN false;
END IF;
ELSE
		unknown_srid := public.ST_SRID('POINT EMPTY'::public.geometry);
		IF ( new_srid != unknown_srid ) THEN
			new_srid := unknown_srid;
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
END IF;
END IF;

	IF postgis_constraint_srid(real_schema, table_name, column_name) IS NOT NULL THEN
	-- srid was enforced with constraints before, keep it that way.
        -- Make up constraint name
        cname = 'enforce_srid_'  || column_name;

        -- Drop enforce_srid constraint
EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
        '.' || quote_ident(table_name) ||
        ' DROP constraint ' || quote_ident(cname);

-- Update geometries SRID
EXECUTE 'UPDATE ' || quote_ident(real_schema) ||
        '.' || quote_ident(table_name) ||
        ' SET ' || quote_ident(column_name) ||
        ' = public.ST_SetSRID(' || quote_ident(column_name) ||
        ', ' || new_srid::text || ')';

-- Reset enforce_srid constraint
EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
        '.' || quote_ident(table_name) ||
        ' ADD constraint ' || quote_ident(cname) ||
        ' CHECK (st_srid(' || quote_ident(column_name) ||
        ') = ' || new_srid::text || ')';
ELSE
        -- We will use typmod to enforce if no srid constraints
        -- We are using postgis_type_name to lookup the new name
        -- (in case Paul changes his mind and flips geometry_columns to return old upper case name)
        EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' || quote_ident(table_name) ||
        ' ALTER COLUMN ' || quote_ident(column_name) || ' TYPE  geometry(' || public.postgis_type_name(myrec.type, myrec.coord_dimension, true) || ', ' || new_srid::text || ') USING public.ST_SetSRID(' || quote_ident(column_name) || ',' || new_srid::text || ');' ;
END IF;

RETURN real_schema || '.' || table_name || '.' || column_name ||' SRID changed to ' || new_srid::text;

END;
$$;

comment on function updategeometrysrid(varchar, varchar, varchar, varchar, integer) is 'args: catalog_name, schema_name, table_name, column_name, srid - Updates the SRID of all features in a geometry column, and the table metadata.';

alter function updategeometrysrid(varchar, varchar, varchar, varchar, integer) owner to postgres;

create function updategeometrysrid(character varying, character varying, character varying, integer) returns text
    strict
    language plpgsql
as
$$
DECLARE
ret  text;
BEGIN
SELECT public.UpdateGeometrySRID('',$1,$2,$3,$4) into ret;
RETURN ret;
END;
$$;

comment on function updategeometrysrid(varchar, varchar, varchar, integer) is 'args: schema_name, table_name, column_name, srid - Updates the SRID of all features in a geometry column, and the table metadata.';

alter function updategeometrysrid(varchar, varchar, varchar, integer) owner to postgres;

create function updategeometrysrid(character varying, character varying, integer) returns text
    strict
    language plpgsql
as
$$
DECLARE
ret  text;
BEGIN
SELECT public.UpdateGeometrySRID('','',$1,$2,$3) into ret;
RETURN ret;
END;
$$;

comment on function updategeometrysrid(varchar, varchar, integer) is 'args: table_name, column_name, srid - Updates the SRID of all features in a geometry column, and the table metadata.';

alter function updategeometrysrid(varchar, varchar, integer) owner to postgres;

create function find_srid(character varying, character varying, character varying) returns integer
    stable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
schem varchar =  $1;
	tabl varchar = $2;
	sr int4;
BEGIN
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and strpos(tabl,'.') > 0 ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
END IF;

select SRID into sr from public.geometry_columns where (f_table_schema = schem or schem = '') and f_table_name = tabl and f_geometry_column = $3;
IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - could not find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase mismatch?';
END IF;
return sr;
END;
$$;

comment on function find_srid(varchar, varchar, varchar) is 'args: a_schema_name, a_table_name, a_geomfield_name - Returns the SRID defined for a geometry column.';

alter function find_srid(varchar, varchar, varchar) owner to postgres;

create function get_proj4_from_srid(integer) returns text
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
BEGIN
RETURN proj4text::text FROM public.spatial_ref_sys WHERE srid= $1;
END;
	$$;

alter function get_proj4_from_srid(integer) owner to postgres;

create function st_setsrid(geom geometry, srid integer) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setsrid(geometry, integer) is 'args: geom, srid - Set the SRID on a geometry.';

alter function st_setsrid(geometry, integer) owner to postgres;

create function st_srid(geom geometry) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_srid(geometry) is 'args: g1 - Returns the spatial reference identifier for a geometry.';

alter function st_srid(geometry) owner to postgres;

create function postgis_transform_geometry(geom geometry, text, text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function postgis_transform_geometry(geometry, text, text, integer) owner to postgres;

create function st_transform(geometry, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_transform(geometry, integer) is 'args: g1, srid - Return a new geometry with coordinates transformed to a different spatial reference system.';

alter function st_transform(geometry, integer) owner to postgres;

create function st_transform(geom geometry, to_proj text) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language sql
as
$$SELECT public.postgis_transform_geometry($1, proj4text, $2, 0)
	FROM spatial_ref_sys WHERE srid=public.ST_SRID($1);$$;

comment on function st_transform(geometry, text) is 'args: geom, to_proj - Return a new geometry with coordinates transformed to a different spatial reference system.';

alter function st_transform(geometry, text) owner to postgres;

create function st_transform(geom geometry, from_proj text, to_proj text) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language sql
as
$$SELECT public.postgis_transform_geometry($1, $2, $3, 0)$$;

comment on function st_transform(geometry, text, text) is 'args: geom, from_proj, to_proj - Return a new geometry with coordinates transformed to a different spatial reference system.';

alter function st_transform(geometry, text, text) owner to postgres;

create function st_transform(geom geometry, from_proj text, to_srid integer) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language sql
as
$$SELECT public.postgis_transform_geometry($1, $2, proj4text, $3)
	FROM spatial_ref_sys WHERE srid=$3;$$;

comment on function st_transform(geometry, text, integer) is 'args: geom, from_proj, to_srid - Return a new geometry with coordinates transformed to a different spatial reference system.';

alter function st_transform(geometry, text, integer) owner to postgres;

create function postgis_version() returns text
    immutable
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_version() is 'Returns PostGIS version number and compile-time options.';

alter function postgis_version() owner to postgres;

create function postgis_liblwgeom_version() returns text
    immutable
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_liblwgeom_version() is 'Returns the version number of the liblwgeom library. This should match the version of PostGIS.';

alter function postgis_liblwgeom_version() owner to postgres;

create function postgis_proj_version() returns text
    immutable
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_proj_version() is 'Returns the version number of the PROJ4 library.';

alter function postgis_proj_version() owner to postgres;

create function postgis_wagyu_version() returns text
    immutable
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_wagyu_version() is 'Returns the version number of the internal Wagyu library.';

alter function postgis_wagyu_version() owner to postgres;

create function postgis_scripts_installed() returns text
    immutable
    language sql
as
$$ SELECT trim('3.2.0'::text || $rev$ c3e3cc0 $rev$) AS version $$;

comment on function postgis_scripts_installed() is 'Returns version of the PostGIS scripts installed in this database.';

alter function postgis_scripts_installed() owner to postgres;

create function postgis_lib_version() returns text
    immutable
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_lib_version() is 'Returns the version number of the PostGIS library.';

alter function postgis_lib_version() owner to postgres;

create function postgis_scripts_released() returns text
    immutable
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_scripts_released() is 'Returns the version number of the postgis.sql script released with the installed PostGIS lib.';

alter function postgis_scripts_released() owner to postgres;

create function postgis_geos_version() returns text
    immutable
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_geos_version() is 'Returns the version number of the GEOS library.';

alter function postgis_geos_version() owner to postgres;

create function postgis_lib_revision() returns text
    immutable
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function postgis_lib_revision() owner to postgres;

create function postgis_svn_version() returns text
    immutable
    language sql
as
$$
SELECT public._postgis_deprecate(
        'postgis_svn_version', 'postgis_lib_revision', '3.1.0');
SELECT public.postgis_lib_revision();
$$;

alter function postgis_svn_version() owner to postgres;

create function postgis_libxml_version() returns text
    immutable
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_libxml_version() is 'Returns the version number of the libxml2 library.';

alter function postgis_libxml_version() owner to postgres;

create function postgis_scripts_build_date() returns text
    immutable
    language sql
as
$$SELECT '2021-12-18 06:27:50'::text AS version$$;

comment on function postgis_scripts_build_date() is 'Returns build date of the PostGIS scripts.';

alter function postgis_scripts_build_date() owner to postgres;

create function postgis_lib_build_date() returns text
    immutable
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_lib_build_date() is 'Returns build date of the PostGIS library.';

alter function postgis_lib_build_date() owner to postgres;

create function _postgis_scripts_pgsql_version() returns text
    immutable
    language sql
as
$$SELECT '130'::text AS version$$;

alter function _postgis_scripts_pgsql_version() owner to postgres;

create function _postgis_pgsql_version() returns text
    stable
    language sql
as
$$
SELECT CASE WHEN split_part(s,'.',1)::integer > 9 THEN split_part(s,'.',1) || '0' ELSE split_part(s,'.', 1) || split_part(s,'.', 2) END AS v
FROM substring(version(), 'PostgreSQL ([0-9\.]+)') AS s;
$$;

alter function _postgis_pgsql_version() owner to postgres;

create function postgis_extensions_upgrade() returns text
    language plpgsql
as
$$
DECLARE rec record; sql text; var_schema text;
BEGIN

FOR rec IN
SELECT name, default_version, installed_version
FROM pg_catalog.pg_available_extensions
WHERE name IN (
               'postgis',
               'postgis_raster',
               'postgis_sfcgal',
               'postgis_topology',
               'postgis_tiger_geocoder'
    )
ORDER BY length(name) -- this is to make sure 'postgis' is first !
    LOOP
		IF rec.installed_version IS NULL THEN
			-- If the support installed by available extension
			-- is found unpackaged, we package it
			IF
				 -- PostGIS is always available (this function is part of it)
				 rec.name = 'postgis'

				 -- PostGIS raster is available if type 'raster' exists
				 OR ( rec.name = 'postgis_raster' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_type
							WHERE typname = 'raster' ) )

				 -- PostGIS SFCGAL is availble if
				 -- 'postgis_sfcgal_version' function exists
				 OR ( rec.name = 'postgis_sfcgal' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_proc
							WHERE proname = 'postgis_sfcgal_version' ) )

				 -- PostGIS Topology is available if
				 -- 'topology.topology' table exists
				 -- NOTE: watch out for https://trac.osgeo.org/postgis/ticket/2503
				 OR ( rec.name = 'postgis_topology' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_class c
							JOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid )
							WHERE n.nspname = 'topology' AND c.relname = 'topology') )

				 OR ( rec.name = 'postgis_tiger_geocoder' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_class c
							JOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid )
							WHERE n.nspname = 'tiger' AND c.relname = 'geocode_settings') )
			THEN
-- Force install in same schema as postgis
SELECT INTO var_schema n.nspname
FROM pg_namespace n, pg_proc p
WHERE p.proname = 'postgis_full_version'
  AND n.oid = p.pronamespace
    LIMIT 1;
IF rec.name NOT IN('postgis_topology', 'postgis_tiger_geocoder')
				THEN
					sql := format(
					          'CREATE EXTENSION %1$I SCHEMA %2$I VERSION unpackaged;'
					          'ALTER EXTENSION %1$I UPDATE TO %3$I',
					          rec.name, var_schema, rec.default_version);
ELSE
					sql := format(
					         'CREATE EXTENSION %1$I VERSION unpackaged;'
					         'ALTER EXTENSION %1$I UPDATE TO %2$I',
					         rec.name, rec.default_version);
END IF;
				RAISE NOTICE 'Packaging extension %', rec.name;
				RAISE DEBUG '%', sql;
EXECUTE sql;
ELSE
				RAISE NOTICE 'Extension % is not available or not packagable for some reason', rec.name;
END IF;
		ELSIF rec.default_version != rec.installed_version
		THEN
			sql = 'ALTER EXTENSION ' || rec.name || ' UPDATE TO ' ||
						quote_ident(rec.default_version)   || ';';
			RAISE NOTICE 'Updating extension % from % to %',
				rec.name, rec.installed_version, rec.default_version;
			RAISE DEBUG '%', sql;
EXECUTE sql;
ELSIF (rec.default_version = rec.installed_version AND rec.installed_version ILIKE '%dev') OR
			(public._postgis_pgsql_version() != public._postgis_scripts_pgsql_version())
		THEN
			-- we need to upgrade to next and back
			RAISE NOTICE 'Updating extension % %',
				rec.name, rec.installed_version;
sql = 'ALTER EXTENSION ' || rec.name || ' UPDATE TO ' ||
						quote_ident(rec.default_version || 'next')   || ';';
			RAISE DEBUG '%', sql;
EXECUTE sql;
sql = 'ALTER EXTENSION ' || rec.name || ' UPDATE TO ' ||
						quote_ident(rec.default_version)   || ';';
			RAISE DEBUG '%', sql;
EXECUTE sql;
END IF;

END LOOP;

RETURN 'Upgrade completed, run SELECT postgis_full_version(); for details';

END
$$;

comment on function postgis_extensions_upgrade() is 'Packages and upgrades PostGIS extensions (e.g. postgis_raster,postgis_topology, postgis_sfcgal) to latest available version.';

alter function postgis_extensions_upgrade() owner to postgres;

create function postgis_full_version() returns text
    immutable
    language plpgsql
as
$$
DECLARE
libver text;
	librev text;
	projver text;
	geosver text;
	sfcgalver text;
	gdalver text := NULL;
	libxmlver text;
	liblwgeomver text;
	dbproc text;
	relproc text;
	fullver text;
	rast_lib_ver text := NULL;
	rast_scr_ver text := NULL;
	topo_scr_ver text := NULL;
	json_lib_ver text;
	protobuf_lib_ver text;
	wagyu_lib_ver text;
	sfcgal_lib_ver text;
	sfcgal_scr_ver text;
	pgsql_scr_ver text;
	pgsql_ver text;
	core_is_extension bool;
BEGIN
SELECT public.postgis_lib_version() INTO libver;
SELECT public.postgis_proj_version() INTO projver;
SELECT public.postgis_geos_version() INTO geosver;
SELECT public.postgis_libjson_version() INTO json_lib_ver;
SELECT public.postgis_libprotobuf_version() INTO protobuf_lib_ver;
SELECT public.postgis_wagyu_version() INTO wagyu_lib_ver;
SELECT public._postgis_scripts_pgsql_version() INTO pgsql_scr_ver;
SELECT public._postgis_pgsql_version() INTO pgsql_ver;
BEGIN
SELECT public.postgis_gdal_version() INTO gdalver;
EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_gdal_version() not found.  Is raster support enabled and rtpostgis.sql installed?';
END;
BEGIN
SELECT public.postgis_sfcgal_version() INTO sfcgalver;
BEGIN
SELECT public.postgis_sfcgal_scripts_installed() INTO sfcgal_scr_ver;
EXCEPTION
			WHEN undefined_function THEN
				sfcgal_scr_ver := 'missing';
END;
EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_sfcgal_scripts_installed() not found. Is sfcgal support enabled and sfcgal.sql installed?';
END;
SELECT public.postgis_liblwgeom_version() INTO liblwgeomver;
SELECT public.postgis_libxml_version() INTO libxmlver;
SELECT public.postgis_scripts_installed() INTO dbproc;
SELECT public.postgis_scripts_released() INTO relproc;
SELECT public.postgis_lib_revision() INTO librev;
BEGIN
SELECT topology.postgis_topology_scripts_installed() INTO topo_scr_ver;
EXCEPTION
		WHEN undefined_function OR invalid_schema_name THEN
			RAISE DEBUG 'Function postgis_topology_scripts_installed() not found. Is topology support enabled and topology.sql installed?';
WHEN insufficient_privilege THEN
			RAISE NOTICE 'Topology support cannot be inspected. Is current user granted USAGE on schema "topology" ?';
WHEN OTHERS THEN
			RAISE NOTICE 'Function postgis_topology_scripts_installed() could not be called: % (%)', SQLERRM, SQLSTATE;
END;

BEGIN
SELECT postgis_raster_scripts_installed() INTO rast_scr_ver;
EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_raster_scripts_installed() not found. Is raster support enabled and rtpostgis.sql installed?';
WHEN OTHERS THEN
			RAISE NOTICE 'Function postgis_raster_scripts_installed() could not be called: % (%)', SQLERRM, SQLSTATE;
END;

BEGIN
SELECT public.postgis_raster_lib_version() INTO rast_lib_ver;
EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_raster_lib_version() not found. Is raster support enabled and rtpostgis.sql installed?';
WHEN OTHERS THEN
			RAISE NOTICE 'Function postgis_raster_lib_version() could not be called: % (%)', SQLERRM, SQLSTATE;
END;

	fullver = 'POSTGIS="' || libver;

	IF  librev IS NOT NULL THEN
		fullver = fullver || ' ' || librev;
END IF;

	fullver = fullver || '"';

	IF EXISTS (
		SELECT * FROM pg_catalog.pg_extension
		WHERE extname = 'postgis')
	THEN
			fullver = fullver || ' [EXTENSION]';
			core_is_extension := true;
ELSE
			core_is_extension := false;
END IF;

	IF liblwgeomver != relproc THEN
		fullver = fullver || ' (liblwgeom version mismatch: "' || liblwgeomver || '")';
END IF;

	fullver = fullver || ' PGSQL="' || pgsql_scr_ver || '"';
	IF pgsql_scr_ver != pgsql_ver THEN
		fullver = fullver || ' (procs need upgrade for use with PostgreSQL "' || pgsql_ver || '")';
END IF;

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS="' || geosver || '"';
END IF;

	IF  sfcgalver IS NOT NULL THEN
		fullver = fullver || ' SFCGAL="' || sfcgalver || '"';
END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ="' || projver || '"';
END IF;

	IF  gdalver IS NOT NULL THEN
		fullver = fullver || ' GDAL="' || gdalver || '"';
END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML="' || libxmlver || '"';
END IF;

	IF json_lib_ver IS NOT NULL THEN
		fullver = fullver || ' LIBJSON="' || json_lib_ver || '"';
END IF;

	IF protobuf_lib_ver IS NOT NULL THEN
		fullver = fullver || ' LIBPROTOBUF="' || protobuf_lib_ver || '"';
END IF;

	IF wagyu_lib_ver IS NOT NULL THEN
		fullver = fullver || ' WAGYU="' || wagyu_lib_ver || '"';
END IF;

	IF dbproc != relproc THEN
		fullver = fullver || ' (core procs from "' || dbproc || '" need upgrade)';
END IF;

	IF topo_scr_ver IS NOT NULL THEN
		fullver = fullver || ' TOPOLOGY';
		IF topo_scr_ver != relproc THEN
			fullver = fullver || ' (topology procs from "' || topo_scr_ver || '" need upgrade)';
END IF;
		IF core_is_extension AND NOT EXISTS (
			SELECT * FROM pg_catalog.pg_extension
			WHERE extname = 'postgis_topology')
		THEN
				fullver = fullver || ' [UNPACKAGED!]';
END IF;
END IF;

	IF rast_lib_ver IS NOT NULL THEN
		fullver = fullver || ' RASTER';
		IF rast_lib_ver != relproc THEN
			fullver = fullver || ' (raster lib from "' || rast_lib_ver || '" need upgrade)';
END IF;
		IF core_is_extension AND NOT EXISTS (
			SELECT * FROM pg_catalog.pg_extension
			WHERE extname = 'postgis_raster')
		THEN
				fullver = fullver || ' [UNPACKAGED!]';
END IF;
END IF;

	IF rast_scr_ver IS NOT NULL AND rast_scr_ver != relproc THEN
		fullver = fullver || ' (raster procs from "' || rast_scr_ver || '" need upgrade)';
END IF;

	IF sfcgal_scr_ver IS NOT NULL AND sfcgal_scr_ver != relproc THEN
		fullver = fullver || ' (sfcgal procs from "' || sfcgal_scr_ver || '" need upgrade)';
END IF;

RETURN fullver;
END
$$;

comment on function postgis_full_version() is 'Reports full PostGIS version and build configuration infos.';

alter function postgis_full_version() owner to postgres;

create function box2d(geometry) returns box2d
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function box2d(geometry) is 'args: geom - Returns a BOX2D representing the 2D extent of a geometry.';

alter function box2d(geometry) owner to postgres;

create function box3d(geometry) returns box3d
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function box3d(geometry) is 'args: geom - Returns a BOX3D representing the 3D extent of a geometry.';

alter function box3d(geometry) owner to postgres;

create function box(geometry) returns box
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function box(geometry) owner to postgres;

create function box2d(box3d) returns box2d
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function box2d(box3d) owner to postgres;

create function box3d(box2d) returns box3d
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function box3d(box2d) owner to postgres;

create function box(box3d) returns box
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function box(box3d) owner to postgres;

create function text(geometry) returns text
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function text(geometry) owner to postgres;

create function box3dtobox(box3d) returns box
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function box3dtobox(box3d) owner to postgres;

create function geometry(box2d) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry(box2d) owner to postgres;

create function geometry(box3d) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry(box3d) owner to postgres;

create function geometry(text) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry(text) owner to postgres;

create function geometry(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry(bytea) owner to postgres;

create function bytea(geometry) returns bytea
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function bytea(geometry) owner to postgres;

create function st_simplify(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_simplify(geometry, double precision) owner to postgres;

create function st_simplify(geometry, double precision, boolean) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_simplify(geometry, double precision, boolean) is 'args: geomA, tolerance, preserveCollapsed - Returns a simplified version of a geometry, using the Douglas-Peucker algorithm.';

alter function st_simplify(geometry, double precision, boolean) owner to postgres;

create function st_simplifyvw(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_simplifyvw(geometry, double precision) is 'args: geomA, tolerance - Returns a simplified version of a geometry, using the Visvalingam-Whyatt algorithm';

alter function st_simplifyvw(geometry, double precision) owner to postgres;

create function st_seteffectivearea(geometry, double precision default '-1'::integer, integer default 1) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_seteffectivearea(geometry, double precision, integer) is 'args: geomA, threshold = 0, set_area = 1 - Sets the effective area for each vertex, using the Visvalingam-Whyatt algorithm.';

alter function st_seteffectivearea(geometry, double precision, integer) owner to postgres;

create function st_filterbym(geometry, double precision, double precision default NULL::double precision, boolean default false) returns geometry
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_filterbym(geometry, double precision, double precision, boolean) is 'args: geom, min, max = null, returnM = false - Removes vertices based on their M value';

alter function st_filterbym(geometry, double precision, double precision, boolean) owner to postgres;

create function st_chaikinsmoothing(geometry, integer default 1, boolean default false) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_chaikinsmoothing(geometry, integer, boolean) is 'args: geom, nIterations = 1, preserveEndPoints = false - Returns a smoothed version of a geometry, using the Chaikin algorithm';

alter function st_chaikinsmoothing(geometry, integer, boolean) owner to postgres;

create function st_snaptogrid(geometry, double precision, double precision, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_snaptogrid(geometry, double precision, double precision, double precision, double precision) is 'args: geomA, originX, originY, sizeX, sizeY - Snap all points of the input geometry to a regular grid.';

alter function st_snaptogrid(geometry, double precision, double precision, double precision, double precision) owner to postgres;

create function st_snaptogrid(geometry, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_SnapToGrid($1, 0, 0, $2, $3)$$;

comment on function st_snaptogrid(geometry, double precision, double precision) is 'args: geomA, sizeX, sizeY - Snap all points of the input geometry to a regular grid.';

alter function st_snaptogrid(geometry, double precision, double precision) owner to postgres;

create function st_snaptogrid(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_SnapToGrid($1, 0, 0, $2, $2)$$;

comment on function st_snaptogrid(geometry, double precision) is 'args: geomA, size - Snap all points of the input geometry to a regular grid.';

alter function st_snaptogrid(geometry, double precision) owner to postgres;

create function st_snaptogrid(geom1 geometry, geom2 geometry, double precision, double precision, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision) is 'args: geomA, pointOrigin, sizeX, sizeY, sizeZ, sizeM - Snap all points of the input geometry to a regular grid.';

alter function st_snaptogrid(geometry, geometry, double precision, double precision, double precision, double precision) owner to postgres;

create function st_segmentize(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_segmentize(geometry, double precision) is 'args: geom, max_segment_length - Return a modified geometry/geography having no segment longer than the given distance.';

alter function st_segmentize(geometry, double precision) owner to postgres;

create function st_lineinterpolatepoint(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_lineinterpolatepoint(geometry, double precision) is 'args: a_linestring, a_fraction - Returns a point interpolated along a line at a fractional location.';

alter function st_lineinterpolatepoint(geometry, double precision) owner to postgres;

create function st_lineinterpolatepoints(geometry, double precision, repeat boolean default true) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_lineinterpolatepoints(geometry, double precision, boolean) is 'args: a_linestring, a_fraction, repeat - Returns points interpolated along a line at a fractional interval.';

alter function st_lineinterpolatepoints(geometry, double precision, boolean) owner to postgres;

create function st_linesubstring(geometry, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_linesubstring(geometry, double precision, double precision) is 'args: a_linestring, startfraction, endfraction - Returns the part of a line between two fractional locations.';

alter function st_linesubstring(geometry, double precision, double precision) owner to postgres;

create function st_linelocatepoint(geom1 geometry, geom2 geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_linelocatepoint(geometry, geometry) is 'args: a_linestring, a_point - Returns the fractional location of the closest point on a line to a point.';

alter function st_linelocatepoint(geometry, geometry) owner to postgres;

create function st_addmeasure(geometry, double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_addmeasure(geometry, double precision, double precision) is 'args: geom_mline, measure_start, measure_end - Interpolates measures along a linear geometry.';

alter function st_addmeasure(geometry, double precision, double precision) owner to postgres;

create function st_closestpointofapproach(geometry, geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_closestpointofapproach(geometry, geometry) is 'args: track1, track2 - Returns a measure at the closest point of approach of two trajectories.';

alter function st_closestpointofapproach(geometry, geometry) owner to postgres;

create function st_distancecpa(geometry, geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_distancecpa(geometry, geometry) is 'args: track1, track2 - Returns the distance between the closest point of approach of two trajectories.';

alter function st_distancecpa(geometry, geometry) owner to postgres;

create function st_cpawithin(geometry, geometry, double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_cpawithin(geometry, geometry, double precision) is 'args: track1, track2, dist - Tests if the closest point of approach of two trajectoriesis within the specified distance.';

alter function st_cpawithin(geometry, geometry, double precision) owner to postgres;

create function st_isvalidtrajectory(geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_isvalidtrajectory(geometry) is 'args: line - Tests if the geometry is a valid trajectory.';

alter function st_isvalidtrajectory(geometry) owner to postgres;

create function st_intersection(geom1 geometry, geom2 geometry, gridsize double precision default '-1'::integer) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_intersection(geometry, geometry, double precision) is 'args: geomA, geomB, gridSize = -1 - Computes a geometry representing the shared portion of geometries A and B.';

alter function st_intersection(geometry, geometry, double precision) owner to postgres;

create function st_buffer(geom geometry, radius double precision, options text default ''::text) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_buffer(geometry, double precision, text) is 'args: g1, radius_of_buffer, buffer_style_parameters = '' - Computes a geometry covering all points within a given distance from a geometry.';

alter function st_buffer(geometry, double precision, text) owner to postgres;

create function st_buffer(geom geometry, radius double precision, quadsegs integer) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language sql
as
$$ SELECT public.ST_Buffer($1, $2, CAST('quad_segs='||CAST($3 AS text) as text)) $$;

comment on function st_buffer(geometry, double precision, integer) is 'args: g1, radius_of_buffer, num_seg_quarter_circle - Computes a geometry covering all points within a given distance from a geometry.';

alter function st_buffer(geometry, double precision, integer) owner to postgres;

create function st_minimumboundingradius(geometry, out center geometry, out radius double precision) returns record
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_minimumboundingradius(geometry, out geometry, out double precision) is 'args: geom - Returns the center point and radius of the smallest circle that contains a geometry.';

alter function st_minimumboundingradius(geometry, out geometry, out double precision) owner to postgres;

create function st_minimumboundingcircle(inputgeom geometry, segs_per_quarter integer default 48) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_minimumboundingcircle(geometry, integer) is 'args: geomA, num_segs_per_qt_circ=48 - Returns the smallest circle polygon that contains a geometry.';

alter function st_minimumboundingcircle(geometry, integer) owner to postgres;

create function st_orientedenvelope(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_orientedenvelope(geometry) is 'args: geom - Returns a minimum-area rectangle containing a geometry.';

alter function st_orientedenvelope(geometry) owner to postgres;

create function st_offsetcurve(line geometry, distance double precision, params text default ''::text) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_offsetcurve(geometry, double precision, text) is 'args: line, signed_distance, style_parameters='' - Returns an offset line at a given distance and side from an input line.';

alter function st_offsetcurve(geometry, double precision, text) owner to postgres;

create function st_generatepoints(area geometry, npoints integer) returns geometry
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_generatepoints(geometry, integer) is 'args: g, npoints - Generates random points contained in a Polygon or MultiPolygon.';

alter function st_generatepoints(geometry, integer) owner to postgres;

create function st_generatepoints(area geometry, npoints integer, seed integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_generatepoints(geometry, integer, integer) is 'args: g, npoints, seed - Generates random points contained in a Polygon or MultiPolygon.';

alter function st_generatepoints(geometry, integer, integer) owner to postgres;

create function st_convexhull(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_convexhull(geometry) is 'args: geomA - Computes the convex hull of a geometry.';

alter function st_convexhull(geometry) owner to postgres;

create function st_simplifypreservetopology(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_simplifypreservetopology(geometry, double precision) is 'args: geomA, tolerance - Returns a simplified and valid version of a geometry, using the Douglas-Peucker algorithm.';

alter function st_simplifypreservetopology(geometry, double precision) owner to postgres;

create function st_isvalidreason(geometry) returns text
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_isvalidreason(geometry) is 'args: geomA - Returns text stating if a geometry is valid, or a reason for invalidity.';

alter function st_isvalidreason(geometry) owner to postgres;

create function st_isvaliddetail(geom geometry, flags integer default 0) returns valid_detail
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_isvaliddetail(geometry, integer) is 'args: geom, flags - Returns a valid_detail row stating if a geometry is valid or if not a reason and a location.';

alter function st_isvaliddetail(geometry, integer) owner to postgres;

create function st_isvalidreason(geometry, integer) returns text
    immutable
    strict
    parallel safe
    cost 10000
    language sql
as
$$
SELECT CASE WHEN valid THEN 'Valid Geometry' ELSE reason END FROM (
                                                                      SELECT (public.ST_isValidDetail($1, $2)).*
                                                                  ) foo
    $$;

comment on function st_isvalidreason(geometry, integer) is 'args: geomA, flags - Returns text stating if a geometry is valid, or a reason for invalidity.';

alter function st_isvalidreason(geometry, integer) owner to postgres;

create function st_isvalid(geometry, integer) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language sql
as
$$SELECT (public.ST_isValidDetail($1, $2)).valid$$;

comment on function st_isvalid(geometry, integer) is 'args: g, flags - Tests if a geometry is well-formed in 2D.';

alter function st_isvalid(geometry, integer) owner to postgres;

create function st_hausdorffdistance(geom1 geometry, geom2 geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_hausdorffdistance(geometry, geometry) is 'args: g1, g2 - Returns the Hausdorff distance between two geometries.';

alter function st_hausdorffdistance(geometry, geometry) owner to postgres;

create function st_hausdorffdistance(geom1 geometry, geom2 geometry, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_hausdorffdistance(geometry, geometry, double precision) is 'args: g1, g2, densifyFrac - Returns the Hausdorff distance between two geometries.';

alter function st_hausdorffdistance(geometry, geometry, double precision) owner to postgres;

create function st_frechetdistance(geom1 geometry, geom2 geometry, double precision default '-1'::integer) returns double precision
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_frechetdistance(geometry, geometry, double precision) is 'args: g1, g2, densifyFrac = -1 - Returns the Fréchet distance between two geometries.';

alter function st_frechetdistance(geometry, geometry, double precision) owner to postgres;

create function st_maximuminscribedcircle(geometry, out center geometry, out nearest geometry, out radius double precision) returns record
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_maximuminscribedcircle(geometry, out geometry, out geometry, out double precision) is 'args: geom - Computes the largest circle that is fully contained within a geometry.';

alter function st_maximuminscribedcircle(geometry, out geometry, out geometry, out double precision) owner to postgres;

create function st_difference(geom1 geometry, geom2 geometry, gridsize double precision default '-1.0'::numeric) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_difference(geometry, geometry, double precision) is 'args: geomA, geomB, gridSize = -1 - Computes a geometry representing the part of geometry A that does not intersect geometry B.';

alter function st_difference(geometry, geometry, double precision) owner to postgres;

create function st_boundary(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_boundary(geometry) is 'args: geomA - Returns the boundary of a geometry.';

alter function st_boundary(geometry) owner to postgres;

create function st_points(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_points(geometry) is 'args: geom - Returns a MultiPoint containing the coordinates of a geometry.';

alter function st_points(geometry) owner to postgres;

create function st_symdifference(geom1 geometry, geom2 geometry, gridsize double precision default '-1.0'::numeric) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_symdifference(geometry, geometry, double precision) is 'args: geomA, geomB, gridSize = -1 - Computes a geometry representing the portions of geometries A and B that do not intersect.';

alter function st_symdifference(geometry, geometry, double precision) owner to postgres;

create function st_symmetricdifference(geom1 geometry, geom2 geometry) returns geometry
    language sql
    as
$$SELECT ST_SymDifference(geom1, geom2, -1.0);$$;

alter function st_symmetricdifference(geometry, geometry) owner to postgres;

create function st_union(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_union(geometry, geometry) is 'args: g1, g2 - Computes a geometry representing the point-set union of the input geometries.';

alter function st_union(geometry, geometry) owner to postgres;

create function st_union(geom1 geometry, geom2 geometry, gridsize double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_union(geometry, geometry, double precision) is 'args: g1, g2, gridSize - Computes a geometry representing the point-set union of the input geometries.';

alter function st_union(geometry, geometry, double precision) owner to postgres;

create function st_unaryunion(geometry, gridsize double precision default '-1.0'::numeric) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_unaryunion(geometry, double precision) is 'args: geom, gridSize = -1 - Computes the union of the components of a single geometry.';

alter function st_unaryunion(geometry, double precision) owner to postgres;

create function st_removerepeatedpoints(geom geometry, tolerance double precision default 0.0) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_removerepeatedpoints(geometry, double precision) is 'args: geom, tolerance - Returns a version of the given geometry with duplicated points removed.';

alter function st_removerepeatedpoints(geometry, double precision) owner to postgres;

create function st_clipbybox2d(geom geometry, box box2d) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_clipbybox2d(geometry, box2d) is 'args: geom, box - Computes the portion of a geometry falling within a rectangle.';

alter function st_clipbybox2d(geometry, box2d) owner to postgres;

create function st_subdivide(geom geometry, maxvertices integer default 256, gridsize double precision default '-1.0'::numeric) returns setof setof geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_subdivide(geometry, integer, double precision) is 'args: geom, max_vertices=256, gridSize = -1 - Computes a rectilinear subdivision of a geometry.';

alter function st_subdivide(geometry, integer, double precision) owner to postgres;

create function st_reduceprecision(geom geometry, gridsize double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_reduceprecision(geometry, double precision) is 'args: g, gridsize - Returns a valid geometry with points rounded to a grid tolerance.';

alter function st_reduceprecision(geometry, double precision) owner to postgres;

create function st_makevalid(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makevalid(geometry) is 'args: input - Attempts to make an invalid geometry valid without losing vertices.';

alter function st_makevalid(geometry) owner to postgres;

create function st_makevalid(geom geometry, params text) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makevalid(geometry, text) is 'args: input, params - Attempts to make an invalid geometry valid without losing vertices.';

alter function st_makevalid(geometry, text) owner to postgres;

create function st_cleangeometry(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_cleangeometry(geometry) owner to postgres;

create function st_split(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_split(geometry, geometry) is 'args: input, blade - Returns a collection of geometries created by splitting a geometry by another geometry.';

alter function st_split(geometry, geometry) owner to postgres;

create function st_sharedpaths(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_sharedpaths(geometry, geometry) is 'args: lineal1, lineal2 - Returns a collection containing paths shared by the two input linestrings/multilinestrings.';

alter function st_sharedpaths(geometry, geometry) owner to postgres;

create function st_snap(geom1 geometry, geom2 geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_snap(geometry, geometry, double precision) is 'args: input, reference, tolerance - Snap segments and vertices of input geometry to vertices of a reference geometry.';

alter function st_snap(geometry, geometry, double precision) owner to postgres;

create function st_relatematch(text, text) returns boolean
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_relatematch(text, text) owner to postgres;

create function st_node(g geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_node(geometry) is 'args: geom - Nodes a collection of lines.';

alter function st_node(geometry) owner to postgres;

create function st_delaunaytriangles(g1 geometry, tolerance double precision default 0.0, flags integer default 0) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_delaunaytriangles(geometry, double precision, integer) is 'args: g1, tolerance, flags - Returns the Delaunay triangulation of the vertices of a geometry.';

alter function st_delaunaytriangles(geometry, double precision, integer) owner to postgres;

create function _st_voronoi(g1 geometry, clip geometry default NULL::geometry, tolerance double precision default 0.0, return_polygons boolean default true) returns geometry
    immutable
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_voronoi(geometry, geometry, double precision, boolean) owner to postgres;

create function st_voronoipolygons(g1 geometry, tolerance double precision DEFAULT 0.0, extend_to geometry DEFAULT NULL::geometry) returns geometry
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_Voronoi(g1, extend_to, tolerance, true) $$;

comment on function st_voronoipolygons(geometry, double precision, geometry) is 'args: g1, tolerance, extend_to - Returns the cells of the Voronoi diagram of the vertices of a geometry.';

alter function st_voronoipolygons(geometry, double precision, geometry) owner to postgres;

create function st_voronoilines(g1 geometry, tolerance double precision DEFAULT 0.0, extend_to geometry DEFAULT NULL::geometry) returns geometry
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_Voronoi(g1, extend_to, tolerance, false) $$;

comment on function st_voronoilines(geometry, double precision, geometry) is 'args: g1, tolerance, extend_to - Returns the boundaries of the Voronoi diagram of the vertices of a geometry.';

alter function st_voronoilines(geometry, double precision, geometry) owner to postgres;

create function st_combinebbox(box3d, geometry) returns box3d
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_combinebbox(box3d, geometry) owner to postgres;

create function st_combinebbox(box3d, box3d) returns box3d
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_combinebbox(box3d, box3d) owner to postgres;

create function st_combinebbox(box2d, geometry) returns box2d
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_combinebbox(box2d, geometry) owner to postgres;

create function st_collect(geom1 geometry, geom2 geometry) returns geometry
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_collect(geometry, geometry) is 'args: g1, g2 - Creates a GeometryCollection or Multi* geometry from a set of geometries.';

alter function st_collect(geometry, geometry) owner to postgres;

create function st_collect(geometry[]) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_collect(geometry[]) is 'args: g1_array - Creates a GeometryCollection or Multi* geometry from a set of geometries.';

alter function st_collect(geometry[]) owner to postgres;

create function pgis_geometry_accum_transfn(internal, geometry) returns internal
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_geometry_accum_transfn(internal, geometry) owner to postgres;

create function pgis_geometry_accum_transfn(internal, geometry, double precision) returns internal
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_geometry_accum_transfn(internal, geometry, double precision) owner to postgres;

create function pgis_geometry_accum_transfn(internal, geometry, double precision, integer) returns internal
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_geometry_accum_transfn(internal, geometry, double precision, integer) owner to postgres;

create function pgis_geometry_union_finalfn(internal) returns geometry
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_geometry_union_finalfn(internal) owner to postgres;

create function pgis_geometry_collect_finalfn(internal) returns geometry
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_geometry_collect_finalfn(internal) owner to postgres;

create function pgis_geometry_polygonize_finalfn(internal) returns geometry
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_geometry_polygonize_finalfn(internal) owner to postgres;

create function pgis_geometry_clusterintersecting_finalfn(internal) returns geometry[]
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_geometry_clusterintersecting_finalfn(internal) owner to postgres;

create function pgis_geometry_clusterwithin_finalfn(internal) returns geometry[]
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_geometry_clusterwithin_finalfn(internal) owner to postgres;

create function pgis_geometry_makeline_finalfn(internal) returns geometry
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_geometry_makeline_finalfn(internal) owner to postgres;

create function st_union(geometry[]) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_union(geometry[]) is 'args: g1_array - Computes a geometry representing the point-set union of the input geometries.';

alter function st_union(geometry[]) owner to postgres;

create function st_clusterkmeans(geom geometry, k integer, max_radius double precision default NULL::double precision) returns integer
    window
    strict
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_clusterkmeans(geometry, integer, double precision) is 'args: geom, number_of_clusters, max_radius - Window function that returns a cluster id for each input geometry using the K-means algorithm.';

alter function st_clusterkmeans(geometry, integer, double precision) owner to postgres;

create function st_relate(geom1 geometry, geom2 geometry) returns text
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_relate(geometry, geometry) owner to postgres;

create function st_relate(geom1 geometry, geom2 geometry, integer) returns text
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_relate(geometry, geometry, integer) owner to postgres;

create function st_relate(geom1 geometry, geom2 geometry, text) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_relate(geometry, geometry, text) owner to postgres;

create function st_disjoint(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_disjoint(geometry, geometry) owner to postgres;

create function _st_linecrossingdirection(line1 geometry, line2 geometry) returns integer
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_linecrossingdirection(geometry, geometry) owner to postgres;

create function _st_dwithin(geom1 geometry, geom2 geometry, double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_dwithin(geometry, geometry, double precision) owner to postgres;

create function _st_touches(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_touches(geometry, geometry) owner to postgres;

create function _st_intersects(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_intersects(geometry, geometry) owner to postgres;

create function _st_crosses(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_crosses(geometry, geometry) owner to postgres;

create function _st_contains(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_contains(geometry, geometry) owner to postgres;

create function _st_containsproperly(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_containsproperly(geometry, geometry) owner to postgres;

create function _st_covers(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_covers(geometry, geometry) owner to postgres;

create function _st_coveredby(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_coveredby(geometry, geometry) owner to postgres;

create function _st_within(geom1 geometry, geom2 geometry) returns boolean
    immutable
    parallel safe
    language sql
as
$$SELECT public._ST_Contains($2,$1)$$;

alter function _st_within(geometry, geometry) owner to postgres;

create function _st_overlaps(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_overlaps(geometry, geometry) owner to postgres;

create function _st_dfullywithin(geom1 geometry, geom2 geometry, double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_dfullywithin(geometry, geometry, double precision) owner to postgres;

create function _st_3ddwithin(geom1 geometry, geom2 geometry, double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_3ddwithin(geometry, geometry, double precision) owner to postgres;

create function _st_3ddfullywithin(geom1 geometry, geom2 geometry, double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_3ddfullywithin(geometry, geometry, double precision) owner to postgres;

create function _st_3dintersects(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_3dintersects(geometry, geometry) owner to postgres;

create function _st_orderingequals(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_orderingequals(geometry, geometry) owner to postgres;

create function _st_equals(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_equals(geometry, geometry) owner to postgres;

create function postgis_index_supportfn(internal) returns internal
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function postgis_index_supportfn(internal) owner to postgres;

create function st_linecrossingdirection(line1 geometry, line2 geometry) returns integer
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_linecrossingdirection(geometry, geometry) owner to postgres;

create function st_dwithin(geom1 geometry, geom2 geometry, double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_dwithin(geometry, geometry, double precision) owner to postgres;

create function st_touches(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_touches(geometry, geometry) owner to postgres;

create function st_intersects(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_intersects(geometry, geometry) owner to postgres;

create function st_crosses(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_crosses(geometry, geometry) owner to postgres;

create function st_contains(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_contains(geometry, geometry) owner to postgres;

create function st_containsproperly(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_containsproperly(geometry, geometry) owner to postgres;

create function st_within(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_within(geometry, geometry) owner to postgres;

create function st_covers(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_covers(geometry, geometry) owner to postgres;

create function st_coveredby(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_coveredby(geometry, geometry) owner to postgres;

create function st_overlaps(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_overlaps(geometry, geometry) owner to postgres;

create function st_dfullywithin(geom1 geometry, geom2 geometry, double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_dfullywithin(geometry, geometry, double precision) owner to postgres;

create function st_3ddwithin(geom1 geometry, geom2 geometry, double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_3ddwithin(geometry, geometry, double precision) owner to postgres;

create function st_3ddfullywithin(geom1 geometry, geom2 geometry, double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_3ddfullywithin(geometry, geometry, double precision) owner to postgres;

create function st_3dintersects(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_3dintersects(geometry, geometry) owner to postgres;

create function st_orderingequals(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_orderingequals(geometry, geometry) owner to postgres;

create function st_equals(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_equals(geometry, geometry) owner to postgres;

create function st_isvalid(geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_isvalid(geometry) is 'args: g - Tests if a geometry is well-formed in 2D.';

alter function st_isvalid(geometry) owner to postgres;

create function st_minimumclearance(geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_minimumclearance(geometry) is 'args: g - Returns the minimum clearance of a geometry, a measure of a geometrys robustness.';

alter function st_minimumclearance(geometry) owner to postgres;

create function st_minimumclearanceline(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_minimumclearanceline(geometry) is 'args: g - Returns the two-point LineString spanning a geometrys minimum clearance.';

alter function st_minimumclearanceline(geometry) owner to postgres;

create function st_centroid(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_centroid(geometry) is 'args: g1 - Returns the geometric center of a geometry.';

alter function st_centroid(geometry) owner to postgres;

create function st_geometricmedian(g geometry, tolerance double precision default NULL::double precision, max_iter integer default 10000, fail_if_not_converged boolean default false) returns geometry
    immutable
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_geometricmedian(geometry, double precision, integer, boolean) is 'args: geom, tolerance = NULL, max_iter = 10000, fail_if_not_converged = false - Returns the geometric median of a MultiPoint.';

alter function st_geometricmedian(geometry, double precision, integer, boolean) owner to postgres;

create function st_isring(geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_isring(geometry) is 'args: g - Tests if a LineString is closed and simple.';

alter function st_isring(geometry) owner to postgres;

create function st_pointonsurface(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_pointonsurface(geometry) is 'args: g1 - Computes a point guaranteed to lie in a polygon, or on a geometry.';

alter function st_pointonsurface(geometry) owner to postgres;

create function st_issimple(geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_issimple(geometry) is 'args: geomA - Tests if a geometry has no points of self-intersection or self-tangency.';

alter function st_issimple(geometry) owner to postgres;

create function st_iscollection(geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_iscollection(geometry) is 'args: g - Tests if a geometry is a geometry collection type.';

alter function st_iscollection(geometry) owner to postgres;

create function equals(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function equals(geometry, geometry) owner to postgres;

create function _st_geomfromgml(text, integer) returns geometry
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_geomfromgml(text, integer) owner to postgres;

create function st_geomfromgml(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geomfromgml(text, integer) owner to postgres;

create function st_geomfromgml(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$SELECT public._ST_GeomFromGML($1, 0)$$;

alter function st_geomfromgml(text) owner to postgres;

create function st_gmltosql(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$SELECT public._ST_GeomFromGML($1, 0)$$;

alter function st_gmltosql(text) owner to postgres;

create function st_gmltosql(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_gmltosql(text, integer) owner to postgres;

create function st_geomfromkml(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geomfromkml(text) owner to postgres;

create function st_geomfromgeojson(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geomfromgeojson(text) owner to postgres;

create function st_geomfromgeojson(json) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$SELECT public.ST_GeomFromGeoJson($1::text)$$;

alter function st_geomfromgeojson(json) owner to postgres;

create function st_geomfromgeojson(jsonb) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$SELECT public.ST_GeomFromGeoJson($1::text)$$;

alter function st_geomfromgeojson(jsonb) owner to postgres;

create function postgis_libjson_version() returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function postgis_libjson_version() owner to postgres;

create function st_linefromencodedpolyline(txtin text, nprecision integer default 5) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_linefromencodedpolyline(text, integer) owner to postgres;

create function st_asencodedpolyline(geom geometry, nprecision integer default 5) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asencodedpolyline(geometry, integer) owner to postgres;

create function st_assvg(geom geometry, rel integer default 0, maxdecimaldigits integer default 15) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_assvg(geometry, integer, integer) owner to postgres;

create function _st_asgml(integer, geometry, integer, integer, text, text) returns text
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_asgml(integer, geometry, integer, integer, text, text) owner to postgres;

create function st_asgml(geom geometry, maxdecimaldigits integer default 15, options integer default 0) returns text
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asgml(geometry, integer, integer) owner to postgres;

create function st_asgml(version integer, geom geometry, maxdecimaldigits integer default 15, options integer default 0, nprefix text default NULL::text, id text default NULL::text) returns text
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asgml(integer, geometry, integer, integer, text, text) owner to postgres;

create function st_askml(geom geometry, maxdecimaldigits integer default 15, nprefix text default ''::text) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_askml(geometry, integer, text) owner to postgres;

create function st_asgeojson(geom geometry, maxdecimaldigits integer default 9, options integer default 8) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asgeojson(geometry, integer, integer) owner to postgres;

create function st_asgeojson(r record, geom_column text default ''::text, maxdecimaldigits integer default 9, pretty_bool boolean default false) returns text
    stable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asgeojson(record, text, integer, boolean) owner to postgres;

create function json(geometry) returns json
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function json(geometry) owner to postgres;

create function jsonb(geometry) returns jsonb
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function jsonb(geometry) owner to postgres;

create function pgis_asmvt_transfn(internal, anyelement) returns internal
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asmvt_transfn(internal, anyelement) owner to postgres;

create function pgis_asmvt_transfn(internal, anyelement, text) returns internal
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asmvt_transfn(internal, anyelement, text) owner to postgres;

create function pgis_asmvt_transfn(internal, anyelement, text, integer) returns internal
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asmvt_transfn(internal, anyelement, text, integer) owner to postgres;

create function pgis_asmvt_transfn(internal, anyelement, text, integer, text) returns internal
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asmvt_transfn(internal, anyelement, text, integer, text) owner to postgres;

create function pgis_asmvt_transfn(internal, anyelement, text, integer, text, text) returns internal
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asmvt_transfn(internal, anyelement, text, integer, text, text) owner to postgres;

create function pgis_asmvt_finalfn(internal) returns bytea
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asmvt_finalfn(internal) owner to postgres;

create function pgis_asmvt_combinefn(internal, internal) returns internal
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asmvt_combinefn(internal, internal) owner to postgres;

create function pgis_asmvt_serialfn(internal) returns bytea
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asmvt_serialfn(internal) owner to postgres;

create function pgis_asmvt_deserialfn(bytea, internal) returns internal
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asmvt_deserialfn(bytea, internal) owner to postgres;

create function st_asmvtgeom(geom geometry, bounds box2d, extent integer default 4096, buffer integer default 256, clip_geom boolean default true) returns geometry
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asmvtgeom(geometry, box2d, integer, integer, boolean) owner to postgres;

create function postgis_libprotobuf_version() returns text
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function postgis_libprotobuf_version() owner to postgres;

create function pgis_asgeobuf_transfn(internal, anyelement) returns internal
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asgeobuf_transfn(internal, anyelement) owner to postgres;

create function pgis_asgeobuf_transfn(internal, anyelement, text) returns internal
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asgeobuf_transfn(internal, anyelement, text) owner to postgres;

create function pgis_asgeobuf_finalfn(internal) returns bytea
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asgeobuf_finalfn(internal) owner to postgres;

create function pgis_asflatgeobuf_transfn(internal, anyelement) returns internal
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asflatgeobuf_transfn(internal, anyelement) owner to postgres;

create function pgis_asflatgeobuf_transfn(internal, anyelement, boolean) returns internal
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asflatgeobuf_transfn(internal, anyelement, boolean) owner to postgres;

create function pgis_asflatgeobuf_transfn(internal, anyelement, boolean, text) returns internal
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asflatgeobuf_transfn(internal, anyelement, boolean, text) owner to postgres;

create function pgis_asflatgeobuf_finalfn(internal) returns bytea
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pgis_asflatgeobuf_finalfn(internal) owner to postgres;

create function st_fromflatgeobuftotable(text, text, bytea) returns void
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_fromflatgeobuftotable(text, text, bytea) owner to postgres;

create function st_fromflatgeobuf(anyelement, bytea) returns setof setof anyelement
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;

$$;

alter function st_fromflatgeobuf(anyelement, bytea) owner to postgres;

create function st_geohash(geom geometry, maxchars integer default 0) returns text
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geohash(geometry, integer) owner to postgres;

create function _st_sortablehash(geom geometry) returns bigint
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_sortablehash(geometry) owner to postgres;

create function st_box2dfromgeohash(text, integer default NULL::integer) returns box2d
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_box2dfromgeohash(text, integer) owner to postgres;

create function st_pointfromgeohash(text, integer default NULL::integer) returns geometry
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_pointfromgeohash(text, integer) owner to postgres;

create function st_geomfromgeohash(text, integer DEFAULT NULL::integer) returns geometry
    immutable
    parallel safe
    cost 50
    language sql
as
$$ SELECT CAST(public.ST_Box2dFromGeoHash($1, $2) AS geometry); $$;

alter function st_geomfromgeohash(text, integer) owner to postgres;

create function st_numpoints(geometry) returns integer
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_numpoints(geometry) is 'args: g1 - Returns the number of points in a LineString or CircularString.';

alter function st_numpoints(geometry) owner to postgres;

create function st_numgeometries(geometry) returns integer
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_numgeometries(geometry) is 'args: geom - Returns the number of elements in a geometry collection.';

alter function st_numgeometries(geometry) owner to postgres;

create function st_geometryn(geometry, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_geometryn(geometry, integer) is 'args: geomA, n - Return an element of a geometry collection.';

alter function st_geometryn(geometry, integer) owner to postgres;

create function st_dimension(geometry) returns integer
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_dimension(geometry) is 'args: g - Returns the topological dimension of a geometry.';

alter function st_dimension(geometry) owner to postgres;

create function st_exteriorring(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_exteriorring(geometry) is 'args: a_polygon - Returns a LineString representing the exterior ring of a Polygon.';

alter function st_exteriorring(geometry) owner to postgres;

create function st_numinteriorrings(geometry) returns integer
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_numinteriorrings(geometry) is 'args: a_polygon - Returns the number of interior rings (holes) of a Polygon.';

alter function st_numinteriorrings(geometry) owner to postgres;

create function st_numinteriorring(geometry) returns integer
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_numinteriorring(geometry) is 'args: a_polygon - Returns the number of interior rings (holes) of a Polygon. Aias for ST_NumInteriorRings';

alter function st_numinteriorring(geometry) owner to postgres;

create function st_interiorringn(geometry, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_interiorringn(geometry, integer) is 'args: a_polygon, n - Returns the Nth interior ring (hole) of a Polygon.';

alter function st_interiorringn(geometry, integer) owner to postgres;

create function geometrytype(geometry) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function geometrytype(geometry) is 'args: geomA - Returns the type of a geometry as text.';

alter function geometrytype(geometry) owner to postgres;

create function st_geometrytype(geometry) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_geometrytype(geometry) is 'args: g1 - Returns the SQL-MM type of a geometry as text.';

alter function st_geometrytype(geometry) owner to postgres;

create function st_pointn(geometry, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_pointn(geometry, integer) is 'args: a_linestring, n - Returns the Nth point in the first LineString or circular LineString in a geometry.';

alter function st_pointn(geometry, integer) owner to postgres;

create function st_numpatches(geometry) returns integer
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.ST_GeometryType($1) = 'ST_PolyhedralSurface'
                THEN public.ST_NumGeometries($1)
            ELSE NULL END
           $$;

comment on function st_numpatches(geometry) is 'args: g1 - Return the number of faces on a Polyhedral Surface. Will return null for non-polyhedral geometries.';

alter function st_numpatches(geometry) owner to postgres;

create function st_patchn(geometry, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.ST_GeometryType($1) = 'ST_PolyhedralSurface'
                THEN public.ST_GeometryN($1, $2)
            ELSE NULL END
           $$;

comment on function st_patchn(geometry, integer) is 'args: geomA, n - Returns the Nth geometry (face) of a PolyhedralSurface.';

alter function st_patchn(geometry, integer) owner to postgres;

create function st_startpoint(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_startpoint(geometry) is 'args: geomA - Returns the first point of a LineString.';

alter function st_startpoint(geometry) owner to postgres;

create function st_endpoint(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_endpoint(geometry) is 'args: g - Returns the last point of a LineString or CircularLineString.';

alter function st_endpoint(geometry) owner to postgres;

create function st_isclosed(geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_isclosed(geometry) is 'args: g - Tests if a LineStringss start and end points are coincident. For a PolyhedralSurface tests if it is closed (volumetric).';

alter function st_isclosed(geometry) owner to postgres;

create function st_isempty(geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_isempty(geometry) is 'args: geomA - Tests if a geometry is empty.';

alter function st_isempty(geometry) owner to postgres;

create function st_asbinary(geometry, text) returns bytea
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asbinary(geometry, text) owner to postgres;

create function st_asbinary(geometry) returns bytea
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asbinary(geometry) owner to postgres;

create function st_astext(geometry) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_astext(geometry) owner to postgres;

create function st_astext(geometry, integer) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_astext(geometry, integer) owner to postgres;

create function st_geometryfromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geometryfromtext(text) owner to postgres;

create function st_geometryfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geometryfromtext(text, integer) owner to postgres;

create function st_geomfromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geomfromtext(text) owner to postgres;

create function st_geomfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geomfromtext(text, integer) owner to postgres;

create function st_wkttosql(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_wkttosql(text) owner to postgres;

create function st_pointfromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'POINT'
                THEN public.ST_GeomFromText($1)
            ELSE NULL END
           $$;

alter function st_pointfromtext(text) owner to postgres;

create function st_pointfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'POINT'
                THEN public.ST_GeomFromText($1, $2)
            ELSE NULL END
           $$;

alter function st_pointfromtext(text, integer) owner to postgres;

create function st_linefromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'LINESTRING'
                THEN public.ST_GeomFromText($1)
            ELSE NULL END
           $$;

alter function st_linefromtext(text) owner to postgres;

create function st_linefromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'LINESTRING'
                THEN public.ST_GeomFromText($1,$2)
            ELSE NULL END
           $$;

alter function st_linefromtext(text, integer) owner to postgres;

create function st_polyfromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'POLYGON'
                THEN public.ST_GeomFromText($1)
            ELSE NULL END
           $$;

alter function st_polyfromtext(text) owner to postgres;

create function st_polyfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'POLYGON'
                THEN public.ST_GeomFromText($1, $2)
            ELSE NULL END
           $$;

alter function st_polyfromtext(text, integer) owner to postgres;

create function st_polygonfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$SELECT public.ST_PolyFromText($1, $2)$$;

alter function st_polygonfromtext(text, integer) owner to postgres;

create function st_polygonfromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$SELECT public.ST_PolyFromText($1)$$;

alter function st_polygonfromtext(text) owner to postgres;

create function st_mlinefromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE
           WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'MULTILINESTRING'
               THEN public.ST_GeomFromText($1,$2)
           ELSE NULL END
           $$;

alter function st_mlinefromtext(text, integer) owner to postgres;

create function st_mlinefromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'MULTILINESTRING'
                THEN public.ST_GeomFromText($1)
            ELSE NULL END
           $$;

alter function st_mlinefromtext(text) owner to postgres;

create function st_multilinestringfromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$SELECT public.ST_MLineFromText($1)$$;

alter function st_multilinestringfromtext(text) owner to postgres;

create function st_multilinestringfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$SELECT public.ST_MLineFromText($1, $2)$$;

alter function st_multilinestringfromtext(text, integer) owner to postgres;

create function st_mpointfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'MULTIPOINT'
                THEN ST_GeomFromText($1, $2)
            ELSE NULL END
           $$;

alter function st_mpointfromtext(text, integer) owner to postgres;

create function st_mpointfromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'MULTIPOINT'
                THEN public.ST_GeomFromText($1)
            ELSE NULL END
           $$;

alter function st_mpointfromtext(text) owner to postgres;

create function st_multipointfromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$SELECT public.ST_MPointFromText($1)$$;

alter function st_multipointfromtext(text) owner to postgres;

create function st_mpolyfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'MULTIPOLYGON'
                THEN public.ST_GeomFromText($1,$2)
            ELSE NULL END
           $$;

alter function st_mpolyfromtext(text, integer) owner to postgres;

create function st_mpolyfromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'MULTIPOLYGON'
                THEN public.ST_GeomFromText($1)
            ELSE NULL END
           $$;

alter function st_mpolyfromtext(text) owner to postgres;

create function st_multipolygonfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$SELECT public.ST_MPolyFromText($1, $2)$$;

alter function st_multipolygonfromtext(text, integer) owner to postgres;

create function st_multipolygonfromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$SELECT public.ST_MPolyFromText($1)$$;

alter function st_multipolygonfromtext(text) owner to postgres;

create function st_geomcollfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE
           WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'GEOMETRYCOLLECTION'
               THEN public.ST_GeomFromText($1,$2)
           ELSE NULL END
           $$;

alter function st_geomcollfromtext(text, integer) owner to postgres;

create function st_geomcollfromtext(text) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT CASE
           WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'GEOMETRYCOLLECTION'
               THEN public.ST_GeomFromText($1)
           ELSE NULL END
           $$;

alter function st_geomcollfromtext(text) owner to postgres;

create function st_geomfromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geomfromwkb(bytea) owner to postgres;

create function st_geomfromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT public.ST_SetSRID(public.ST_GeomFromWKB($1), $2)$$;

alter function st_geomfromwkb(bytea, integer) owner to postgres;

create function st_pointfromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'POINT'
                THEN public.ST_GeomFromWKB($1, $2)
            ELSE NULL END
           $$;

alter function st_pointfromwkb(bytea, integer) owner to postgres;

create function st_pointfromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'POINT'
                THEN public.ST_GeomFromWKB($1)
            ELSE NULL END
           $$;

alter function st_pointfromwkb(bytea) owner to postgres;

create function st_linefromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'LINESTRING'
                THEN public.ST_GeomFromWKB($1, $2)
            ELSE NULL END
           $$;

alter function st_linefromwkb(bytea, integer) owner to postgres;

create function st_linefromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'LINESTRING'
                THEN public.ST_GeomFromWKB($1)
            ELSE NULL END
           $$;

alter function st_linefromwkb(bytea) owner to postgres;

create function st_linestringfromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'LINESTRING'
                THEN public.ST_GeomFromWKB($1, $2)
            ELSE NULL END
           $$;

alter function st_linestringfromwkb(bytea, integer) owner to postgres;

create function st_linestringfromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'LINESTRING'
                THEN public.ST_GeomFromWKB($1)
            ELSE NULL END
           $$;

alter function st_linestringfromwkb(bytea) owner to postgres;

create function st_polyfromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'POLYGON'
                THEN public.ST_GeomFromWKB($1, $2)
            ELSE NULL END
           $$;

alter function st_polyfromwkb(bytea, integer) owner to postgres;

create function st_polyfromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'POLYGON'
                THEN public.ST_GeomFromWKB($1)
            ELSE NULL END
           $$;

alter function st_polyfromwkb(bytea) owner to postgres;

create function st_polygonfromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1,$2)) = 'POLYGON'
                THEN public.ST_GeomFromWKB($1, $2)
            ELSE NULL END
           $$;

alter function st_polygonfromwkb(bytea, integer) owner to postgres;

create function st_polygonfromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'POLYGON'
                THEN public.ST_GeomFromWKB($1)
            ELSE NULL END
           $$;

alter function st_polygonfromwkb(bytea) owner to postgres;

create function st_mpointfromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTIPOINT'
                THEN public.ST_GeomFromWKB($1, $2)
            ELSE NULL END
           $$;

alter function st_mpointfromwkb(bytea, integer) owner to postgres;

create function st_mpointfromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTIPOINT'
                THEN public.ST_GeomFromWKB($1)
            ELSE NULL END
           $$;

alter function st_mpointfromwkb(bytea) owner to postgres;

create function st_multipointfromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1,$2)) = 'MULTIPOINT'
                THEN public.ST_GeomFromWKB($1, $2)
            ELSE NULL END
           $$;

alter function st_multipointfromwkb(bytea, integer) owner to postgres;

create function st_multipointfromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTIPOINT'
                THEN public.ST_GeomFromWKB($1)
            ELSE NULL END
           $$;

alter function st_multipointfromwkb(bytea) owner to postgres;

create function st_multilinefromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTILINESTRING'
                THEN public.ST_GeomFromWKB($1)
            ELSE NULL END
           $$;

alter function st_multilinefromwkb(bytea) owner to postgres;

create function st_mlinefromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTILINESTRING'
                THEN public.ST_GeomFromWKB($1, $2)
            ELSE NULL END
           $$;

alter function st_mlinefromwkb(bytea, integer) owner to postgres;

create function st_mlinefromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTILINESTRING'
                THEN public.ST_GeomFromWKB($1)
            ELSE NULL END
           $$;

alter function st_mlinefromwkb(bytea) owner to postgres;

create function st_mpolyfromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
                THEN public.ST_GeomFromWKB($1, $2)
            ELSE NULL END
           $$;

alter function st_mpolyfromwkb(bytea, integer) owner to postgres;

create function st_mpolyfromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
                THEN public.ST_GeomFromWKB($1)
            ELSE NULL END
           $$;

alter function st_mpolyfromwkb(bytea) owner to postgres;

create function st_multipolyfromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
                THEN public.ST_GeomFromWKB($1, $2)
            ELSE NULL END
           $$;

alter function st_multipolyfromwkb(bytea, integer) owner to postgres;

create function st_multipolyfromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
                THEN public.ST_GeomFromWKB($1)
            ELSE NULL END
           $$;

alter function st_multipolyfromwkb(bytea) owner to postgres;

create function st_geomcollfromwkb(bytea, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE
           WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'GEOMETRYCOLLECTION'
               THEN public.ST_GeomFromWKB($1, $2)
           ELSE NULL END
           $$;

alter function st_geomcollfromwkb(bytea, integer) owner to postgres;

create function st_geomcollfromwkb(bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT CASE
           WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'GEOMETRYCOLLECTION'
               THEN public.ST_GeomFromWKB($1)
           ELSE NULL END
           $$;

alter function st_geomcollfromwkb(bytea) owner to postgres;

create function _st_maxdistance(geom1 geometry, geom2 geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_maxdistance(geometry, geometry) owner to postgres;

create function st_maxdistance(geom1 geometry, geom2 geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 10000
    language sql
as
$$SELECT public._ST_MaxDistance(public.ST_ConvexHull($1), public.ST_ConvexHull($2))$$;

comment on function st_maxdistance(geometry, geometry) is 'args: g1, g2 - Returns the 2D largest distance between two geometries in projected units.';

alter function st_maxdistance(geometry, geometry) owner to postgres;

create function st_closestpoint(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_closestpoint(geometry, geometry) is 'args: g1, g2 - Returns the 2D point on g1 that is closest to g2. This is the first point of the shortest line.';

alter function st_closestpoint(geometry, geometry) owner to postgres;

create function st_shortestline(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_shortestline(geometry, geometry) is 'args: g1, g2 - Returns the 2D shortest line between two geometries';

alter function st_shortestline(geometry, geometry) owner to postgres;

create function _st_longestline(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_longestline(geometry, geometry) owner to postgres;

create function st_longestline(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language sql
as
$$SELECT public._ST_LongestLine(public.ST_ConvexHull($1), public.ST_ConvexHull($2))$$;

comment on function st_longestline(geometry, geometry) is 'args: g1, g2 - Returns the 2D longest line between two geometries.';

alter function st_longestline(geometry, geometry) owner to postgres;

create function st_swapordinates(geom geometry, ords cstring) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_swapordinates(geometry, cstring) is 'args: geom, ords - Returns a version of the given geometry with given ordinate values swapped.';

alter function st_swapordinates(geometry, cstring) owner to postgres;

create function st_flipcoordinates(geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_flipcoordinates(geometry) is 'args: geom - Returns a version of a geometry with X and Y axis flipped.';

alter function st_flipcoordinates(geometry) owner to postgres;

create function st_bdpolyfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
geomtext alias for $1;
	srid alias for $2;
	mline public.geometry;
	geom public.geometry;
BEGIN
	mline := public.ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
END IF;

	geom := public.ST_BuildArea(mline);

	IF public.GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
END IF;

RETURN geom;
END;
$$;

alter function st_bdpolyfromtext(text, integer) owner to postgres;

create function st_bdmpolyfromtext(text, integer) returns geometry
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
geomtext alias for $1;
	srid alias for $2;
	mline public.geometry;
	geom public.geometry;
BEGIN
	mline := public.ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
END IF;

	geom := public.ST_Multi(public.ST_BuildArea(mline));

RETURN geom;
END;
$$;

alter function st_bdmpolyfromtext(text, integer) owner to postgres;

create function unlockrows(text) returns integer
    strict
    language plpgsql
as
$$
DECLARE
ret int;
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
END IF;

EXECUTE 'DELETE FROM authorization_table where authid = ' ||
        quote_literal($1);

GET DIAGNOSTICS ret = ROW_COUNT;

RETURN ret;
END;
$$;

comment on function unlockrows(text) is 'args: auth_token - Removes all locks held by an authorization token.';

alter function unlockrows(text) owner to postgres;

create function lockrow(text, text, text, text, timestamp without time zone) returns integer
    strict
    language plpgsql
as
$$
DECLARE
myschema alias for $1;
	mytable alias for $2;
	myrid   alias for $3;
	authid alias for $4;
	expires alias for $5;
	ret int;
	mytoid oid;
	myrec RECORD;

BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
END IF;

EXECUTE 'DELETE FROM authorization_table WHERE expires < now()';

SELECT c.oid INTO mytoid FROM pg_class c, pg_namespace n
WHERE c.relname = mytable
  AND c.relnamespace = n.oid
  AND n.nspname = myschema;

-- RAISE NOTICE 'toid: %', mytoid;

FOR myrec IN SELECT * FROM authorization_table WHERE
        toid = mytoid AND rid = myrid
    LOOP
		IF myrec.authid != authid THEN
			RETURN 0;
ELSE
			RETURN 1;
END IF;
END LOOP;

EXECUTE 'INSERT INTO authorization_table VALUES ('||
        quote_literal(mytoid::text)||','||quote_literal(myrid)||
        ','||quote_literal(expires::text)||
        ','||quote_literal(authid) ||')';

GET DIAGNOSTICS ret = ROW_COUNT;

RETURN ret;
END;
$$;

comment on function lockrow(text, text, text, text, timestamp) is 'args: a_schema_name, a_table_name, a_row_key, an_auth_token, expire_dt - Sets lock/authorization for a row in a table.';

alter function lockrow(text, text, text, text, timestamp) owner to postgres;

create function lockrow(text, text, text, text) returns integer
    strict
    language sql
as
$$ SELECT LockRow($1, $2, $3, $4, now()::timestamp+'1:00'); $$;

alter function lockrow(text, text, text, text) owner to postgres;

create function lockrow(text, text, text) returns integer
    strict
    language sql
as
$$ SELECT LockRow(current_schema(), $1, $2, $3, now()::timestamp+'1:00'); $$;

comment on function lockrow(text, text, text) is 'args: a_table_name, a_row_key, an_auth_token - Sets lock/authorization for a row in a table.';

alter function lockrow(text, text, text) owner to postgres;

create function lockrow(text, text, text, timestamp without time zone) returns integer
    strict
    language sql
as
$$ SELECT LockRow(current_schema(), $1, $2, $3, $4); $$;

comment on function lockrow(text, text, text, timestamp) is 'args: a_table_name, a_row_key, an_auth_token, expire_dt - Sets lock/authorization for a row in a table.';

alter function lockrow(text, text, text, timestamp) owner to postgres;

create function addauth(text) returns boolean
    language plpgsql
as
$$
DECLARE
lockid alias for $1;
	okay boolean;
	myrec record;
BEGIN
	-- check to see if table exists
	--  if not, CREATE TEMP TABLE mylock (transid xid, lockcode text)
	okay := 'f';
FOR myrec IN SELECT * FROM pg_class WHERE relname = 'temp_lock_have_table' LOOP
		okay := 't';
END LOOP;
	IF (okay <> 't') THEN
		CREATE TEMP TABLE temp_lock_have_table (transid xid, lockcode text);
			-- this will only work from pgsql7.4 up
			-- ON COMMIT DELETE ROWS;
END IF;

	--  INSERT INTO mylock VALUES ( $1)
--	EXECUTE 'INSERT INTO temp_lock_have_table VALUES ( '||
--		quote_literal(getTransactionID()) || ',' ||
--		quote_literal(lockid) ||')';

INSERT INTO temp_lock_have_table VALUES (getTransactionID(), lockid);

RETURN true::boolean;
END;
$$;

comment on function addauth(text) is 'args: auth_token - Adds an authorization token to be used in the current transaction.';

alter function addauth(text) owner to postgres;

create function checkauth(text, text, text) returns integer
    language plpgsql
as
$$
DECLARE
schema text;
BEGIN
	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
END IF;

	if ( $1 != '' ) THEN
		schema = $1;
ELSE
SELECT current_schema() into schema;
END IF;

	-- TODO: check for an already existing trigger ?

EXECUTE 'CREATE TRIGGER check_auth BEFORE UPDATE OR DELETE ON '
    || quote_ident(schema) || '.' || quote_ident($2)
    ||' FOR EACH ROW EXECUTE PROCEDURE CheckAuthTrigger('
    || quote_literal($3) || ')';

RETURN 0;
END;
$$;

comment on function checkauth(text, text, text) is 'args: a_schema_name, a_table_name, a_key_column_name - Creates a trigger on a table to prevent/allow updates and deletes of rows based on authorization token.';

alter function checkauth(text, text, text) owner to postgres;

create function checkauth(text, text) returns integer
    language sql
    as
$$ SELECT CheckAuth('', $1, $2) $$;

comment on function checkauth(text, text) is 'args: a_table_name, a_key_column_name - Creates a trigger on a table to prevent/allow updates and deletes of rows based on authorization token.';

alter function checkauth(text, text) owner to postgres;

create function checkauthtrigger() returns trigger
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function checkauthtrigger() owner to postgres;

create function gettransactionid() returns xid
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function gettransactionid() owner to postgres;

create function enablelongtransactions() returns text
    language plpgsql
as
$$
DECLARE
"query" text;
exists bool;
	rec RECORD;

BEGIN

exists = 'f';
FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table'
    LOOP
		exists = 't';
END LOOP;

	IF NOT exists
	THEN
		"query" = 'CREATE TABLE authorization_table (
			toid oid, -- table oid
			rid text, -- row id
			expires timestamp,
			authid text
		)';
EXECUTE "query";
END IF;

exists = 'f';
FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables'
    LOOP
		exists = 't';
END LOOP;

	IF NOT exists THEN
		"query" = 'CREATE VIEW authorized_tables AS ' ||
			'SELECT ' ||
			'n.nspname as schema, ' ||
			'c.relname as table, trim(' ||
			quote_literal(chr(92) || '000') ||
			' from t.tgargs) as id_column ' ||
			'FROM pg_trigger t, pg_class c, pg_proc p ' ||
			', pg_namespace n ' ||
			'WHERE p.proname = ' || quote_literal('checkauthtrigger') ||
			' AND c.relnamespace = n.oid' ||
			' AND t.tgfoid = p.oid and t.tgrelid = c.oid';
EXECUTE "query";
END IF;

RETURN 'Long transactions support enabled';
END;
$$;

comment on function enablelongtransactions() is 'Enables long transaction support.';

alter function enablelongtransactions() owner to postgres;

create function longtransactionsenabled() returns boolean
    language plpgsql
as
$$
DECLARE
rec RECORD;
BEGIN
FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
    LOOP
		return 't';
END LOOP;
return 'f';
END;
$$;

alter function longtransactionsenabled() owner to postgres;

create function disablelongtransactions() returns text
    language plpgsql
as
$$
DECLARE
rec RECORD;

BEGIN

	--
	-- Drop all triggers applied by CheckAuth()
	--
FOR rec IN
SELECT c.relname, t.tgname, t.tgargs FROM pg_trigger t, pg_class c, pg_proc p
WHERE p.proname = 'checkauthtrigger' and t.tgfoid = p.oid and t.tgrelid = c.oid
    LOOP
		EXECUTE 'DROP TRIGGER ' || quote_ident(rec.tgname) ||
			' ON ' || quote_ident(rec.relname);
END LOOP;

	--
	-- Drop the authorization_table table
	--
FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table' LOOP
DROP TABLE authorization_table;
END LOOP;

	--
	-- Drop the authorized_tables view
	--
FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables' LOOP
DROP VIEW authorized_tables;
END LOOP;

RETURN 'Long transactions support disabled';
END;
$$;

comment on function disablelongtransactions() is 'Disables long transaction support.';

alter function disablelongtransactions() owner to postgres;

create function geography_typmod_in(cstring[]) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_typmod_in(cstring[]) owner to postgres;

create function geography_typmod_out(integer) returns cstring
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_typmod_out(integer) owner to postgres;

create function geography_in(cstring, oid, integer) returns geography
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_in(cstring, oid, integer) owner to postgres;

create function geography_out(geography) returns cstring
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_out(geography) owner to postgres;

create function geography_recv(internal, oid, integer) returns geography
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_recv(internal, oid, integer) owner to postgres;

create function geography_send(geography) returns bytea
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_send(geography) owner to postgres;

create function geography_analyze(internal) returns boolean
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_analyze(internal) owner to postgres;

create function geography(geography, integer, boolean) returns geography
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography(geography, integer, boolean) owner to postgres;

create function geography(bytea) returns geography
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography(bytea) owner to postgres;

create function bytea(geography) returns bytea
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function bytea(geography) owner to postgres;

create function st_astext(geography) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_astext(geography) owner to postgres;

create function st_astext(geography, integer) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_astext(geography, integer) owner to postgres;

create function st_astext(text) returns text
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$ SELECT public.ST_AsText($1::public.geometry);  $$;

alter function st_astext(text) owner to postgres;

create function st_geographyfromtext(text) returns geography
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geographyfromtext(text) owner to postgres;

create function st_geogfromtext(text) returns geography
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geogfromtext(text) owner to postgres;

create function st_geogfromwkb(bytea) returns geography
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geogfromwkb(bytea) owner to postgres;

create function postgis_typmod_dims(integer) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function postgis_typmod_dims(integer) owner to postgres;

create function postgis_typmod_srid(integer) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function postgis_typmod_srid(integer) owner to postgres;

create function postgis_typmod_type(integer) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function postgis_typmod_type(integer) owner to postgres;

create function geography(geometry) returns geography
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography(geometry) owner to postgres;

create function geometry(geography) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry(geography) owner to postgres;

create function geography_gist_consistent(internal, geography, integer) returns boolean
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function geography_gist_consistent(internal, geography, integer) owner to postgres;

create function geography_gist_compress(internal) returns internal
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function geography_gist_compress(internal) owner to postgres;

create function geography_gist_penalty(internal, internal, internal) returns internal
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function geography_gist_penalty(internal, internal, internal) owner to postgres;

create function geography_gist_picksplit(internal, internal) returns internal
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function geography_gist_picksplit(internal, internal) owner to postgres;

create function geography_gist_union(bytea, internal) returns internal
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function geography_gist_union(bytea, internal) owner to postgres;

create function geography_gist_same(box2d, box2d, internal) returns internal
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function geography_gist_same(box2d, box2d, internal) owner to postgres;

create function geography_gist_decompress(internal) returns internal
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function geography_gist_decompress(internal) owner to postgres;

create function geography_overlaps(geography, geography) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_overlaps(geography, geography) owner to postgres;

create function geography_distance_knn(geography, geography) returns double precision
    immutable
    strict
    parallel safe
    cost 100
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_distance_knn(geography, geography) owner to postgres;

create function geography_gist_distance(internal, geography, integer) returns double precision
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function geography_gist_distance(internal, geography, integer) owner to postgres;

create function overlaps_geog(gidx, geography) returns boolean
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function overlaps_geog(gidx, geography) owner to postgres;

create function overlaps_geog(gidx, gidx) returns boolean
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function overlaps_geog(gidx, gidx) owner to postgres;

create function overlaps_geog(geography, gidx) returns boolean
    immutable
    strict
    language sql
as
$$SELECT $2 OPERATOR(public.&&) $1;$$;

alter function overlaps_geog(geography, gidx) owner to postgres;

create function geog_brin_inclusion_add_value(internal, internal, internal, internal) returns boolean
    language c
    as
$$
begin
-- missing source code
end;
$$;

alter function geog_brin_inclusion_add_value(internal, internal, internal, internal) owner to postgres;

create function geography_lt(geography, geography) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_lt(geography, geography) owner to postgres;

create function geography_le(geography, geography) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_le(geography, geography) owner to postgres;

create function geography_gt(geography, geography) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_gt(geography, geography) owner to postgres;

create function geography_ge(geography, geography) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_ge(geography, geography) owner to postgres;

create function geography_eq(geography, geography) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_eq(geography, geography) owner to postgres;

create function geography_cmp(geography, geography) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_cmp(geography, geography) owner to postgres;

create function st_assvg(geog geography, rel integer default 0, maxdecimaldigits integer default 15) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_assvg(geography, integer, integer) owner to postgres;

create function st_assvg(text) returns text
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$ SELECT public.ST_AsSVG($1::public.geometry,0,15);  $$;

alter function st_assvg(text) owner to postgres;

create function st_asgml(version integer, geog geography, maxdecimaldigits integer default 15, options integer default 0, nprefix text default 'gml'::text, id text default ''::text) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asgml(integer, geography, integer, integer, text, text) owner to postgres;

create function st_asgml(geog geography, maxdecimaldigits integer default 15, options integer default 0, nprefix text default 'gml'::text, id text default ''::text) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asgml(geography, integer, integer, text, text) owner to postgres;

create function st_asgml(text) returns text
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$ SELECT public._ST_AsGML(2,$1::public.geometry,15,0, NULL, NULL);  $$;

alter function st_asgml(text) owner to postgres;

create function st_askml(geog geography, maxdecimaldigits integer default 15, nprefix text default ''::text) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_askml(geography, integer, text) owner to postgres;

create function st_askml(text) returns text
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$ SELECT public.ST_AsKML($1::public.geometry, 15);  $$;

alter function st_askml(text) owner to postgres;

create function st_asgeojson(geog geography, maxdecimaldigits integer default 9, options integer default 0) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asgeojson(geography, integer, integer) owner to postgres;

create function st_asgeojson(text) returns text
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$ SELECT public.ST_AsGeoJson($1::public.geometry, 9, 0);  $$;

alter function st_asgeojson(text) owner to postgres;

create function st_distance(geog1 geography, geog2 geography, use_spheroid boolean default true) returns double precision
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_distance(geography, geography, boolean) is 'args: geog1, geog2, use_spheroid=true - Returns the distance between two geometry or geography values.';

alter function st_distance(geography, geography, boolean) owner to postgres;

create function st_distance(text, text) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_Distance($1::public.geometry, $2::public.geometry);  $$;

alter function st_distance(text, text) owner to postgres;

create function _st_expand(geography, double precision) returns geography
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_expand(geography, double precision) owner to postgres;

create function _st_distanceuncached(geography, geography, double precision, boolean) returns double precision
    immutable
    strict
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_distanceuncached(geography, geography, double precision, boolean) owner to postgres;

create function _st_distanceuncached(geography, geography, boolean) returns double precision
    immutable
    strict
    language sql
as
$$SELECT public._ST_DistanceUnCached($1, $2, 0.0, $3)$$;

alter function _st_distanceuncached(geography, geography, boolean) owner to postgres;

create function _st_distanceuncached(geography, geography) returns double precision
    immutable
    strict
    language sql
as
$$SELECT public._ST_DistanceUnCached($1, $2, 0.0, true)$$;

alter function _st_distanceuncached(geography, geography) owner to postgres;

create function _st_distancetree(geography, geography, double precision, boolean) returns double precision
    immutable
    strict
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_distancetree(geography, geography, double precision, boolean) owner to postgres;

create function _st_distancetree(geography, geography) returns double precision
    immutable
    strict
    language sql
as
$$SELECT public._ST_DistanceTree($1, $2, 0.0, true)$$;

alter function _st_distancetree(geography, geography) owner to postgres;

create function _st_dwithinuncached(geography, geography, double precision, boolean) returns boolean
    immutable
    strict
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_dwithinuncached(geography, geography, double precision, boolean) owner to postgres;

create function _st_dwithinuncached(geography, geography, double precision) returns boolean
    immutable
    language sql
as
$$SELECT $1 OPERATOR(public.&&) public._ST_Expand($2,$3) AND $2 OPERATOR(public.&&) public._ST_Expand($1,$3) AND public._ST_DWithinUnCached($1, $2, $3, true)$$;

alter function _st_dwithinuncached(geography, geography, double precision) owner to postgres;

create function st_area(geog geography, use_spheroid boolean default true) returns double precision
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_area(geography, boolean) is 'args: geog, use_spheroid=true - Returns the area of a polygonal geometry.';

alter function st_area(geography, boolean) owner to postgres;

create function st_area(text) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_Area($1::public.geometry);  $$;

alter function st_area(text) owner to postgres;

create function st_length(geog geography, use_spheroid boolean default true) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_length(geography, boolean) is 'args: geog, use_spheroid=true - Returns the 2D length of a linear geometry.';

alter function st_length(geography, boolean) owner to postgres;

create function st_length(text) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_Length($1::public.geometry);  $$;

alter function st_length(text) owner to postgres;

create function st_project(geog geography, distance double precision, azimuth double precision) returns geography
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_project(geography, double precision, double precision) is 'args: g1, distance, azimuth - Returns a point projected from a start point by a distance and bearing (azimuth).';

alter function st_project(geography, double precision, double precision) owner to postgres;

create function st_azimuth(geog1 geography, geog2 geography) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_azimuth(geography, geography) is 'args: pointA, pointB - Returns the north-based azimuth of a line between two points.';

alter function st_azimuth(geography, geography) owner to postgres;

create function st_perimeter(geog geography, use_spheroid boolean default true) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_perimeter(geography, boolean) is 'args: geog, use_spheroid=true - Returns the length of the boundary of a polygonal geometry or geography.';

alter function st_perimeter(geography, boolean) owner to postgres;

create function _st_pointoutside(geography) returns geography
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_pointoutside(geography) owner to postgres;

create function st_segmentize(geog geography, max_segment_length double precision) returns geography
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_segmentize(geography, double precision) is 'args: geog, max_segment_length - Return a modified geometry/geography having no segment longer than the given distance.';

alter function st_segmentize(geography, double precision) owner to postgres;

create function _st_bestsrid(geography, geography) returns integer
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_bestsrid(geography, geography) owner to postgres;

create function _st_bestsrid(geography) returns integer
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_bestsrid(geography) owner to postgres;

create function st_buffer(geography, double precision) returns geography
    immutable
    strict
    parallel safe
    language sql
as
$$SELECT public.geography(public.ST_Transform(public.ST_Buffer(public.ST_Transform(public.geometry($1), public._ST_BestSRID($1)), $2), 4326))$$;

alter function st_buffer(geography, double precision) owner to postgres;

create function st_buffer(geography, double precision, integer) returns geography
    immutable
    strict
    parallel safe
    language sql
as
$$SELECT public.geography(public.ST_Transform(public.ST_Buffer(public.ST_Transform(public.geometry($1), public._ST_BestSRID($1)), $2, $3), 4326))$$;

comment on function st_buffer(geography, double precision, integer) is 'args: g1, radius_of_buffer, num_seg_quarter_circle - Computes a geometry covering all points within a given distance from a geometry.';

alter function st_buffer(geography, double precision, integer) owner to postgres;

create function st_buffer(geography, double precision, text) returns geography
    immutable
    strict
    parallel safe
    language sql
as
$$SELECT public.geography(public.ST_Transform(public.ST_Buffer(public.ST_Transform(public.geometry($1), public._ST_BestSRID($1)), $2, $3), 4326))$$;

comment on function st_buffer(geography, double precision, text) is 'args: g1, radius_of_buffer, buffer_style_parameters - Computes a geometry covering all points within a given distance from a geometry.';

alter function st_buffer(geography, double precision, text) owner to postgres;

create function st_buffer(text, double precision) returns geometry
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_Buffer($1::public.geometry, $2);  $$;

alter function st_buffer(text, double precision) owner to postgres;

create function st_buffer(text, double precision, integer) returns geometry
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_Buffer($1::public.geometry, $2, $3);  $$;

alter function st_buffer(text, double precision, integer) owner to postgres;

create function st_buffer(text, double precision, text) returns geometry
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_Buffer($1::public.geometry, $2, $3);  $$;

alter function st_buffer(text, double precision, text) owner to postgres;

create function st_intersection(geography, geography) returns geography
    immutable
    strict
    parallel safe
    language sql
as
$$SELECT public.geography(public.ST_Transform(public.ST_Intersection(public.ST_Transform(public.geometry($1), public._ST_BestSRID($1, $2)), public.ST_Transform(public.geometry($2), public._ST_BestSRID($1, $2))), 4326))$$;

comment on function st_intersection(geography, geography) is 'args: geogA, geogB - Computes a geometry representing the shared portion of geometries A and B.';

alter function st_intersection(geography, geography) owner to postgres;

create function st_intersection(text, text) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language sql
as
$$ SELECT public.ST_Intersection($1::public.geometry, $2::public.geometry);  $$;

alter function st_intersection(text, text) owner to postgres;

create function st_asbinary(geography) returns bytea
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asbinary(geography) owner to postgres;

create function st_asbinary(geography, text) returns bytea
    immutable
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asbinary(geography, text) owner to postgres;

create function st_asewkt(geography) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asewkt(geography) owner to postgres;

create function st_asewkt(geography, integer) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_asewkt(geography, integer) owner to postgres;

create function st_asewkt(text) returns text
    immutable
    strict
    parallel safe
    cost 500
    language sql
as
$$ SELECT public.ST_AsEWKT($1::public.geometry);  $$;

alter function st_asewkt(text) owner to postgres;

create function geometrytype(geography) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometrytype(geography) owner to postgres;

create function st_summary(geography) returns text
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_summary(geography) is 'args: g - Returns a text summary of the contents of a geometry.';

alter function st_summary(geography) owner to postgres;

create function st_geohash(geog geography, maxchars integer default 0) returns text
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geohash(geography, integer) owner to postgres;

create function st_srid(geog geography) returns integer
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_srid(geography) owner to postgres;

create function st_setsrid(geog geography, srid integer) returns geography
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_setsrid(geography, integer) owner to postgres;

create function st_centroid(geography, use_spheroid boolean default true) returns geography
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_centroid(geography, boolean) is 'args: g1, use_spheroid=true - Returns the geometric center of a geometry.';

alter function st_centroid(geography, boolean) owner to postgres;

create function st_centroid(text) returns geometry
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_Centroid($1::public.geometry);  $$;

alter function st_centroid(text) owner to postgres;

create function _st_covers(geog1 geography, geog2 geography) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_covers(geography, geography) owner to postgres;

create function _st_dwithin(geog1 geography, geog2 geography, tolerance double precision, use_spheroid boolean default true) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_dwithin(geography, geography, double precision, boolean) owner to postgres;

create function _st_coveredby(geog1 geography, geog2 geography) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_coveredby(geography, geography) owner to postgres;

create function st_covers(geog1 geography, geog2 geography) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_covers(geography, geography) owner to postgres;

create function st_dwithin(geog1 geography, geog2 geography, tolerance double precision, use_spheroid boolean default true) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_dwithin(geography, geography, double precision, boolean) owner to postgres;

create function st_coveredby(geog1 geography, geog2 geography) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_coveredby(geography, geography) owner to postgres;

create function st_intersects(geog1 geography, geog2 geography) returns boolean
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_intersects(geography, geography) owner to postgres;

create function st_covers(text, text) returns boolean
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_Covers($1::public.geometry, $2::public.geometry);  $$;

alter function st_covers(text, text) owner to postgres;

create function st_coveredby(text, text) returns boolean
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_CoveredBy($1::public.geometry, $2::public.geometry);  $$;

alter function st_coveredby(text, text) owner to postgres;

create function st_dwithin(text, text, double precision) returns boolean
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_DWithin($1::public.geometry, $2::public.geometry, $3);  $$;

alter function st_dwithin(text, text, double precision) owner to postgres;

create function st_intersects(text, text) returns boolean
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_Intersects($1::public.geometry, $2::public.geometry);  $$;

alter function st_intersects(text, text) owner to postgres;

create function st_distancesphere(geom1 geometry, geom2 geometry) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$select public.ST_distance( public.geography($1), public.geography($2),false)$$;

comment on function st_distancesphere(geometry, geometry) is 'args: geomlonlatA, geomlonlatB - Returns minimum distance in meters between two lon/lat geometries using a spherical earth model.';

alter function st_distancesphere(geometry, geometry) owner to postgres;

create function postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean DEFAULT true) returns character varying
    immutable
    strict
    parallel safe
    cost 10000
    language sql
as
$$
SELECT CASE WHEN $3 THEN new_name ELSE old_name END As geomname
FROM
    ( VALUES
          ('GEOMETRY', 'Geometry', 2),
          ('GEOMETRY', 'GeometryZ', 3),
          ('GEOMETRYM', 'GeometryM', 3),
          ('GEOMETRY', 'GeometryZM', 4),

          ('GEOMETRYCOLLECTION', 'GeometryCollection', 2),
          ('GEOMETRYCOLLECTION', 'GeometryCollectionZ', 3),
          ('GEOMETRYCOLLECTIONM', 'GeometryCollectionM', 3),
          ('GEOMETRYCOLLECTION', 'GeometryCollectionZM', 4),

          ('POINT', 'Point', 2),
          ('POINT', 'PointZ', 3),
          ('POINTM','PointM', 3),
          ('POINT', 'PointZM', 4),

          ('MULTIPOINT','MultiPoint', 2),
          ('MULTIPOINT','MultiPointZ', 3),
          ('MULTIPOINTM','MultiPointM', 3),
          ('MULTIPOINT','MultiPointZM', 4),

          ('POLYGON', 'Polygon', 2),
          ('POLYGON', 'PolygonZ', 3),
          ('POLYGONM', 'PolygonM', 3),
          ('POLYGON', 'PolygonZM', 4),

          ('MULTIPOLYGON', 'MultiPolygon', 2),
          ('MULTIPOLYGON', 'MultiPolygonZ', 3),
          ('MULTIPOLYGONM', 'MultiPolygonM', 3),
          ('MULTIPOLYGON', 'MultiPolygonZM', 4),

          ('MULTILINESTRING', 'MultiLineString', 2),
          ('MULTILINESTRING', 'MultiLineStringZ', 3),
          ('MULTILINESTRINGM', 'MultiLineStringM', 3),
          ('MULTILINESTRING', 'MultiLineStringZM', 4),

          ('LINESTRING', 'LineString', 2),
          ('LINESTRING', 'LineStringZ', 3),
          ('LINESTRINGM', 'LineStringM', 3),
          ('LINESTRING', 'LineStringZM', 4),

          ('CIRCULARSTRING', 'CircularString', 2),
          ('CIRCULARSTRING', 'CircularStringZ', 3),
          ('CIRCULARSTRINGM', 'CircularStringM' ,3),
          ('CIRCULARSTRING', 'CircularStringZM', 4),

          ('COMPOUNDCURVE', 'CompoundCurve', 2),
          ('COMPOUNDCURVE', 'CompoundCurveZ', 3),
          ('COMPOUNDCURVEM', 'CompoundCurveM', 3),
          ('COMPOUNDCURVE', 'CompoundCurveZM', 4),

          ('CURVEPOLYGON', 'CurvePolygon', 2),
          ('CURVEPOLYGON', 'CurvePolygonZ', 3),
          ('CURVEPOLYGONM', 'CurvePolygonM', 3),
          ('CURVEPOLYGON', 'CurvePolygonZM', 4),

          ('MULTICURVE', 'MultiCurve', 2),
          ('MULTICURVE', 'MultiCurveZ', 3),
          ('MULTICURVEM', 'MultiCurveM', 3),
          ('MULTICURVE', 'MultiCurveZM', 4),

          ('MULTISURFACE', 'MultiSurface', 2),
          ('MULTISURFACE', 'MultiSurfaceZ', 3),
          ('MULTISURFACEM', 'MultiSurfaceM', 3),
          ('MULTISURFACE', 'MultiSurfaceZM', 4),

          ('POLYHEDRALSURFACE', 'PolyhedralSurface', 2),
          ('POLYHEDRALSURFACE', 'PolyhedralSurfaceZ', 3),
          ('POLYHEDRALSURFACEM', 'PolyhedralSurfaceM', 3),
          ('POLYHEDRALSURFACE', 'PolyhedralSurfaceZM', 4),

          ('TRIANGLE', 'Triangle', 2),
          ('TRIANGLE', 'TriangleZ', 3),
          ('TRIANGLEM', 'TriangleM', 3),
          ('TRIANGLE', 'TriangleZM', 4),

          ('TIN', 'Tin', 2),
          ('TIN', 'TinZ', 3),
          ('TINM', 'TinM', 3),
          ('TIN', 'TinZM', 4) )
        As g(old_name, new_name, coord_dimension)
WHERE (upper(old_name) = upper($1) OR upper(new_name) = upper($1))
  AND coord_dimension = $2;
$$;

alter function postgis_type_name(varchar, integer, boolean) owner to postgres;

create function postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text) returns integer
    stable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')::integer
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%srid(% = %';
$$;

alter function postgis_constraint_srid(text, text, text) owner to postgres;

create function postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text) returns integer
    stable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT  replace(split_part(s.consrc, ' = ', 2), ')', '')::integer
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%ndims(% = %';
$$;

alter function postgis_constraint_dims(text, text, text) owner to postgres;

create function postgis_constraint_type(geomschema text, geomtable text, geomcolumn text) returns character varying
    stable
    strict
    parallel safe
    cost 500
    language sql
as
$$
SELECT  replace(split_part(s.consrc, '''', 2), ')', '')::varchar
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%geometrytype(% = %';
$$;

alter function postgis_constraint_type(text, text, text) owner to postgres;

create function st_3ddistance(geom1 geometry, geom2 geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_3ddistance(geometry, geometry) is 'args: g1, g2 - Returns the 3D cartesian minimum distance (based on spatial ref) between two geometries in projected units.';

alter function st_3ddistance(geometry, geometry) owner to postgres;

create function st_3dmaxdistance(geom1 geometry, geom2 geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_3dmaxdistance(geometry, geometry) is 'args: g1, g2 - Returns the 3D cartesian maximum distance (based on spatial ref) between two geometries in projected units.';

alter function st_3dmaxdistance(geometry, geometry) owner to postgres;

create function st_3dclosestpoint(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_3dclosestpoint(geometry, geometry) is 'args: g1, g2 - Returns the 3D point on g1 that is closest to g2. This is the first point of the 3D shortest line.';

alter function st_3dclosestpoint(geometry, geometry) owner to postgres;

create function st_3dshortestline(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_3dshortestline(geometry, geometry) is 'args: g1, g2 - Returns the 3D shortest line between two geometries';

alter function st_3dshortestline(geometry, geometry) owner to postgres;

create function st_3dlongestline(geom1 geometry, geom2 geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_3dlongestline(geometry, geometry) is 'args: g1, g2 - Returns the 3D longest line between two geometries';

alter function st_3dlongestline(geometry, geometry) owner to postgres;

create function st_coorddim(geometry geometry) returns smallint
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_coorddim(geometry) is 'args: geomA - Return the coordinate dimension of a geometry.';

alter function st_coorddim(geometry) owner to postgres;

create function st_curvetoline(geom geometry, tol double precision default 32, toltype integer default 0, flags integer default 0) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_curvetoline(geometry, double precision, integer, integer) is 'args: curveGeom, tolerance, tolerance_type, flags - Converts a geometry containing curves to a linear geometry.';

alter function st_curvetoline(geometry, double precision, integer, integer) owner to postgres;

create function st_hasarc(geometry geometry) returns boolean
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_hasarc(geometry) is 'args: geomA - Tests if a geometry contains a circular arc';

alter function st_hasarc(geometry) owner to postgres;

create function st_linetocurve(geometry geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_linetocurve(geometry) is 'args: geomANoncircular - Converts a linear geometry to a curved geometry.';

alter function st_linetocurve(geometry) owner to postgres;

create function st_point(double precision, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_point(double precision, double precision) is 'args: x, y - Creates a Point with the given coordinate values. Alias for ST_MakePoint.';

alter function st_point(double precision, double precision) owner to postgres;

create function st_point(double precision, double precision, srid integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_point(double precision, double precision, integer) is 'args: x, y, srid=unknown - Creates a Point with the given coordinate values. Alias for ST_MakePoint.';

alter function st_point(double precision, double precision, integer) owner to postgres;

create function st_pointz(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, srid integer default 0) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_pointz(double precision, double precision, double precision, integer) is 'args: x, y, m, srid=unknown - Creates a Point with the given coordinate and SRID values.';

alter function st_pointz(double precision, double precision, double precision, integer) owner to postgres;

create function st_pointm(xcoordinate double precision, ycoordinate double precision, mcoordinate double precision, srid integer default 0) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_pointm(double precision, double precision, double precision, integer) owner to postgres;

create function st_pointzm(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, mcoordinate double precision, srid integer default 0) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_pointzm(double precision, double precision, double precision, double precision, integer) is 'args: x, y, z, m, srid=unknown - Creates a Point with the given coordinate and SRID values.';

alter function st_pointzm(double precision, double precision, double precision, double precision, integer) owner to postgres;

create function st_polygon(geometry, integer) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$
SELECT public.ST_SetSRID(public.ST_MakePolygon($1), $2)
           $$;

comment on function st_polygon(geometry, integer) is 'args: lineString, srid - Creates a Polygon from a LineString with a specified SRID.';

alter function st_polygon(geometry, integer) owner to postgres;

create function st_wkbtosql(wkb bytea) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_wkbtosql(bytea) owner to postgres;

create function st_locatebetween(geometry geometry, frommeasure double precision, tomeasure double precision, leftrightoffset double precision default 0.0) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_locatebetween(geometry, double precision, double precision, double precision) is 'args: geom, measure_start, measure_end, offset = 0 - Returns the portions of a geometry that match a measure range.';

alter function st_locatebetween(geometry, double precision, double precision, double precision) owner to postgres;

create function st_locatealong(geometry geometry, measure double precision, leftrightoffset double precision default 0.0) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_locatealong(geometry, double precision, double precision) is 'args: geom_with_measure, measure, offset = 0 - Returns the point(s) on a geometry that match a measure value.';

alter function st_locatealong(geometry, double precision, double precision) owner to postgres;

create function st_locatebetweenelevations(geometry geometry, fromelevation double precision, toelevation double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_locatebetweenelevations(geometry, double precision, double precision) is 'args: geom, elevation_start, elevation_end - Returns the portions of a geometry that lie in an elevation (Z) range.';

alter function st_locatebetweenelevations(geometry, double precision, double precision) owner to postgres;

create function st_interpolatepoint(line geometry, point geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_interpolatepoint(geometry, geometry) is 'args: line, point - Returns the interpolated measure of a geometry closest to a point.';

alter function st_interpolatepoint(geometry, geometry) owner to postgres;

create function st_hexagon(size double precision, cell_i integer, cell_j integer, origin geometry default '010100000000000000000000000000000000000000'::geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_hexagon(double precision, integer, integer, geometry) is 'args: size, cell_i, cell_j, origin - Returns a single hexagon, using the provided edge size and cell coordinate within the hexagon grid space.';

alter function st_hexagon(double precision, integer, integer, geometry) owner to postgres;

create function st_square(size double precision, cell_i integer, cell_j integer, origin geometry default '010100000000000000000000000000000000000000'::geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_square(double precision, integer, integer, geometry) is 'args: size, cell_i, cell_j, origin - Returns a single square, using the provided edge size and cell coordinate within the square grid space.';

alter function st_square(double precision, integer, integer, geometry) owner to postgres;

create function st_hexagongrid(size double precision, bounds geometry, out geom geometry, out i integer, out j integer) returns setof setof record
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_hexagongrid(double precision, geometry, out geometry, out integer, out integer) is 'args: size, bounds - Returns a set of hexagons and cell indices that completely cover the bounds of the geometry argument.';

alter function st_hexagongrid(double precision, geometry, out geometry, out integer, out integer) owner to postgres;

create function st_squaregrid(size double precision, bounds geometry, out geom geometry, out i integer, out j integer) returns setof setof record
    immutable
    strict
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_squaregrid(double precision, geometry, out geometry, out integer, out integer) is 'args: size, bounds - Returns a set of grid squares and cell indices that completely cover the bounds of the geometry argument.';

alter function st_squaregrid(double precision, geometry, out geometry, out integer, out integer) owner to postgres;

create function contains_2d(box2df, geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function contains_2d(box2df, geometry) owner to postgres;

create function is_contained_2d(box2df, geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function is_contained_2d(box2df, geometry) owner to postgres;

create function overlaps_2d(box2df, geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function overlaps_2d(box2df, geometry) owner to postgres;

create function overlaps_2d(box2df, box2df) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function overlaps_2d(box2df, box2df) owner to postgres;

create function contains_2d(box2df, box2df) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function contains_2d(box2df, box2df) owner to postgres;

create function is_contained_2d(box2df, box2df) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function is_contained_2d(box2df, box2df) owner to postgres;

create function contains_2d(geometry, box2df) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$SELECT $2 OPERATOR(public.@) $1;$$;

alter function contains_2d(geometry, box2df) owner to postgres;

create function is_contained_2d(geometry, box2df) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$SELECT $2 OPERATOR(public.~) $1;$$;

alter function is_contained_2d(geometry, box2df) owner to postgres;

create function overlaps_2d(geometry, box2df) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$SELECT $2 OPERATOR(public.&&) $1;$$;

alter function overlaps_2d(geometry, box2df) owner to postgres;

create function overlaps_nd(gidx, geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function overlaps_nd(gidx, geometry) owner to postgres;

create function overlaps_nd(gidx, gidx) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function overlaps_nd(gidx, gidx) owner to postgres;

create function overlaps_nd(geometry, gidx) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$SELECT $2 OPERATOR(public.&&&) $1;$$;

alter function overlaps_nd(geometry, gidx) owner to postgres;

create function geom2d_brin_inclusion_add_value(internal, internal, internal, internal) returns boolean
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geom2d_brin_inclusion_add_value(internal, internal, internal, internal) owner to postgres;

create function geom3d_brin_inclusion_add_value(internal, internal, internal, internal) returns boolean
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geom3d_brin_inclusion_add_value(internal, internal, internal, internal) owner to postgres;

create function geom4d_brin_inclusion_add_value(internal, internal, internal, internal) returns boolean
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geom4d_brin_inclusion_add_value(internal, internal, internal, internal) owner to postgres;

create function _st_concavehull(param_inputgeom geometry) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language plpgsql
as
$$
DECLARE
vexhull public.geometry;
	var_resultgeom public.geometry;
	var_inputgeom public.geometry;
	vexring public.geometry;
	cavering public.geometry;
	cavept public.geometry[];
	seglength double precision;
	var_tempgeom public.geometry;
	scale_factor float := 1;
	i integer;
BEGIN
		-- First compute the ConvexHull of the geometry
		vexhull := public.ST_ConvexHull(param_inputgeom);
		var_inputgeom := param_inputgeom;
		--A point really has no concave hull
		IF public.ST_GeometryType(vexhull) = 'ST_Point' OR public.ST_GeometryType(vexHull) = 'ST_LineString' THEN
			RETURN vexhull;
END IF;

		-- convert the hull perimeter to a linestring so we can manipulate individual points
		vexring := CASE WHEN public.ST_GeometryType(vexhull) = 'ST_LineString' THEN vexhull ELSE public.ST_ExteriorRing(vexhull) END;
		IF abs(public.ST_X(public.ST_PointN(vexring,1))) < 1 THEN --scale the geometry to prevent stupid precision errors - not sure it works so make low for now
			scale_factor := 100;
			vexring := public.ST_Scale(vexring, scale_factor,scale_factor);
			var_inputgeom := public.ST_Scale(var_inputgeom, scale_factor, scale_factor);
			--RAISE NOTICE 'Scaling';
END IF;
		seglength := public.ST_Length(vexring)/least(public.ST_NPoints(vexring)*2,1000) ;

		vexring := public.ST_Segmentize(vexring, seglength);
		-- find the point on the original geom that is closest to each point of the convex hull and make a new linestring out of it.
		cavering := public.ST_Collect(
			ARRAY(

				SELECT
					public.ST_ClosestPoint(var_inputgeom, pt ) As the_geom
					FROM (
						SELECT  public.ST_PointN(vexring, n ) As pt, n
							FROM
							generate_series(1, public.ST_NPoints(vexring) ) As n
						) As pt

				)
			)
		;

		var_resultgeom := public.ST_MakeLine(geom)
			FROM public.ST_Dump(cavering) As foo;

		IF public.ST_IsSimple(var_resultgeom) THEN
			var_resultgeom := public.ST_MakePolygon(var_resultgeom);
			--RAISE NOTICE 'is Simple: %', var_resultgeom;
ELSE
			--RAISE NOTICE 'is not Simple: %', var_resultgeom;
			var_resultgeom := public.ST_ConvexHull(var_resultgeom);
END IF;

		IF scale_factor > 1 THEN -- scale the result back
			var_resultgeom := public.ST_Scale(var_resultgeom, 1/scale_factor, 1/scale_factor);
END IF;

		-- make sure result covers original (#3638)
		-- Using ST_UnaryUnion since SFCGAL doesn't replace with its own implementation
		-- and SFCGAL one chokes for some reason
		var_resultgeom := public.ST_UnaryUnion(public.ST_Collect(param_inputgeom, var_resultgeom) );
RETURN var_resultgeom;

END;
$$;

alter function _st_concavehull(geometry) owner to postgres;

create function st_concavehull(param_geom geometry, param_pctconvex double precision, param_allow_holes boolean DEFAULT false) returns geometry
    immutable
    strict
    parallel safe
    cost 10000
    language plpgsql
as
$$
DECLARE
var_convhull public.geometry := public.ST_ForceSFS(public.ST_ConvexHull(param_geom));
		var_param_geom public.geometry := public.ST_ForceSFS(param_geom);
		var_initarea float := public.ST_Area(var_convhull);
		var_newarea float := var_initarea;
		var_div integer := 6;
		var_tempgeom public.geometry;
		var_tempgeom2 public.geometry;
		var_cent public.geometry;
		var_geoms public.geometry[4];
		var_enline public.geometry;
		var_resultgeom public.geometry;
		var_atempgeoms public.geometry[];
		var_buf float := 1;
BEGIN
		-- We start with convex hull as our base
		var_resultgeom := var_convhull;

		IF param_pctconvex = 1 THEN
			-- this is the same as asking for the convex hull
			return var_resultgeom;
		ELSIF public.ST_GeometryType(var_param_geom) = 'ST_Polygon' THEN -- it is as concave as it is going to get
			IF param_allow_holes THEN -- leave the holes
				RETURN var_param_geom;
ELSE -- remove the holes
				var_resultgeom := public.ST_MakePolygon(public.ST_ExteriorRing(var_param_geom));
RETURN var_resultgeom;
END IF;
END IF;
		IF public.ST_Dimension(var_resultgeom) > 1 AND param_pctconvex BETWEEN 0 and 0.98 THEN
		-- get linestring that forms envelope of geometry
			var_enline := public.ST_Boundary(public.ST_Envelope(var_param_geom));
			var_buf := public.ST_Length(var_enline)/1000.0;
			IF public.ST_GeometryType(var_param_geom) = 'ST_MultiPoint' AND public.ST_NumGeometries(var_param_geom) BETWEEN 4 and 200 THEN
			-- we make polygons out of points since they are easier to cave in.
			-- Note we limit to between 4 and 200 points because this process is slow and gets quadratically slow
				var_buf := sqrt(public.ST_Area(var_convhull)*0.8/(public.ST_NumGeometries(var_param_geom)*public.ST_NumGeometries(var_param_geom)));
				var_atempgeoms := ARRAY(SELECT geom FROM public.ST_DumpPoints(var_param_geom));
				-- 5 and 10 and just fudge factors
				var_tempgeom := public.ST_Union(ARRAY(SELECT geom
						FROM (
						-- fuse near neighbors together
						SELECT DISTINCT ON (i) i,  public.ST_Distance(var_atempgeoms[i],var_atempgeoms[j]), public.ST_Buffer(public.ST_MakeLine(var_atempgeoms[i], var_atempgeoms[j]) , var_buf*5, 'quad_segs=3') As geom
								FROM generate_series(1,array_upper(var_atempgeoms, 1)) As i
									INNER JOIN generate_series(1,array_upper(var_atempgeoms, 1)) As j
										ON (
								 NOT public.ST_Intersects(var_atempgeoms[i],var_atempgeoms[j])
									AND public.ST_DWithin(var_atempgeoms[i],var_atempgeoms[j], var_buf*10)
									)
								UNION ALL
						-- catch the ones with no near neighbors
								SELECT i, 0, public.ST_Buffer(var_atempgeoms[i] , var_buf*10, 'quad_segs=3') As geom
								FROM generate_series(1,array_upper(var_atempgeoms, 1)) As i
									LEFT JOIN generate_series(ceiling(array_upper(var_atempgeoms,1)/2)::integer,array_upper(var_atempgeoms, 1)) As j
										ON (
								 NOT public.ST_Intersects(var_atempgeoms[i],var_atempgeoms[j])
									AND public.ST_DWithin(var_atempgeoms[i],var_atempgeoms[j], var_buf*10)
									)
									WHERE j IS NULL
								ORDER BY 1, 2
							) As foo	) );
				IF public.ST_IsValid(var_tempgeom) AND public.ST_GeometryType(var_tempgeom) = 'ST_Polygon' THEN
					var_tempgeom := public.ST_ForceSFS(public.ST_Intersection(var_tempgeom, var_convhull));
					IF param_allow_holes THEN
						var_param_geom := var_tempgeom;
					ELSIF public.ST_GeometryType(var_tempgeom) = 'ST_Polygon' THEN
						var_param_geom := public.ST_ForceSFS(public.ST_MakePolygon(public.ST_ExteriorRing(var_tempgeom)));
ELSE
						var_param_geom := public.ST_ForceSFS(public.ST_ConvexHull(var_param_geom));
END IF;
					-- make sure result covers original (#3638)
					var_param_geom := public.ST_Union(param_geom, var_param_geom);
return var_param_geom;
ELSIF public.ST_IsValid(var_tempgeom) THEN
					var_param_geom := public.ST_ForceSFS(public.ST_Intersection(var_tempgeom, var_convhull));
END IF;
END IF;

			IF public.ST_GeometryType(var_param_geom) = 'ST_Polygon' THEN
				IF NOT param_allow_holes THEN
					var_param_geom := public.ST_ForceSFS(public.ST_MakePolygon(public.ST_ExteriorRing(var_param_geom)));
END IF;
				-- make sure result covers original (#3638)
				--var_param_geom := public.ST_Union(param_geom, var_param_geom);
return var_param_geom;
END IF;
            var_cent := public.ST_Centroid(var_param_geom);
            IF (public.ST_XMax(var_enline) - public.ST_XMin(var_enline) ) > var_buf AND (public.ST_YMax(var_enline) - public.ST_YMin(var_enline) ) > var_buf THEN
                    IF public.ST_Dwithin(public.ST_Centroid(var_convhull) , public.ST_Centroid(public.ST_Envelope(var_param_geom)), var_buf/2) THEN
                -- If the geometric dimension is > 1 and the object is symettric (cutting at centroid will not work -- offset a bit)
                        var_cent := public.ST_Translate(var_cent, (public.ST_XMax(var_enline) - public.ST_XMin(var_enline))/1000,  (public.ST_YMAX(var_enline) - public.ST_YMin(var_enline))/1000);
ELSE
                        -- uses closest point on geometry to centroid. I can't explain why we are doing this
                        var_cent := public.ST_ClosestPoint(var_param_geom,var_cent);
END IF;
                    IF public.ST_DWithin(var_cent, var_enline,var_buf) THEN
                        var_cent := public.ST_centroid(public.ST_Envelope(var_param_geom));
END IF;
                    -- break envelope into 4 triangles about the centroid of the geometry and returned the clipped geometry in each quadrant
FOR i in 1 .. 4 LOOP
                       var_geoms[i] := public.ST_MakePolygon(public.ST_MakeLine(ARRAY[public.ST_PointN(var_enline,i), public.ST_PointN(var_enline,i+1), var_cent, public.ST_PointN(var_enline,i)]));
                       var_geoms[i] := public.ST_ForceSFS(public.ST_Intersection(var_param_geom, public.ST_Buffer(var_geoms[i],var_buf)));
                       IF public.ST_IsValid(var_geoms[i]) THEN

                       ELSE
                            var_geoms[i] := public.ST_BuildArea(public.ST_MakeLine(ARRAY[public.ST_PointN(var_enline,i), public.ST_PointN(var_enline,i+1), var_cent, public.ST_PointN(var_enline,i)]));
END IF;
END LOOP;
                    var_tempgeom := public.ST_Union(ARRAY[public.ST_ConvexHull(var_geoms[1]), public.ST_ConvexHull(var_geoms[2]) , public.ST_ConvexHull(var_geoms[3]), public.ST_ConvexHull(var_geoms[4])]);
                    --RAISE NOTICE 'Curr vex % ', public.ST_AsText(var_tempgeom);
                    IF public.ST_Area(var_tempgeom) <= var_newarea AND public.ST_IsValid(var_tempgeom)  THEN --AND public.ST_GeometryType(var_tempgeom) ILIKE '%Polygon'

                        var_tempgeom := public.ST_Buffer(public.ST_ConcaveHull(var_geoms[1],least(param_pctconvex + param_pctconvex/var_div),true),var_buf, 'quad_segs=2');
FOR i IN 1 .. 4 LOOP
                            var_geoms[i] := public.ST_Buffer(public.ST_ConcaveHull(var_geoms[i],least(param_pctconvex + param_pctconvex/var_div),true), var_buf, 'quad_segs=2');
                            IF public.ST_IsValid(var_geoms[i]) Then
                                var_tempgeom := public.ST_Union(var_tempgeom, var_geoms[i]);
ELSE
                                RAISE NOTICE 'Not valid % %', i, public.ST_AsText(var_tempgeom);
                                var_tempgeom := public.ST_Union(var_tempgeom, public.ST_ConvexHull(var_geoms[i]));
END IF;
END LOOP;

                        --RAISE NOTICE 'Curr concave % ', public.ST_AsText(var_tempgeom);
                        IF public.ST_IsValid(var_tempgeom) THEN
                            var_resultgeom := var_tempgeom;
END IF;
                        var_newarea := public.ST_Area(var_resultgeom);
                    ELSIF public.ST_IsValid(var_tempgeom) THEN
                        var_resultgeom := var_tempgeom;
END IF;

                    IF public.ST_NumGeometries(var_resultgeom) > 1  THEN
                        var_tempgeom := public._ST_ConcaveHull(var_resultgeom);
                        IF public.ST_IsValid(var_tempgeom) AND public.ST_GeometryType(var_tempgeom) ILIKE 'ST_Polygon' THEN
                            var_resultgeom := var_tempgeom;
ELSE
                            var_resultgeom := public.ST_Buffer(var_tempgeom,var_buf, 'quad_segs=2');
END IF;
END IF;
                    IF param_allow_holes = false THEN
                    -- only keep exterior ring since we do not want holes
                        var_resultgeom := public.ST_MakePolygon(public.ST_ExteriorRing(var_resultgeom));
END IF;
ELSE
                    var_resultgeom := public.ST_Buffer(var_resultgeom,var_buf);
END IF;
                var_resultgeom := public.ST_ForceSFS(public.ST_Intersection(var_resultgeom, public.ST_ConvexHull(var_param_geom)));
ELSE
                -- dimensions are too small to cut
                var_resultgeom := public._ST_ConcaveHull(var_param_geom);
END IF;

RETURN var_resultgeom;
END;
$$;

comment on function st_concavehull(geometry, double precision, boolean) is 'args: geom, target_percent, allow_holes = false - Computes a possibly concave geometry that encloses all input geometry vertices';

alter function st_concavehull(geometry, double precision, boolean) owner to postgres;

create function _st_asx3d(integer, geometry, integer, integer, text) returns text
    immutable
    parallel safe
    cost 500
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_asx3d(integer, geometry, integer, integer, text) owner to postgres;

create function st_asx3d(geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0) returns text
    immutable
    parallel safe
    cost 500
    language sql
as
$$SELECT public._ST_AsX3D(3,$1,$2,$3,'');$$;

alter function st_asx3d(geometry, integer, integer) owner to postgres;

create function st_angle(line1 geometry, line2 geometry) returns double precision
    immutable
    strict
    parallel safe
    cost 50
    language sql
as
$$SELECT ST_Angle(St_StartPoint($1), ST_EndPoint($1), St_StartPoint($2), ST_EndPoint($2))$$;

comment on function st_angle(geometry, geometry) is 'args: line1, line2 - Returns the angle between two vectors defined by 3 or 4 points, or 2 lines.';

alter function st_angle(geometry, geometry) owner to postgres;

create function st_3dlineinterpolatepoint(geometry, double precision) returns geometry
    immutable
    strict
    parallel safe
    cost 50
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_3dlineinterpolatepoint(geometry, double precision) is 'args: a_linestring, a_fraction - Returns a point interpolated along a 3D line at a fractional location.';

alter function st_3dlineinterpolatepoint(geometry, double precision) owner to postgres;

create function geometry_spgist_config_2d(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_config_2d(internal, internal) owner to postgres;

create function geometry_spgist_choose_2d(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_choose_2d(internal, internal) owner to postgres;

create function geometry_spgist_picksplit_2d(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_picksplit_2d(internal, internal) owner to postgres;

create function geometry_spgist_inner_consistent_2d(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_inner_consistent_2d(internal, internal) owner to postgres;

create function geometry_spgist_leaf_consistent_2d(internal, internal) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_leaf_consistent_2d(internal, internal) owner to postgres;

create function geometry_spgist_compress_2d(internal) returns internal
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_compress_2d(internal) owner to postgres;

create function geometry_overlaps_3d(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_overlaps_3d(geometry, geometry) owner to postgres;

create function geometry_contains_3d(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_contains_3d(geometry, geometry) owner to postgres;

create function geometry_contained_3d(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_contained_3d(geometry, geometry) owner to postgres;

create function geometry_same_3d(geom1 geometry, geom2 geometry) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_same_3d(geometry, geometry) owner to postgres;

create function geometry_spgist_config_3d(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_config_3d(internal, internal) owner to postgres;

create function geometry_spgist_choose_3d(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_choose_3d(internal, internal) owner to postgres;

create function geometry_spgist_picksplit_3d(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_picksplit_3d(internal, internal) owner to postgres;

create function geometry_spgist_inner_consistent_3d(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_inner_consistent_3d(internal, internal) owner to postgres;

create function geometry_spgist_leaf_consistent_3d(internal, internal) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_leaf_consistent_3d(internal, internal) owner to postgres;

create function geometry_spgist_compress_3d(internal) returns internal
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_compress_3d(internal) owner to postgres;

create function geometry_spgist_config_nd(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_config_nd(internal, internal) owner to postgres;

create function geometry_spgist_choose_nd(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_choose_nd(internal, internal) owner to postgres;

create function geometry_spgist_picksplit_nd(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_picksplit_nd(internal, internal) owner to postgres;

create function geometry_spgist_inner_consistent_nd(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_inner_consistent_nd(internal, internal) owner to postgres;

create function geometry_spgist_leaf_consistent_nd(internal, internal) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_leaf_consistent_nd(internal, internal) owner to postgres;

create function geometry_spgist_compress_nd(internal) returns internal
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geometry_spgist_compress_nd(internal) owner to postgres;

create function geography_spgist_config_nd(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_spgist_config_nd(internal, internal) owner to postgres;

create function geography_spgist_choose_nd(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_spgist_choose_nd(internal, internal) owner to postgres;

create function geography_spgist_picksplit_nd(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_spgist_picksplit_nd(internal, internal) owner to postgres;

create function geography_spgist_inner_consistent_nd(internal, internal) returns void
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_spgist_inner_consistent_nd(internal, internal) owner to postgres;

create function geography_spgist_leaf_consistent_nd(internal, internal) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_spgist_leaf_consistent_nd(internal, internal) owner to postgres;

create function geography_spgist_compress_nd(internal) returns internal
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function geography_spgist_compress_nd(internal) owner to postgres;

create function levenshtein(text, text) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function levenshtein(text, text) owner to postgres;

create function levenshtein(text, text, integer, integer, integer) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function levenshtein(text, text, integer, integer, integer) owner to postgres;

create function levenshtein_less_equal(text, text, integer) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function levenshtein_less_equal(text, text, integer) owner to postgres;

create function levenshtein_less_equal(text, text, integer, integer, integer, integer) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function levenshtein_less_equal(text, text, integer, integer, integer, integer) owner to postgres;

create function metaphone(text, integer) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function metaphone(text, integer) owner to postgres;

create function soundex(text) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function soundex(text) owner to postgres;

create function text_soundex(text) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function text_soundex(text) owner to postgres;

create function difference(text, text) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function difference(text, text) owner to postgres;

create function dmetaphone(text) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function dmetaphone(text) owner to postgres;

create function dmetaphone_alt(text) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function dmetaphone_alt(text) owner to postgres;

create function raster_in(cstring) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function raster_in(cstring) owner to postgres;

create function raster_out(raster) returns cstring
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function raster_out(raster) owner to postgres;

create function postgis_raster_lib_version() returns text
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_raster_lib_version() is 'Reports full raster version and build configuration infos.';

alter function postgis_raster_lib_version() owner to postgres;

create function postgis_raster_scripts_installed() returns text
    immutable
    parallel safe
    language sql
as
$$ SELECT trim('3.2.0'::text || $rev$ c3e3cc0 $rev$) AS version $$;

alter function postgis_raster_scripts_installed() owner to postgres;

create function postgis_raster_lib_build_date() returns text
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_raster_lib_build_date() is 'Reports full raster library build date.';

alter function postgis_raster_lib_build_date() owner to postgres;

create function postgis_gdal_version() returns text
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function postgis_gdal_version() is 'Reports the version of the GDAL library in use by PostGIS.';

alter function postgis_gdal_version() owner to postgres;

create function st_envelope(raster) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_envelope(raster) is 'args: rast - Returns the polygon representation of the extent of the raster.';

alter function st_envelope(raster) owner to postgres;

create function st_convexhull(raster) returns geometry
    immutable
    strict
    cost 300
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_convexhull(raster) is 'args: rast - Return the convex hull geometry of the raster including pixel values equal to BandNoDataValue. For regular shaped and non-skewed rasters, this gives the same result as ST_Envelope so only useful for irregularly shaped or skewed rasters.';

alter function st_convexhull(raster) owner to postgres;

create function st_minconvexhull(rast raster, nband integer default NULL::integer) returns geometry
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_minconvexhull(raster, integer) is 'args: rast, nband=NULL - Return the convex hull geometry of the raster excluding NODATA pixels.';

alter function st_minconvexhull(raster, integer) owner to postgres;

create function box3d(raster) returns box3d
    immutable
    strict
    parallel safe
    language sql
as
$$select box3d( public.ST_convexhull($1))$$;

comment on function box3d(raster) is 'args: rast - Returns the box 3d representation of the enclosing box of the raster.';

alter function box3d(raster) owner to postgres;

create function st_height(raster) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_height(raster) is 'args: rast - Returns the height of the raster in pixels.';

alter function st_height(raster) owner to postgres;

create function st_numbands(raster) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_numbands(raster) is 'args: rast - Returns the number of bands in the raster object.';

alter function st_numbands(raster) owner to postgres;

create function st_scalex(raster) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_scalex(raster) is 'args: rast - Returns the X component of the pixel width in units of coordinate reference system.';

alter function st_scalex(raster) owner to postgres;

create function st_scaley(raster) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_scaley(raster) is 'args: rast - Returns the Y component of the pixel height in units of coordinate reference system.';

alter function st_scaley(raster) owner to postgres;

create function st_skewx(raster) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_skewx(raster) is 'args: rast - Returns the georeference X skew (or rotation parameter).';

alter function st_skewx(raster) owner to postgres;

create function st_skewy(raster) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_skewy(raster) is 'args: rast - Returns the georeference Y skew (or rotation parameter).';

alter function st_skewy(raster) owner to postgres;

create function st_srid(raster) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_srid(raster) is 'args: rast - Returns the spatial reference identifier of the raster as defined in spatial_ref_sys table.';

alter function st_srid(raster) owner to postgres;

create function st_upperleftx(raster) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_upperleftx(raster) is 'args: rast - Returns the upper left X coordinate of raster in projected spatial ref.';

alter function st_upperleftx(raster) owner to postgres;

create function st_upperlefty(raster) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_upperlefty(raster) is 'args: rast - Returns the upper left Y coordinate of raster in projected spatial ref.';

alter function st_upperlefty(raster) owner to postgres;

create function st_width(raster) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_width(raster) is 'args: rast - Returns the width of the raster in pixels.';

alter function st_width(raster) owner to postgres;

create function st_pixelwidth(raster) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_pixelwidth(raster) is 'args: rast - Returns the pixel width in geometric units of the spatial reference system.';

alter function st_pixelwidth(raster) owner to postgres;

create function st_pixelheight(raster) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_pixelheight(raster) is 'args: rast - Returns the pixel height in geometric units of the spatial reference system.';

alter function st_pixelheight(raster) owner to postgres;

create function st_geotransform(raster, out imag double precision, out jmag double precision, out theta_i double precision, out theta_ij double precision, out xoffset double precision, out yoffset double precision) returns record
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_geotransform(raster, out double precision, out double precision, out double precision, out double precision, out double precision, out double precision) owner to postgres;

create function st_rotation(raster) returns double precision
    language sql
    as
$$ SELECT ( public.ST_Geotransform($1)).theta_i $$;

comment on function st_rotation(raster) is 'args: rast - Returns the rotation of the raster in radian.';

alter function st_rotation(raster) owner to postgres;

create function st_metadata(rast raster, out upperleftx double precision, out upperlefty double precision, out width integer, out height integer, out scalex double precision, out scaley double precision, out skewx double precision, out skewy double precision, out srid integer, out numbands integer) returns record
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_metadata(raster, out double precision, out double precision, out integer, out integer, out double precision, out double precision, out double precision, out double precision, out integer, out integer) is 'args: rast - Returns basic meta data about a raster object such as pixel size, rotation (skew), upper, lower left, etc.';

alter function st_metadata(raster, out double precision, out double precision, out integer, out integer, out double precision, out double precision, out double precision, out double precision, out integer, out integer) owner to postgres;

create function st_summary(rast raster) returns text
    stable
    strict
    language plpgsql
as
$$
DECLARE
extent box2d;
		metadata record;
		bandmetadata record;
		msg text;
		msgset text[];
BEGIN
		extent := public.ST_Extent(rast::geometry);
		metadata := public.ST_Metadata(rast);

		msg := 'Raster of ' || metadata.width || 'x' || metadata.height || ' pixels has ' || metadata.numbands || ' ';

		IF metadata.numbands = 1 THEN
			msg := msg || 'band ';
ELSE
			msg := msg || 'bands ';
END IF;
		msg := msg || 'and extent of ' || extent;

		IF
round(metadata.skewx::numeric, 10) <> round(0::numeric, 10) OR
			round(metadata.skewy::numeric, 10) <> round(0::numeric, 10)
		THEN
			msg := 'Skewed ' || overlay(msg placing 'r' from 1 for 1);
END IF;

		msgset := Array[]::text[] || msg;

FOR bandmetadata IN SELECT * FROM public.ST_BandMetadata(rast, ARRAY[]::int[]) LOOP
    msg := 'band ' || bandmetadata.bandnum || ' of pixtype ' || bandmetadata.pixeltype || ' is ';
IF bandmetadata.isoutdb IS FALSE THEN
				msg := msg || 'in-db ';
ELSE
				msg := msg || 'out-db ';
END IF;

			msg := msg || 'with ';
			IF bandmetadata.nodatavalue IS NOT NULL THEN
				msg := msg || 'NODATA value of ' || bandmetadata.nodatavalue;
ELSE
				msg := msg || 'no NODATA value';
END IF;

			msgset := msgset || ('    ' || msg);
END LOOP;

RETURN array_to_string(msgset, E'\n');
END;
	$$;

comment on function st_summary(raster) is 'args: rast - Returns a text summary of the contents of the raster.';

alter function st_summary(raster) owner to postgres;

create function st_memsize(raster) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_memsize(raster) is 'args: rast - Returns the amount of space (in bytes) the raster takes.';

alter function st_memsize(raster) owner to postgres;

create function st_makeemptyraster(width integer, height integer, upperleftx double precision, upperlefty double precision, scalex double precision, scaley double precision, skewx double precision, skewy double precision, srid integer default 0) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_makeemptyraster(integer, integer, double precision, double precision, double precision, double precision, double precision, double precision, integer) is 'args: width, height, upperleftx, upperlefty, scalex, scaley, skewx, skewy, srid=unknown - Returns an empty raster (having no bands) of given dimensions (width & height), upperleft X and Y, pixel size and rotation (scalex, scaley, skewx & skewy) and reference system (srid). If a raster is passed in, returns a new raster with the same size, alignment and SRID. If srid is left out, the spatial ref is set to unknown (0).';

alter function st_makeemptyraster(integer, integer, double precision, double precision, double precision, double precision, double precision, double precision, integer) owner to postgres;

create function st_makeemptyraster(width integer, height integer, upperleftx double precision, upperlefty double precision, pixelsize double precision) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT  public.ST_makeemptyraster($1, $2, $3, $4, $5, -($5), 0, 0, public.ST_SRID('POINT(0 0)'::geometry)) $$;

comment on function st_makeemptyraster(integer, integer, double precision, double precision, double precision) is 'args: width, height, upperleftx, upperlefty, pixelsize - Returns an empty raster (having no bands) of given dimensions (width & height), upperleft X and Y, pixel size and rotation (scalex, scaley, skewx & skewy) and reference system (srid). If a raster is passed in, returns a new raster with the same size, alignment and SRID. If srid is left out, the spatial ref is set to unknown (0).';

alter function st_makeemptyraster(integer, integer, double precision, double precision, double precision) owner to postgres;

create function st_makeemptyraster(rast raster) returns raster
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
w int;
			h int;
			ul_x double precision;
			ul_y double precision;
			scale_x double precision;
			scale_y double precision;
			skew_x double precision;
			skew_y double precision;
			sr_id int;
BEGIN
SELECT width, height, upperleftx, upperlefty, scalex, scaley, skewx, skewy, srid INTO w, h, ul_x, ul_y, scale_x, scale_y, skew_x, skew_y, sr_id FROM public.ST_Metadata(rast);
RETURN  public.ST_makeemptyraster(w, h, ul_x, ul_y, scale_x, scale_y, skew_x, skew_y, sr_id);
END;
    $$;

comment on function st_makeemptyraster(raster) is 'args: rast - Returns an empty raster (having no bands) of given dimensions (width & height), upperleft X and Y, pixel size and rotation (scalex, scaley, skewx & skewy) and reference system (srid). If a raster is passed in, returns a new raster with the same size, alignment and SRID. If srid is left out, the spatial ref is set to unknown (0).';

alter function st_makeemptyraster(raster) owner to postgres;

create function st_addband(rast raster, addbandargset addbandarg[]) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_addband(raster, addbandarg[]) is 'args: rast, addbandargset - Returns a raster with the new band(s) of given type added with given initial value in the given index location. If no index is specified, the band is added to the end.';

alter function st_addband(raster, addbandarg[]) owner to postgres;

create function st_addband(rast raster, index integer, pixeltype text, initialvalue double precision DEFAULT '0'::numeric, nodataval double precision DEFAULT NULL::double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT  public.ST_addband($1, ARRAY[ROW($2, $3, $4, $5)]::addbandarg[]) $$;

comment on function st_addband(raster, integer, text, double precision, double precision) is 'args: rast, index, pixeltype, initialvalue=0, nodataval=NULL - Returns a raster with the new band(s) of given type added with given initial value in the given index location. If no index is specified, the band is added to the end.';

alter function st_addband(raster, integer, text, double precision, double precision) owner to postgres;

create function st_addband(rast raster, pixeltype text, initialvalue double precision DEFAULT '0'::numeric, nodataval double precision DEFAULT NULL::double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT  public.ST_addband($1, ARRAY[ROW(NULL, $2, $3, $4)]::addbandarg[]) $$;

comment on function st_addband(raster, text, double precision, double precision) is 'args: rast, pixeltype, initialvalue=0, nodataval=NULL - Returns a raster with the new band(s) of given type added with given initial value in the given index location. If no index is specified, the band is added to the end.';

alter function st_addband(raster, text, double precision, double precision) owner to postgres;

create function st_addband(torast raster, fromrast raster, fromband integer default 1, torastindex integer default NULL::integer) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_addband(raster, raster, integer, integer) is 'args: torast, fromrast, fromband=1, torastindex=at_end - Returns a raster with the new band(s) of given type added with given initial value in the given index location. If no index is specified, the band is added to the end.';

alter function st_addband(raster, raster, integer, integer) owner to postgres;

create function st_addband(torast raster, fromrasts raster[], fromband integer default 1, torastindex integer default NULL::integer) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_addband(raster, raster[], integer, integer) is 'args: torast, fromrasts, fromband=1, torastindex=at_end - Returns a raster with the new band(s) of given type added with given initial value in the given index location. If no index is specified, the band is added to the end.';

alter function st_addband(raster, raster[], integer, integer) owner to postgres;

create function st_addband(rast raster, index integer, outdbfile text, outdbindex integer[], nodataval double precision default NULL::double precision) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_addband(raster, integer, text, integer[], double precision) is 'args: rast, index, outdbfile, outdbindex, nodataval=NULL - Returns a raster with the new band(s) of given type added with given initial value in the given index location. If no index is specified, the band is added to the end.';

alter function st_addband(raster, integer, text, integer[], double precision) owner to postgres;

create function st_addband(rast raster, outdbfile text, outdbindex integer[], index integer DEFAULT NULL::integer, nodataval double precision DEFAULT NULL::double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_AddBand($1, $4, $2, $3, $5) $$;

comment on function st_addband(raster, text, integer[], integer, double precision) is 'args: rast, outdbfile, outdbindex, index=at_end, nodataval=NULL - Returns a raster with the new band(s) of given type added with given initial value in the given index location. If no index is specified, the band is added to the end.';

alter function st_addband(raster, text, integer[], integer, double precision) owner to postgres;

create function st_band(rast raster, nbands integer[] default ARRAY[1]) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_band(raster, integer[]) is 'args: rast, nbands = ARRAY[1] - Returns one or more bands of an existing raster as a new raster. Useful for building new rasters from existing rasters.';

alter function st_band(raster, integer[]) owner to postgres;

create function st_band(rast raster, nband integer) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT  public.ST_band($1, ARRAY[$2]) $$;

comment on function st_band(raster, integer) is 'args: rast, nband - Returns one or more bands of an existing raster as a new raster. Useful for building new rasters from existing rasters.';

alter function st_band(raster, integer) owner to postgres;

create function st_band(rast raster, nbands text, delimiter character DEFAULT ','::bpchar) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT  public.ST_band($1, regexp_split_to_array(regexp_replace($2, '[[:space:]]', '', 'g'), E'\\' || array_to_string(regexp_split_to_array($3, ''), E'\\'))::int[]) $$;

comment on function st_band(raster, text, char) is 'args: rast, nbands, delimiter=, - Returns one or more bands of an existing raster as a new raster. Useful for building new rasters from existing rasters.';

alter function st_band(raster, text, char) owner to postgres;

create function _st_summarystats(rast raster, nband integer default 1, exclude_nodata_value boolean default true, sample_percent double precision default 1) returns summarystats
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_summarystats(raster, integer, boolean, double precision) owner to postgres;

create function st_summarystats(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true) returns summarystats
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_summarystats($1, $2, $3, 1) $$;

comment on function st_summarystats(raster, integer, boolean) is 'args: rast, nband, exclude_nodata_value - Returns summarystats consisting of count, sum, mean, stddev, min, max for a given raster band of a raster or raster coverage. Band 1 is assumed is no band is specified.';

alter function st_summarystats(raster, integer, boolean) owner to postgres;

create function st_summarystats(rast raster, exclude_nodata_value boolean) returns summarystats
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_summarystats($1, 1, $2, 1) $$;

comment on function st_summarystats(raster, boolean) is 'args: rast, exclude_nodata_value - Returns summarystats consisting of count, sum, mean, stddev, min, max for a given raster band of a raster or raster coverage. Band 1 is assumed is no band is specified.';

alter function st_summarystats(raster, boolean) owner to postgres;

create function st_approxsummarystats(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1) returns summarystats
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_summarystats($1, $2, $3, $4) $$;

alter function st_approxsummarystats(raster, integer, boolean, double precision) owner to postgres;

create function st_approxsummarystats(rast raster, nband integer, sample_percent double precision) returns summarystats
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_summarystats($1, $2, TRUE, $3) $$;

alter function st_approxsummarystats(raster, integer, double precision) owner to postgres;

create function st_approxsummarystats(rast raster, exclude_nodata_value boolean, sample_percent double precision DEFAULT 0.1) returns summarystats
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_summarystats($1, 1, $2, $3) $$;

alter function st_approxsummarystats(raster, boolean, double precision) owner to postgres;

create function st_approxsummarystats(rast raster, sample_percent double precision) returns summarystats
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_summarystats($1, 1, TRUE, $2) $$;

alter function st_approxsummarystats(raster, double precision) owner to postgres;

create function _st_summarystats_finalfn(internal) returns summarystats
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_summarystats_finalfn(internal) owner to postgres;

create function _st_summarystats_transfn(internal, raster, integer, boolean, double precision) returns internal
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_summarystats_transfn(internal, raster, integer, boolean, double precision) owner to postgres;

create function _st_summarystats_transfn(internal, raster, boolean, double precision) returns internal
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_summarystats_transfn(internal, raster, boolean, double precision) owner to postgres;

create function _st_summarystats_transfn(internal, raster, integer, boolean) returns internal
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_summarystats_transfn(internal, raster, integer, boolean) owner to postgres;

create function _st_count(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1) returns bigint
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
rtn bigint;
BEGIN
		IF exclude_nodata_value IS FALSE THEN
SELECT width * height INTO rtn FROM public.ST_Metadata(rast);
ELSE
SELECT count INTO rtn FROM public._ST_summarystats($1, $2, $3, $4);
END IF;

RETURN rtn;
END;
	$$;

alter function _st_count(raster, integer, boolean, double precision) owner to postgres;

create function st_count(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true) returns bigint
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_count($1, $2, $3, 1) $$;

comment on function st_count(raster, integer, boolean) is 'args: rast, nband=1, exclude_nodata_value=true - Returns the number of pixels in a given band of a raster or raster coverage. If no band is specified defaults to band 1. If exclude_nodata_value is set to true, will only count pixels that are not equal to the nodata value.';

alter function st_count(raster, integer, boolean) owner to postgres;

create function st_count(rast raster, exclude_nodata_value boolean) returns bigint
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_count($1, 1, $2, 1) $$;

comment on function st_count(raster, boolean) is 'args: rast, exclude_nodata_value - Returns the number of pixels in a given band of a raster or raster coverage. If no band is specified defaults to band 1. If exclude_nodata_value is set to true, will only count pixels that are not equal to the nodata value.';

alter function st_count(raster, boolean) owner to postgres;

create function st_approxcount(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1) returns bigint
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_count($1, $2, $3, $4) $$;

alter function st_approxcount(raster, integer, boolean, double precision) owner to postgres;

create function st_approxcount(rast raster, nband integer, sample_percent double precision) returns bigint
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_count($1, $2, TRUE, $3) $$;

alter function st_approxcount(raster, integer, double precision) owner to postgres;

create function st_approxcount(rast raster, exclude_nodata_value boolean, sample_percent double precision DEFAULT 0.1) returns bigint
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_count($1, 1, $2, $3) $$;

alter function st_approxcount(raster, boolean, double precision) owner to postgres;

create function st_approxcount(rast raster, sample_percent double precision) returns bigint
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_count($1, 1, TRUE, $2) $$;

alter function st_approxcount(raster, double precision) owner to postgres;

create function _st_countagg_finalfn(agg agg_count) returns bigint
    immutable
    parallel safe
    language plpgsql
as
$$
BEGIN
		IF agg IS NULL THEN
			RAISE EXCEPTION 'Cannot count coverage';
END IF;

RETURN agg.count;
END;
	$$;

alter function _st_countagg_finalfn(agg_count) owner to postgres;

create function __st_countagg_transfn(agg agg_count, rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1) returns agg_count
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_count bigint;
		rtn_agg agg_count;
BEGIN

		-- only process parameter args once
		IF agg IS NULL THEN
			rtn_agg.count := 0;

			IF nband < 1 THEN
				RAISE EXCEPTION 'Band index must be greater than zero (1-based)';
ELSE
				rtn_agg.nband := nband;
END IF;

			IF exclude_nodata_value IS FALSE THEN
				rtn_agg.exclude_nodata_value := FALSE;
ELSE
				rtn_agg.exclude_nodata_value := TRUE;
END IF;

			IF sample_percent < 0. OR sample_percent > 1. THEN
				RAISE EXCEPTION 'Sample percent must be between zero and one';
ELSE
				rtn_agg.sample_percent := sample_percent;
END IF;
ELSE
			rtn_agg := agg;
END IF;

		IF rast IS NOT NULL THEN
			IF rtn_agg.exclude_nodata_value IS FALSE THEN
SELECT width * height INTO _count FROM public.ST_Metadata(rast);
ELSE
SELECT count INTO _count FROM public._ST_summarystats(
    rast,
    rtn_agg.nband, rtn_agg.exclude_nodata_value,
    rtn_agg.sample_percent
    );
END IF;
END IF;

		rtn_agg.count := rtn_agg.count + _count;
RETURN rtn_agg;
END;
	$$;

alter function __st_countagg_transfn(agg_count, raster, integer, boolean, double precision) owner to postgres;

create function _st_countagg_transfn(agg agg_count, rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision) returns agg_count
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
rtn_agg agg_count;
BEGIN
		rtn_agg :=  public.__st_countagg_transfn(
			agg,
			rast,
			nband, exclude_nodata_value,
			sample_percent
		);
RETURN rtn_agg;
END;
	$$;

alter function _st_countagg_transfn(agg_count, raster, integer, boolean, double precision) owner to postgres;

create function _st_countagg_transfn(agg agg_count, rast raster, nband integer, exclude_nodata_value boolean) returns agg_count
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
rtn_agg agg_count;
BEGIN
		rtn_agg :=  public.__ST_countagg_transfn(
			agg,
			rast,
			nband, exclude_nodata_value,
			1
		);
RETURN rtn_agg;
END;
	$$;

alter function _st_countagg_transfn(agg_count, raster, integer, boolean) owner to postgres;

create function _st_countagg_transfn(agg agg_count, rast raster, exclude_nodata_value boolean) returns agg_count
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
rtn_agg agg_count;
BEGIN
		rtn_agg :=  public.__ST_countagg_transfn(
			agg,
			rast,
			1, exclude_nodata_value,
			1
		);
RETURN rtn_agg;
END;
	$$;

alter function _st_countagg_transfn(agg_count, raster, boolean) owner to postgres;

create function _st_histogram(rast raster, nband integer default 1, exclude_nodata_value boolean default true, sample_percent double precision default 1, bins integer default 0, width double precision[] default NULL::double precision[], "right" boolean default false, min double precision default NULL::double precision, max double precision default NULL::double precision, out min double precision, out max double precision, out count bigint, out percent double precision) returns setof setof record
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;

$$;

alter function _st_histogram(raster, integer, boolean, double precision, integer, double precision[], boolean, double precision, double precision, out double precision, out double precision, out bigint, out double precision) owner to postgres;

create function st_histogram(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, bins integer DEFAULT 0, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT min, max, count, percent FROM public._ST_histogram($1, $2, $3, 1, $4, $5, $6) $$;

comment on function st_histogram(raster, integer, boolean, integer, double precision[], boolean, out double precision, out double precision, out bigint, out double precision) is 'args: rast, nband=1, exclude_nodata_value=true, bins=autocomputed, width=NULL, right=false - Returns a set of record summarizing a raster or raster coverage data distribution separate bin ranges. Number of bins are autocomputed if not specified.';

alter function st_histogram(raster, integer, boolean, integer, double precision[], boolean, out double precision, out double precision, out bigint, out double precision) owner to postgres;

create function st_histogram(rast raster, nband integer, exclude_nodata_value boolean, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT min, max, count, percent FROM public._ST_histogram($1, $2, $3, 1, $4, NULL, $5) $$;

comment on function st_histogram(raster, integer, boolean, integer, boolean, out double precision, out double precision, out bigint, out double precision) is 'args: rast, nband, exclude_nodata_value, bins, right - Returns a set of record summarizing a raster or raster coverage data distribution separate bin ranges. Number of bins are autocomputed if not specified.';

alter function st_histogram(raster, integer, boolean, integer, boolean, out double precision, out double precision, out bigint, out double precision) owner to postgres;

create function st_histogram(rast raster, nband integer, bins integer, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT min, max, count, percent FROM public._ST_histogram($1, $2, TRUE, 1, $3, $4, $5) $$;

comment on function st_histogram(raster, integer, integer, double precision[], boolean, out double precision, out double precision, out bigint, out double precision) is 'args: rast, nband, bins, width=NULL, right=false - Returns a set of record summarizing a raster or raster coverage data distribution separate bin ranges. Number of bins are autocomputed if not specified.';

alter function st_histogram(raster, integer, integer, double precision[], boolean, out double precision, out double precision, out bigint, out double precision) owner to postgres;

create function st_histogram(rast raster, nband integer, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT min, max, count, percent FROM public._ST_histogram($1, $2, TRUE, 1, $3, NULL, $4) $$;

comment on function st_histogram(raster, integer, integer, boolean, out double precision, out double precision, out bigint, out double precision) is 'args: rast, nband, bins, right - Returns a set of record summarizing a raster or raster coverage data distribution separate bin ranges. Number of bins are autocomputed if not specified.';

alter function st_histogram(raster, integer, integer, boolean, out double precision, out double precision, out bigint, out double precision) owner to postgres;

create function st_approxhistogram(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1, bins integer DEFAULT 0, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT min, max, count, percent FROM public._ST_histogram($1, $2, $3, $4, $5, $6, $7) $$;

alter function st_approxhistogram(raster, integer, boolean, double precision, integer, double precision[], boolean, out double precision, out double precision, out bigint, out double precision) owner to postgres;

create function st_approxhistogram(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT min, max, count, percent FROM public._ST_histogram($1, $2, $3, $4, $5, NULL, $6) $$;

alter function st_approxhistogram(raster, integer, boolean, double precision, integer, boolean, out double precision, out double precision, out bigint, out double precision) owner to postgres;

create function st_approxhistogram(rast raster, nband integer, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT min, max, count, percent FROM public._ST_histogram($1, $2, TRUE, $3, 0, NULL, FALSE) $$;

alter function st_approxhistogram(raster, integer, double precision, out double precision, out double precision, out bigint, out double precision) owner to postgres;

create function st_approxhistogram(rast raster, sample_percent double precision, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT min, max, count, percent FROM public._ST_histogram($1, 1, TRUE, $2, 0, NULL, FALSE) $$;

alter function st_approxhistogram(raster, double precision, out double precision, out double precision, out bigint, out double precision) owner to postgres;

create function st_approxhistogram(rast raster, nband integer, sample_percent double precision, bins integer, width double precision[] DEFAULT NULL::double precision[], "right" boolean DEFAULT false, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT min, max, count, percent FROM public._ST_histogram($1, $2, TRUE, $3, $4, $5, $6) $$;

alter function st_approxhistogram(raster, integer, double precision, integer, double precision[], boolean, out double precision, out double precision, out bigint, out double precision) owner to postgres;

create function st_approxhistogram(rast raster, nband integer, sample_percent double precision, bins integer, "right" boolean, OUT min double precision, OUT max double precision, OUT count bigint, OUT percent double precision) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT min, max, count, percent FROM public._ST_histogram($1, $2, TRUE, $3, $4, NULL, $5) $$;

alter function st_approxhistogram(raster, integer, double precision, integer, boolean, out double precision, out double precision, out bigint, out double precision) owner to postgres;

create function _st_quantile(rast raster, nband integer default 1, exclude_nodata_value boolean default true, sample_percent double precision default 1, quantiles double precision[] default NULL::double precision[], out quantile double precision, out value double precision) returns setof setof record
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;

$$;

alter function _st_quantile(raster, integer, boolean, double precision, double precision[], out double precision, out double precision) owner to postgres;

create function st_quantile(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_quantile($1, $2, $3, 1, $4) $$;

comment on function st_quantile(raster, integer, boolean, double precision[], out double precision, out double precision) is 'args: rast, nband=1, exclude_nodata_value=true, quantiles=NULL - Compute quantiles for a raster or raster table coverage in the context of the sample or population. Thus, a value could be examined to be at the rasters 25%, 50%, 75% percentile.';

alter function st_quantile(raster, integer, boolean, double precision[], out double precision, out double precision) owner to postgres;

create function st_quantile(rast raster, nband integer, quantiles double precision[], OUT quantile double precision, OUT value double precision) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_quantile($1, $2, TRUE, 1, $3) $$;

comment on function st_quantile(raster, integer, double precision[], out double precision, out double precision) is 'args: rast, nband, quantiles - Compute quantiles for a raster or raster table coverage in the context of the sample or population. Thus, a value could be examined to be at the rasters 25%, 50%, 75% percentile.';

alter function st_quantile(raster, integer, double precision[], out double precision, out double precision) owner to postgres;

create function st_quantile(rast raster, quantiles double precision[], OUT quantile double precision, OUT value double precision) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_quantile($1, 1, TRUE, 1, $2) $$;

comment on function st_quantile(raster, double precision[], out double precision, out double precision) is 'args: rast, quantiles - Compute quantiles for a raster or raster table coverage in the context of the sample or population. Thus, a value could be examined to be at the rasters 25%, 50%, 75% percentile.';

alter function st_quantile(raster, double precision[], out double precision, out double precision) owner to postgres;

create function st_quantile(rast raster, nband integer, exclude_nodata_value boolean, quantile double precision) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_quantile($1, $2, $3, 1, ARRAY[$4]::double precision[])).value $$;

comment on function st_quantile(raster, integer, boolean, double precision) is 'args: rast, nband, exclude_nodata_value, quantile - Compute quantiles for a raster or raster table coverage in the context of the sample or population. Thus, a value could be examined to be at the rasters 25%, 50%, 75% percentile.';

alter function st_quantile(raster, integer, boolean, double precision) owner to postgres;

create function st_quantile(rast raster, nband integer, quantile double precision) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_quantile($1, $2, TRUE, 1, ARRAY[$3]::double precision[])).value $$;

comment on function st_quantile(raster, integer, double precision) is 'args: rast, nband, quantile - Compute quantiles for a raster or raster table coverage in the context of the sample or population. Thus, a value could be examined to be at the rasters 25%, 50%, 75% percentile.';

alter function st_quantile(raster, integer, double precision) owner to postgres;

create function st_quantile(rast raster, exclude_nodata_value boolean, quantile double precision DEFAULT NULL::double precision) returns double precision
    immutable
    parallel safe
    language sql
as
$$ SELECT ( public._ST_quantile($1, 1, $2, 1, ARRAY[$3]::double precision[])).value $$;

comment on function st_quantile(raster, boolean, double precision) is 'args: rast, exclude_nodata_value, quantile=NULL - Compute quantiles for a raster or raster table coverage in the context of the sample or population. Thus, a value could be examined to be at the rasters 25%, 50%, 75% percentile.';

alter function st_quantile(raster, boolean, double precision) owner to postgres;

create function st_quantile(rast raster, quantile double precision) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_quantile($1, 1, TRUE, 1, ARRAY[$2]::double precision[])).value $$;

comment on function st_quantile(raster, double precision) is 'args: rast, quantile - Compute quantiles for a raster or raster table coverage in the context of the sample or population. Thus, a value could be examined to be at the rasters 25%, 50%, 75% percentile.';

alter function st_quantile(raster, double precision) owner to postgres;

create function st_approxquantile(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 0.1, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_quantile($1, $2, $3, $4, $5) $$;

alter function st_approxquantile(raster, integer, boolean, double precision, double precision[], out double precision, out double precision) owner to postgres;

create function st_approxquantile(rast raster, nband integer, sample_percent double precision, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_quantile($1, $2, TRUE, $3, $4) $$;

alter function st_approxquantile(raster, integer, double precision, double precision[], out double precision, out double precision) owner to postgres;

create function st_approxquantile(rast raster, sample_percent double precision, quantiles double precision[] DEFAULT NULL::double precision[], OUT quantile double precision, OUT value double precision) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_quantile($1, 1, TRUE, $2, $3) $$;

alter function st_approxquantile(raster, double precision, double precision[], out double precision, out double precision) owner to postgres;

create function st_approxquantile(rast raster, quantiles double precision[], OUT quantile double precision, OUT value double precision) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_quantile($1, 1, TRUE, 0.1, $2) $$;

alter function st_approxquantile(raster, double precision[], out double precision, out double precision) owner to postgres;

create function st_approxquantile(rast raster, nband integer, exclude_nodata_value boolean, sample_percent double precision, quantile double precision) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_quantile($1, $2, $3, $4, ARRAY[$5]::double precision[])).value $$;

alter function st_approxquantile(raster, integer, boolean, double precision, double precision) owner to postgres;

create function st_approxquantile(rast raster, nband integer, sample_percent double precision, quantile double precision) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_quantile($1, $2, TRUE, $3, ARRAY[$4]::double precision[])).value $$;

alter function st_approxquantile(raster, integer, double precision, double precision) owner to postgres;

create function st_approxquantile(rast raster, sample_percent double precision, quantile double precision) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_quantile($1, 1, TRUE, $2, ARRAY[$3]::double precision[])).value $$;

alter function st_approxquantile(raster, double precision, double precision) owner to postgres;

create function st_approxquantile(rast raster, exclude_nodata_value boolean, quantile double precision DEFAULT NULL::double precision) returns double precision
    immutable
    parallel safe
    language sql
as
$$ SELECT ( public._ST_quantile($1, 1, $2, 0.1, ARRAY[$3]::double precision[])).value $$;

alter function st_approxquantile(raster, boolean, double precision) owner to postgres;

create function st_approxquantile(rast raster, quantile double precision) returns double precision
    immutable
    parallel safe
    language sql
as
$$ SELECT ( public._ST_quantile($1, 1, TRUE, 0.1, ARRAY[$2]::double precision[])).value $$;

alter function st_approxquantile(raster, double precision) owner to postgres;

create function _st_valuecount(rast raster, nband integer default 1, exclude_nodata_value boolean default true, searchvalues double precision[] default NULL::double precision[], roundto double precision default 0, out value double precision, out count integer, out percent double precision) returns setof setof record
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;

$$;

alter function _st_valuecount(raster, integer, boolean, double precision[], double precision, out double precision, out integer, out double precision) owner to postgres;

create function st_valuecount(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT value, count FROM public._ST_valuecount($1, $2, $3, $4, $5) $$;

comment on function st_valuecount(raster, integer, boolean, double precision[], double precision, out double precision, out integer) is 'args: rast, nband=1, exclude_nodata_value=true, searchvalues=NULL, roundto=0, OUT value, OUT count - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(raster, integer, boolean, double precision[], double precision, out double precision, out integer) owner to postgres;

create function st_valuecount(rast raster, nband integer, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT value, count FROM public._ST_valuecount($1, $2, TRUE, $3, $4) $$;

comment on function st_valuecount(raster, integer, double precision[], double precision, out double precision, out integer) is 'args: rast, nband, searchvalues, roundto=0, OUT value, OUT count - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(raster, integer, double precision[], double precision, out double precision, out integer) owner to postgres;

create function st_valuecount(rast raster, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT value, count FROM public._ST_valuecount($1, 1, TRUE, $2, $3) $$;

comment on function st_valuecount(raster, double precision[], double precision, out double precision, out integer) is 'args: rast, searchvalues, roundto=0, OUT value, OUT count - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(raster, double precision[], double precision, out double precision, out integer) owner to postgres;

create function st_valuecount(rast raster, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision DEFAULT 0) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_valuecount($1, $2, $3, ARRAY[$4]::double precision[], $5)).count $$;

comment on function st_valuecount(raster, integer, boolean, double precision, double precision) is 'args: rast, nband, exclude_nodata_value, searchvalue, roundto=0 - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(raster, integer, boolean, double precision, double precision) owner to postgres;

create function st_valuecount(rast raster, nband integer, searchvalue double precision, roundto double precision DEFAULT 0) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_valuecount($1, $2, TRUE, ARRAY[$3]::double precision[], $4)).count $$;

comment on function st_valuecount(raster, integer, double precision, double precision) is 'args: rast, nband, searchvalue, roundto=0 - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(raster, integer, double precision, double precision) owner to postgres;

create function st_valuecount(rast raster, searchvalue double precision, roundto double precision DEFAULT 0) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_valuecount($1, 1, TRUE, ARRAY[$2]::double precision[], $3)).count $$;

comment on function st_valuecount(raster, double precision, double precision) is 'args: rast, searchvalue, roundto=0 - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(raster, double precision, double precision) owner to postgres;

create function st_valuepercent(rast raster, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT value, percent FROM public._ST_valuecount($1, $2, $3, $4, $5) $$;

alter function st_valuepercent(raster, integer, boolean, double precision[], double precision, out double precision, out double precision) owner to postgres;

create function st_valuepercent(rast raster, nband integer, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT value, percent FROM public._ST_valuecount($1, $2, TRUE, $3, $4) $$;

alter function st_valuepercent(raster, integer, double precision[], double precision, out double precision, out double precision) owner to postgres;

create function st_valuepercent(rast raster, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) returns SETOF record
    immutable
    parallel safe
    language sql
as
$$ SELECT value, percent FROM public._ST_valuecount($1, 1, TRUE, $2, $3) $$;

alter function st_valuepercent(raster, double precision[], double precision, out double precision, out double precision) owner to postgres;

create function st_valuepercent(rast raster, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision DEFAULT 0) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_valuecount($1, $2, $3, ARRAY[$4]::double precision[], $5)).percent $$;

alter function st_valuepercent(raster, integer, boolean, double precision, double precision) owner to postgres;

create function st_valuepercent(rast raster, nband integer, searchvalue double precision, roundto double precision DEFAULT 0) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_valuecount($1, $2, TRUE, ARRAY[$3]::double precision[], $4)).percent $$;

alter function st_valuepercent(raster, integer, double precision, double precision) owner to postgres;

create function st_valuepercent(rast raster, searchvalue double precision, roundto double precision DEFAULT 0) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ( public._ST_valuecount($1, 1, TRUE, ARRAY[$2]::double precision[], $3)).percent $$;

alter function st_valuepercent(raster, double precision, double precision) owner to postgres;

create function _st_valuecount(rastertable text, rastercolumn text, nband integer default 1, exclude_nodata_value boolean default true, searchvalues double precision[] default NULL::double precision[], roundto double precision default 0, out value double precision, out count integer, out percent double precision) returns setof setof record
    stable
    language c
as
$$
begin
-- missing source code
end;

$$;

alter function _st_valuecount(text, text, integer, boolean, double precision[], double precision, out double precision, out integer, out double precision) owner to postgres;

create function st_valuecount(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) returns SETOF record
    stable
    language sql
as
$$ SELECT value, count FROM public._ST_valuecount($1, $2, $3, $4, $5, $6) $$;

comment on function st_valuecount(text, text, integer, boolean, double precision[], double precision, out double precision, out integer) is 'args: rastertable, rastercolumn, nband=1, exclude_nodata_value=true, searchvalues=NULL, roundto=0, OUT value, OUT count - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(text, text, integer, boolean, double precision[], double precision, out double precision, out integer) owner to postgres;

create function st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) returns SETOF record
    stable
    language sql
as
$$ SELECT value, count FROM public._ST_valuecount($1, $2, $3, TRUE, $4, $5) $$;

comment on function st_valuecount(text, text, integer, double precision[], double precision, out double precision, out integer) is 'args: rastertable, rastercolumn, nband, searchvalues, roundto=0, OUT value, OUT count - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(text, text, integer, double precision[], double precision, out double precision, out integer) owner to postgres;

create function st_valuecount(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT count integer) returns SETOF record
    stable
    language sql
as
$$ SELECT value, count FROM public._ST_valuecount($1, $2, 1, TRUE, $3, $4) $$;

comment on function st_valuecount(text, text, double precision[], double precision, out double precision, out integer) is 'args: rastertable, rastercolumn, searchvalues, roundto=0, OUT value, OUT count - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(text, text, double precision[], double precision, out double precision, out integer) owner to postgres;

create function st_valuecount(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision DEFAULT 0) returns integer
    stable
    strict
    language sql
as
$$ SELECT ( public._ST_valuecount($1, $2, $3, $4, ARRAY[$5]::double precision[], $6)).count $$;

comment on function st_valuecount(text, text, integer, boolean, double precision, double precision) is 'args: rastertable, rastercolumn, nband, exclude_nodata_value, searchvalue, roundto=0 - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(text, text, integer, boolean, double precision, double precision) owner to postgres;

create function st_valuecount(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision DEFAULT 0) returns integer
    stable
    strict
    language sql
as
$$ SELECT ( public._ST_valuecount($1, $2, $3, TRUE, ARRAY[$4]::double precision[], $5)).count $$;

comment on function st_valuecount(text, text, integer, double precision, double precision) is 'args: rastertable, rastercolumn, nband, searchvalue, roundto=0 - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(text, text, integer, double precision, double precision) owner to postgres;

create function st_valuecount(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision DEFAULT 0) returns integer
    stable
    strict
    language sql
as
$$ SELECT ( public._ST_valuecount($1, $2, 1, TRUE, ARRAY[$3]::double precision[], $4)).count $$;

comment on function st_valuecount(text, text, double precision, double precision) is 'args: rastertable, rastercolumn, searchvalue, roundto=0 - Returns a set of records containing a pixel band value and count of the number of pixels in a given band of a raster (or a raster coverage) that have a given set of values. If no band is specified defaults to band 1. By default nodata value pixels are not counted. and all other values in the pixel are output and pixel band values are rounded to the nearest integer.';

alter function st_valuecount(text, text, double precision, double precision) owner to postgres;

create function st_valuepercent(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, searchvalues double precision[] DEFAULT NULL::double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) returns SETOF record
    stable
    language sql
as
$$ SELECT value, percent FROM public._ST_valuecount($1, $2, $3, $4, $5, $6) $$;

alter function st_valuepercent(text, text, integer, boolean, double precision[], double precision, out double precision, out double precision) owner to postgres;

create function st_valuepercent(rastertable text, rastercolumn text, nband integer, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) returns SETOF record
    stable
    language sql
as
$$ SELECT value, percent FROM public._ST_valuecount($1, $2, $3, TRUE, $4, $5) $$;

alter function st_valuepercent(text, text, integer, double precision[], double precision, out double precision, out double precision) owner to postgres;

create function st_valuepercent(rastertable text, rastercolumn text, searchvalues double precision[], roundto double precision DEFAULT 0, OUT value double precision, OUT percent double precision) returns SETOF record
    stable
    language sql
as
$$ SELECT value, percent FROM public._ST_valuecount($1, $2, 1, TRUE, $3, $4) $$;

alter function st_valuepercent(text, text, double precision[], double precision, out double precision, out double precision) owner to postgres;

create function st_valuepercent(rastertable text, rastercolumn text, nband integer, exclude_nodata_value boolean, searchvalue double precision, roundto double precision DEFAULT 0) returns double precision
    stable
    strict
    language sql
as
$$ SELECT ( public._ST_valuecount($1, $2, $3, $4, ARRAY[$5]::double precision[], $6)).percent $$;

alter function st_valuepercent(text, text, integer, boolean, double precision, double precision) owner to postgres;

create function st_valuepercent(rastertable text, rastercolumn text, nband integer, searchvalue double precision, roundto double precision DEFAULT 0) returns double precision
    stable
    strict
    language sql
as
$$ SELECT ( public._ST_valuecount($1, $2, $3, TRUE, ARRAY[$4]::double precision[], $5)).percent $$;

alter function st_valuepercent(text, text, integer, double precision, double precision) owner to postgres;

create function st_valuepercent(rastertable text, rastercolumn text, searchvalue double precision, roundto double precision DEFAULT 0) returns double precision
    stable
    strict
    language sql
as
$$ SELECT ( public._ST_valuecount($1, $2, 1, TRUE, ARRAY[$3]::double precision[], $4)).percent $$;

alter function st_valuepercent(text, text, double precision, double precision) owner to postgres;

create function _st_reclass(rast raster, reclassargset reclassarg[]) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_reclass(raster, reclassarg[]) owner to postgres;

create function st_reclass(rast raster, VARIADIC reclassargset reclassarg[]) returns raster
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
i int;
		expr text;
BEGIN
		-- for each reclassarg, validate elements as all except nodataval cannot be NULL
FOR i IN SELECT * FROM generate_subscripts($2, 1) LOOP
    IF $2[i].nband IS NULL OR $2[i].reclassexpr IS NULL OR $2[i].pixeltype IS NULL THEN
				RAISE WARNING 'Values are required for the nband, reclassexpr and pixeltype attributes.';
RETURN rast;
END IF;
END LOOP;

RETURN public._ST_reclass($1, VARIADIC $2);
END;
	$$;

comment on function st_reclass(raster, reclassarg[]) is 'args: rast, VARIADIC reclassargset - Creates a new raster composed of band types reclassified from original. The nband is the band to be changed. If nband is not specified assumed to be 1. All other bands are returned unchanged. Use case: convert a 16BUI band to a 8BUI and so forth for simpler rendering as viewable formats.';

alter function st_reclass(raster, reclassarg[]) owner to postgres;

create function st_reclass(rast raster, nband integer, reclassexpr text, pixeltype text, nodataval double precision DEFAULT NULL::double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT st_reclass($1, ROW($2, $3, $4, $5)) $$;

comment on function st_reclass(raster, integer, text, text, double precision) is 'args: rast, nband, reclassexpr, pixeltype, nodataval=NULL - Creates a new raster composed of band types reclassified from original. The nband is the band to be changed. If nband is not specified assumed to be 1. All other bands are returned unchanged. Use case: convert a 16BUI band to a 8BUI and so forth for simpler rendering as viewable formats.';

alter function st_reclass(raster, integer, text, text, double precision) owner to postgres;

create function st_reclass(rast raster, reclassexpr text, pixeltype text) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT st_reclass($1, ROW(1, $2, $3, NULL)) $$;

comment on function st_reclass(raster, text, text) is 'args: rast, reclassexpr, pixeltype - Creates a new raster composed of band types reclassified from original. The nband is the band to be changed. If nband is not specified assumed to be 1. All other bands are returned unchanged. Use case: convert a 16BUI band to a 8BUI and so forth for simpler rendering as viewable formats.';

alter function st_reclass(raster, text, text) owner to postgres;

create function _st_colormap(rast raster, nband integer, colormap text, method text default 'INTERPOLATE'::text) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_colormap(raster, integer, text, text) owner to postgres;

create function st_colormap(rast raster, nband integer DEFAULT 1, colormap text DEFAULT 'grayscale'::text, method text DEFAULT 'INTERPOLATE'::text) returns raster
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
_ismap boolean;
		_colormap text;
		_element text[];
BEGIN
_ismap := TRUE;

		-- clean colormap to see what it is
_colormap := split_part(colormap, E'\n', 1);
_colormap := regexp_replace(_colormap, E':+', ' ', 'g');
_colormap := regexp_replace(_colormap, E',+', ' ', 'g');
_colormap := regexp_replace(_colormap, E'\\t+', ' ', 'g');
_colormap := regexp_replace(_colormap, E' +', ' ', 'g');
_element := regexp_split_to_array(_colormap, ' ');

		-- treat as colormap
		IF (array_length(_element, 1) > 1) THEN
			_colormap := colormap;
		-- treat as keyword
ELSE
			method := 'INTERPOLATE';
CASE lower(trim(both from _colormap))
				WHEN 'grayscale', 'greyscale' THEN
					_colormap := '
100%   0
  0% 254
  nv 255
					';
WHEN 'pseudocolor' THEN
					_colormap := '
100% 255   0   0 255
 50%   0 255   0 255
  0%   0   0 255 255
  nv   0   0   0   0
					';
WHEN 'fire' THEN
					_colormap := '
  100% 243 255 221 255
93.75% 242 255 178 255
 87.5% 255 255 135 255
81.25% 255 228  96 255
   75% 255 187  53 255
68.75% 255 131   7 255
 62.5% 255  84   0 255
56.25% 255  42   0 255
   50% 255   0   0 255
43.75% 255  42   0 255
 37.5% 224  74   0 255
31.25% 183  91   0 255
   25% 140  93   0 255
18.75%  99  82   0 255
 12.5%  58  58   1 255
 6.25%  12  15   0 255
    0%   0   0   0 255
    nv   0   0   0   0
					';
WHEN 'bluered' THEN
					_colormap := '
100.00% 165   0  33 255
 94.12% 216  21  47 255
 88.24% 247  39  53 255
 82.35% 255  61  61 255
 76.47% 255 120  86 255
 70.59% 255 172 117 255
 64.71% 255 214 153 255
 58.82% 255 241 188 255
 52.94% 255 255 234 255
 47.06% 234 255 255 255
 41.18% 188 249 255 255
 35.29% 153 234 255 255
 29.41% 117 211 255 255
 23.53%  86 176 255 255
 17.65%  61 135 255 255
 11.76%  40  87 255 255
  5.88%  24  28 247 255
  0.00%  36   0 216 255
     nv   0   0   0   0
					';
ELSE
					RAISE EXCEPTION 'Unknown colormap keyword: %', colormap;
END CASE;
END IF;

RETURN public._ST_colormap($1, $2, _colormap, $4);
END;
	$$;

comment on function st_colormap(raster, integer, text, text) is 'args: rast, nband=1, colormap=grayscale, method=INTERPOLATE - Creates a new raster of up to four 8BUI bands (grayscale, RGB, RGBA) from the source raster and a specified band. Band 1 is assumed if not specified.';

alter function st_colormap(raster, integer, text, text) owner to postgres;

create function st_colormap(rast raster, colormap text, method text DEFAULT 'INTERPOLATE'::text) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_ColorMap($1, 1, $2, $3) $$;

comment on function st_colormap(raster, text, text) is 'args: rast, colormap, method=INTERPOLATE - Creates a new raster of up to four 8BUI bands (grayscale, RGB, RGBA) from the source raster and a specified band. Band 1 is assumed if not specified.';

alter function st_colormap(raster, text, text) owner to postgres;

create function st_fromgdalraster(gdaldata bytea, srid integer default NULL::integer) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_fromgdalraster(bytea, integer) is 'args: gdaldata, srid=NULL - Returns a raster from a supported GDAL raster file.';

alter function st_fromgdalraster(bytea, integer) owner to postgres;

create function st_gdaldrivers(out idx integer, out short_name text, out long_name text, out can_read boolean, out can_write boolean, out create_options text) returns setof setof record
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_gdaldrivers(out integer, out text, out text, out boolean, out boolean, out text) is 'args: OUT idx, OUT short_name, OUT long_name, OUT can_read, OUT can_write, OUT create_options - Returns a list of raster formats supported by PostGIS through GDAL. Only those formats with can_write=True can be used by ST_AsGDALRaster';

alter function st_gdaldrivers(out integer, out text, out text, out boolean, out boolean, out text) owner to postgres;

create function st_asgdalraster(rast raster, format text, options text[] default NULL::text[], srid integer default NULL::integer) returns bytea
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_asgdalraster(raster, text, text[], integer) is 'args: rast, format, options=NULL, srid=sameassource - Return the raster tile in the designated GDAL Raster format. Raster formats are one of those supported by your compiled library. Use ST_GDALDrivers() to get a list of formats supported by your library.';

alter function st_asgdalraster(raster, text, text[], integer) owner to postgres;

create function st_contour(rast raster, bandnumber integer default 1, level_interval double precision default 100.0, level_base double precision default 0.0, fixed_levels double precision[] default ARRAY[]::double precision[], polygonize boolean default false) returns setof table("geom" geometry, "id" integer, "value" double precision)
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_contour(raster, integer, double precision, double precision, double precision[], boolean) is 'args: rast, bandnumber, level_interval, level_base, fixed_levels, polygonize - Generates a set of vector contours from the provided raster band, using the GDAL contouring algorithm.';

alter function st_contour(raster, integer, double precision, double precision, double precision[], boolean) owner to postgres;

create function st_interpolateraster(geom geometry, options text, rast raster, bandnumber integer default 1) returns raster
    immutable
    strict
    parallel safe
    cost 10000
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_interpolateraster(geometry, text, raster, integer) is 'args: input_points, algorithm_options, template, template_band_num=1 - Interpolates a gridded surface based on an input set of 3-d points, using the X- and Y-values to position the points on the grid and the Z-value of the points as the surface elevation.';

alter function st_interpolateraster(geometry, text, raster, integer) owner to postgres;

create function st_astiff(rast raster, options text[] DEFAULT NULL::text[], srid integer DEFAULT NULL::integer) returns bytea
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
i int;
		num_bands int;
		nodata double precision;
		last_nodata double precision;
BEGIN
		IF rast IS NULL THEN
			RETURN NULL;
END IF;

		num_bands := st_numbands($1);

		-- TIFF only allows one NODATA value for ALL bands
FOR i IN 1..num_bands LOOP
			nodata := st_bandnodatavalue($1, i);
			IF last_nodata IS NULL THEN
				last_nodata := nodata;
			ELSEIF nodata != last_nodata THEN
				RAISE NOTICE 'The TIFF format only permits one NODATA value for all bands.  The value used will be the last band with a NODATA value.';
END IF;
END LOOP;

RETURN st_asgdalraster($1, 'GTiff', $2, $3);
END;
	$$;

comment on function st_astiff(raster, text[], integer) is 'args: rast, options='', srid=sameassource - Return the raster selected bands as a single TIFF image (byte array). If no band is specified or any of specified bands does not exist in the raster, then will try to use all bands.';

alter function st_astiff(raster, text[], integer) owner to postgres;

create function st_astiff(rast raster, nbands integer[], options text[] DEFAULT NULL::text[], srid integer DEFAULT NULL::integer) returns bytea
    immutable
    parallel safe
    language sql
as
$$ SELECT st_astiff(st_band($1, $2), $3, $4) $$;

comment on function st_astiff(raster, integer[], text[], integer) is 'args: rast, nbands, options, srid=sameassource - Return the raster selected bands as a single TIFF image (byte array). If no band is specified or any of specified bands does not exist in the raster, then will try to use all bands.';

alter function st_astiff(raster, integer[], text[], integer) owner to postgres;

create function st_astiff(rast raster, compression text, srid integer DEFAULT NULL::integer) returns bytea
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
compression2 text;
		c_type text;
		c_level int;
		i int;
		num_bands int;
		options text[];
BEGIN
		IF rast IS NULL THEN
			RETURN NULL;
END IF;

		compression2 := trim(both from upper(compression));

		IF length(compression2) > 0 THEN
			-- JPEG
			IF position('JPEG' in compression2) != 0 THEN
				c_type := 'JPEG';
				c_level := substring(compression2 from '[0-9]+$');

				IF c_level IS NOT NULL THEN
					IF c_level > 100 THEN
						c_level := 100;
					ELSEIF c_level < 1 THEN
						c_level := 1;
END IF;

					options := array_append(options, 'JPEG_QUALITY=' || c_level);
END IF;

				-- per band pixel type check
				num_bands := st_numbands($1);
FOR i IN 1..num_bands LOOP
					IF public.ST_BandPixelType($1, i) != '8BUI' THEN
						RAISE EXCEPTION 'The pixel type of band % in the raster is not 8BUI.  JPEG compression can only be used with the 8BUI pixel type.', i;
END IF;
END LOOP;

			-- DEFLATE
			ELSEIF position('DEFLATE' in compression2) != 0 THEN
				c_type := 'DEFLATE';
				c_level := substring(compression2 from '[0-9]+$');

				IF c_level IS NOT NULL THEN
					IF c_level > 9 THEN
						c_level := 9;
					ELSEIF c_level < 1 THEN
						c_level := 1;
END IF;

					options := array_append(options, 'ZLEVEL=' || c_level);
END IF;

ELSE
				c_type := compression2;

				-- CCITT
				IF position('CCITT' in compression2) THEN
					-- per band pixel type check
					num_bands := st_numbands($1);
FOR i IN 1..num_bands LOOP
						IF public.ST_BandPixelType($1, i) != '1BB' THEN
							RAISE EXCEPTION 'The pixel type of band % in the raster is not 1BB.  CCITT compression can only be used with the 1BB pixel type.', i;
END IF;
END LOOP;
END IF;

END IF;

			-- compression type check
			IF ARRAY[c_type] <@ ARRAY['JPEG', 'LZW', 'PACKBITS', 'DEFLATE', 'CCITTRLE', 'CCITTFAX3', 'CCITTFAX4', 'NONE'] THEN
				options := array_append(options, 'COMPRESS=' || c_type);
ELSE
				RAISE NOTICE 'Unknown compression type: %.  The outputted TIFF will not be COMPRESSED.', c_type;
END IF;
END IF;

RETURN st_astiff($1, options, $3);
END;
	$$;

comment on function st_astiff(raster, text, integer) is 'args: rast, compression='', srid=sameassource - Return the raster selected bands as a single TIFF image (byte array). If no band is specified or any of specified bands does not exist in the raster, then will try to use all bands.';

alter function st_astiff(raster, text, integer) owner to postgres;

create function st_astiff(rast raster, nbands integer[], compression text, srid integer DEFAULT NULL::integer) returns bytea
    immutable
    parallel safe
    language sql
as
$$ SELECT st_astiff(st_band($1, $2), $3, $4) $$;

comment on function st_astiff(raster, integer[], text, integer) is 'args: rast, nbands, compression='', srid=sameassource - Return the raster selected bands as a single TIFF image (byte array). If no band is specified or any of specified bands does not exist in the raster, then will try to use all bands.';

alter function st_astiff(raster, integer[], text, integer) owner to postgres;

create function st_asjpeg(rast raster, options text[] DEFAULT NULL::text[]) returns bytea
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
rast2 public.raster;
		num_bands int;
		i int;
BEGIN
		IF rast IS NULL THEN
			RETURN NULL;
END IF;

		num_bands := st_numbands($1);

		-- JPEG allows 1 or 3 bands
		IF num_bands <> 1 AND num_bands <> 3 THEN
			RAISE NOTICE 'The JPEG format only permits one or three bands.  The first band will be used.';
			rast2 := st_band(rast, ARRAY[1]);
			num_bands := st_numbands(rast);
ELSE
			rast2 := rast;
END IF;

		-- JPEG only supports 8BUI pixeltype
FOR i IN 1..num_bands LOOP
			IF public.ST_BandPixelType(rast, i) != '8BUI' THEN
				RAISE EXCEPTION 'The pixel type of band % in the raster is not 8BUI.  The JPEG format can only be used with the 8BUI pixel type.', i;
END IF;
END LOOP;

RETURN st_asgdalraster(rast2, 'JPEG', $2, NULL);
END;
	$$;

comment on function st_asjpeg(raster, text[]) is 'args: rast, options=NULL - Return the raster tile selected bands as a single Joint Photographic Exports Group (JPEG) image (byte array). If no band is specified and 1 or more than 3 bands, then only the first band is used. If only 3 bands then all 3 bands are used and mapped to RGB.';

alter function st_asjpeg(raster, text[]) owner to postgres;

create function st_asjpeg(rast raster, nbands integer[], options text[] DEFAULT NULL::text[]) returns bytea
    immutable
    parallel safe
    language sql
as
$$ SELECT st_asjpeg(st_band($1, $2), $3) $$;

comment on function st_asjpeg(raster, integer[], text[]) is 'args: rast, nbands, options=NULL - Return the raster tile selected bands as a single Joint Photographic Exports Group (JPEG) image (byte array). If no band is specified and 1 or more than 3 bands, then only the first band is used. If only 3 bands then all 3 bands are used and mapped to RGB.';

alter function st_asjpeg(raster, integer[], text[]) owner to postgres;

create function st_asjpeg(rast raster, nbands integer[], quality integer) returns bytea
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
quality2 int;
		options text[];
BEGIN
		IF quality IS NOT NULL THEN
			IF quality > 100 THEN
				quality2 := 100;
			ELSEIF quality < 10 THEN
				quality2 := 10;
ELSE
				quality2 := quality;
END IF;

			options := array_append(options, 'QUALITY=' || quality2);
END IF;

RETURN public.st_asjpeg(st_band($1, $2), options);
END;
	$$;

comment on function st_asjpeg(raster, integer[], integer) is 'args: rast, nbands, quality - Return the raster tile selected bands as a single Joint Photographic Exports Group (JPEG) image (byte array). If no band is specified and 1 or more than 3 bands, then only the first band is used. If only 3 bands then all 3 bands are used and mapped to RGB.';

alter function st_asjpeg(raster, integer[], integer) owner to postgres;

create function st_asjpeg(rast raster, nband integer, options text[] DEFAULT NULL::text[]) returns bytea
    immutable
    parallel safe
    language sql
as
$$ SELECT public.st_asjpeg(st_band($1, $2), $3) $$;

comment on function st_asjpeg(raster, integer, text[]) is 'args: rast, nband, options=NULL - Return the raster tile selected bands as a single Joint Photographic Exports Group (JPEG) image (byte array). If no band is specified and 1 or more than 3 bands, then only the first band is used. If only 3 bands then all 3 bands are used and mapped to RGB.';

alter function st_asjpeg(raster, integer, text[]) owner to postgres;

create function st_asjpeg(rast raster, nband integer, quality integer) returns bytea
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.st_asjpeg($1, ARRAY[$2], $3) $$;

comment on function st_asjpeg(raster, integer, integer) is 'args: rast, nband, quality - Return the raster tile selected bands as a single Joint Photographic Exports Group (JPEG) image (byte array). If no band is specified and 1 or more than 3 bands, then only the first band is used. If only 3 bands then all 3 bands are used and mapped to RGB.';

alter function st_asjpeg(raster, integer, integer) owner to postgres;

create function st_aspng(rast raster, options text[] DEFAULT NULL::text[]) returns bytea
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
rast2 public.raster;
		num_bands int;
		i int;
		pt text;
BEGIN
		IF rast IS NULL THEN
			RETURN NULL;
END IF;

		num_bands := st_numbands($1);

		-- PNG allows 1, 3 or 4 bands
		IF num_bands <> 1 AND num_bands <> 3 AND num_bands <> 4 THEN
			RAISE NOTICE 'The PNG format only permits one, three or four bands.  The first band will be used.';
			rast2 := public.st_band($1, ARRAY[1]);
			num_bands := public.st_numbands(rast2);
ELSE
			rast2 := rast;
END IF;

		-- PNG only supports 8BUI and 16BUI pixeltype
FOR i IN 1..num_bands LOOP
			pt = public.ST_BandPixelType(rast, i);
			IF pt != '8BUI' AND pt != '16BUI' THEN
				RAISE EXCEPTION 'The pixel type of band % in the raster is not 8BUI or 16BUI.  The PNG format can only be used with 8BUI and 16BUI pixel types.', i;
END IF;
END LOOP;

RETURN public.st_asgdalraster(rast2, 'PNG', $2, NULL);
END;
	$$;

comment on function st_aspng(raster, text[]) is 'args: rast, options=NULL - Return the raster tile selected bands as a single portable network graphics (PNG) image (byte array). If 1, 3, or 4 bands in raster and no bands are specified, then all bands are used. If more 2 or more than 4 bands and no bands specified, then only band 1 is used. Bands are mapped to RGB or RGBA space.';

alter function st_aspng(raster, text[]) owner to postgres;

create function st_aspng(rast raster, nbands integer[], options text[] DEFAULT NULL::text[]) returns bytea
    immutable
    parallel safe
    language sql
as
$$ SELECT public.st_aspng(st_band($1, $2), $3) $$;

comment on function st_aspng(raster, integer[], text[]) is 'args: rast, nbands, options=NULL - Return the raster tile selected bands as a single portable network graphics (PNG) image (byte array). If 1, 3, or 4 bands in raster and no bands are specified, then all bands are used. If more 2 or more than 4 bands and no bands specified, then only band 1 is used. Bands are mapped to RGB or RGBA space.';

alter function st_aspng(raster, integer[], text[]) owner to postgres;

create function st_aspng(rast raster, nbands integer[], compression integer) returns bytea
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
compression2 int;
		options text[];
BEGIN
		IF compression IS NOT NULL THEN
			IF compression > 9 THEN
				compression2 := 9;
			ELSEIF compression < 1 THEN
				compression2 := 1;
ELSE
				compression2 := compression;
END IF;

			options := array_append(options, 'ZLEVEL=' || compression2);
END IF;

RETURN public.st_aspng(st_band($1, $2), options);
END;
	$$;

comment on function st_aspng(raster, integer[], integer) is 'args: rast, nbands, compression - Return the raster tile selected bands as a single portable network graphics (PNG) image (byte array). If 1, 3, or 4 bands in raster and no bands are specified, then all bands are used. If more 2 or more than 4 bands and no bands specified, then only band 1 is used. Bands are mapped to RGB or RGBA space.';

alter function st_aspng(raster, integer[], integer) owner to postgres;

create function st_aspng(rast raster, nband integer, options text[] DEFAULT NULL::text[]) returns bytea
    immutable
    parallel safe
    language sql
as
$$ SELECT public.st_aspng(st_band($1, $2), $3) $$;

comment on function st_aspng(raster, integer, text[]) is 'args: rast, nband, options=NULL - Return the raster tile selected bands as a single portable network graphics (PNG) image (byte array). If 1, 3, or 4 bands in raster and no bands are specified, then all bands are used. If more 2 or more than 4 bands and no bands specified, then only band 1 is used. Bands are mapped to RGB or RGBA space.';

alter function st_aspng(raster, integer, text[]) owner to postgres;

create function st_aspng(rast raster, nband integer, compression integer) returns bytea
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.st_aspng($1, ARRAY[$2], $3) $$;

comment on function st_aspng(raster, integer, integer) is 'args: rast, nband, compression - Return the raster tile selected bands as a single portable network graphics (PNG) image (byte array). If 1, 3, or 4 bands in raster and no bands are specified, then all bands are used. If more 2 or more than 4 bands and no bands specified, then only band 1 is used. Bands are mapped to RGB or RGBA space.';

alter function st_aspng(raster, integer, integer) owner to postgres;

create function _st_asraster(geom geometry, scalex double precision default 0, scaley double precision default 0, width integer default 0, height integer default 0, pixeltype text[] default ARRAY['8BUI'::text], value double precision[] default ARRAY[(1)::double precision], nodataval double precision[] default ARRAY[(0)::double precision], upperleftx double precision default NULL::double precision, upperlefty double precision default NULL::double precision, gridx double precision default NULL::double precision, gridy double precision default NULL::double precision, skewx double precision default 0, skewy double precision default 0, touched boolean default false) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_asraster(geometry, double precision, double precision, integer, integer, text[], double precision[], double precision[], double precision, double precision, double precision, double precision, double precision, double precision, boolean) owner to postgres;

create function st_asraster(geom geometry, scalex double precision, scaley double precision, gridx double precision DEFAULT NULL::double precision, gridy double precision DEFAULT NULL::double precision, pixeltype text[] DEFAULT ARRAY['8BUI'::text], value double precision[] DEFAULT ARRAY[(1)::double precision], nodataval double precision[] DEFAULT ARRAY[(0)::double precision], skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_asraster($1, $2, $3, NULL, NULL, $6, $7, $8, NULL, NULL, $4, $5, $9, $10, $11) $$;

comment on function st_asraster(geometry, double precision, double precision, double precision, double precision, text[], double precision[], double precision[], double precision, double precision, boolean) is 'args: geom, scalex, scaley, gridx=NULL, gridy=NULL, pixeltype=ARRAY[''8BUI''], value=ARRAY[1], nodataval=ARRAY[0], skewx=0, skewy=0, touched=false - Converts a PostGIS geometry to a PostGIS raster.';

alter function st_asraster(geometry, double precision, double precision, double precision, double precision, text[], double precision[], double precision[], double precision, double precision, boolean) owner to postgres;

create function st_asraster(geom geometry, scalex double precision, scaley double precision, pixeltype text[], value double precision[] DEFAULT ARRAY[(1)::double precision], nodataval double precision[] DEFAULT ARRAY[(0)::double precision], upperleftx double precision DEFAULT NULL::double precision, upperlefty double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_asraster($1, $2, $3, NULL, NULL, $4, $5, $6, $7, $8, NULL, NULL,	$9, $10, $11) $$;

comment on function st_asraster(geometry, double precision, double precision, text[], double precision[], double precision[], double precision, double precision, double precision, double precision, boolean) is 'args: geom, scalex, scaley, pixeltype, value=ARRAY[1], nodataval=ARRAY[0], upperleftx=NULL, upperlefty=NULL, skewx=0, skewy=0, touched=false - Converts a PostGIS geometry to a PostGIS raster.';

alter function st_asraster(geometry, double precision, double precision, text[], double precision[], double precision[], double precision, double precision, double precision, double precision, boolean) owner to postgres;

create function st_asraster(geom geometry, width integer, height integer, gridx double precision DEFAULT NULL::double precision, gridy double precision DEFAULT NULL::double precision, pixeltype text[] DEFAULT ARRAY['8BUI'::text], value double precision[] DEFAULT ARRAY[(1)::double precision], nodataval double precision[] DEFAULT ARRAY[(0)::double precision], skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_asraster($1, NULL, NULL, $2, $3, $6, $7, $8, NULL, NULL, $4, $5, $9, $10, $11) $$;

comment on function st_asraster(geometry, integer, integer, double precision, double precision, text[], double precision[], double precision[], double precision, double precision, boolean) is 'args: geom, width, height, gridx=NULL, gridy=NULL, pixeltype=ARRAY[''8BUI''], value=ARRAY[1], nodataval=ARRAY[0], skewx=0, skewy=0, touched=false - Converts a PostGIS geometry to a PostGIS raster.';

alter function st_asraster(geometry, integer, integer, double precision, double precision, text[], double precision[], double precision[], double precision, double precision, boolean) owner to postgres;

create function st_asraster(geom geometry, width integer, height integer, pixeltype text[], value double precision[] DEFAULT ARRAY[(1)::double precision], nodataval double precision[] DEFAULT ARRAY[(0)::double precision], upperleftx double precision DEFAULT NULL::double precision, upperlefty double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_asraster($1, NULL, NULL, $2, $3, $4, $5, $6, $7, $8, NULL, NULL,	$9, $10, $11) $$;

comment on function st_asraster(geometry, integer, integer, text[], double precision[], double precision[], double precision, double precision, double precision, double precision, boolean) is 'args: geom, width, height, pixeltype, value=ARRAY[1], nodataval=ARRAY[0], upperleftx=NULL, upperlefty=NULL, skewx=0, skewy=0, touched=false - Converts a PostGIS geometry to a PostGIS raster.';

alter function st_asraster(geometry, integer, integer, text[], double precision[], double precision[], double precision, double precision, double precision, double precision, boolean) owner to postgres;

create function st_asraster(geom geometry, scalex double precision, scaley double precision, gridx double precision, gridy double precision, pixeltype text, value double precision DEFAULT 1, nodataval double precision DEFAULT 0, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_asraster($1, $2, $3, NULL, NULL, ARRAY[$6]::text[], ARRAY[$7]::double precision[], ARRAY[$8]::double precision[], NULL, NULL, $4, $5, $9, $10, $11) $$;

comment on function st_asraster(geometry, double precision, double precision, double precision, double precision, text, double precision, double precision, double precision, double precision, boolean) is 'args: geom, scalex, scaley, gridx, gridy, pixeltype, value=1, nodataval=0, skewx=0, skewy=0, touched=false - Converts a PostGIS geometry to a PostGIS raster.';

alter function st_asraster(geometry, double precision, double precision, double precision, double precision, text, double precision, double precision, double precision, double precision, boolean) owner to postgres;

create function st_asraster(geom geometry, scalex double precision, scaley double precision, pixeltype text, value double precision DEFAULT 1, nodataval double precision DEFAULT 0, upperleftx double precision DEFAULT NULL::double precision, upperlefty double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_asraster($1, $2, $3, NULL, NULL, ARRAY[$4]::text[], ARRAY[$5]::double precision[], ARRAY[$6]::double precision[], $7, $8, NULL, NULL, $9, $10, $11) $$;

comment on function st_asraster(geometry, double precision, double precision, text, double precision, double precision, double precision, double precision, double precision, double precision, boolean) is 'args: geom, scalex, scaley, pixeltype, value=1, nodataval=0, upperleftx=NULL, upperlefty=NULL, skewx=0, skewy=0, touched=false - Converts a PostGIS geometry to a PostGIS raster.';

alter function st_asraster(geometry, double precision, double precision, text, double precision, double precision, double precision, double precision, double precision, double precision, boolean) owner to postgres;

create function st_asraster(geom geometry, width integer, height integer, gridx double precision, gridy double precision, pixeltype text, value double precision DEFAULT 1, nodataval double precision DEFAULT 0, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_asraster($1, NULL, NULL, $2, $3, ARRAY[$6]::text[], ARRAY[$7]::double precision[], ARRAY[$8]::double precision[], NULL, NULL, $4, $5, $9, $10, $11) $$;

comment on function st_asraster(geometry, integer, integer, double precision, double precision, text, double precision, double precision, double precision, double precision, boolean) is 'args: geom, width, height, gridx, gridy, pixeltype, value=1, nodataval=0, skewx=0, skewy=0, touched=false - Converts a PostGIS geometry to a PostGIS raster.';

alter function st_asraster(geometry, integer, integer, double precision, double precision, text, double precision, double precision, double precision, double precision, boolean) owner to postgres;

create function st_asraster(geom geometry, width integer, height integer, pixeltype text, value double precision DEFAULT 1, nodataval double precision DEFAULT 0, upperleftx double precision DEFAULT NULL::double precision, upperlefty double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, touched boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_asraster($1, NULL, NULL, $2, $3, ARRAY[$4]::text[], ARRAY[$5]::double precision[], ARRAY[$6]::double precision[], $7, $8, NULL, NULL,$9, $10, $11) $$;

comment on function st_asraster(geometry, integer, integer, text, double precision, double precision, double precision, double precision, double precision, double precision, boolean) is 'args: geom, width, height, pixeltype, value=1, nodataval=0, upperleftx=NULL, upperlefty=NULL, skewx=0, skewy=0, touched=false - Converts a PostGIS geometry to a PostGIS raster.';

alter function st_asraster(geometry, integer, integer, text, double precision, double precision, double precision, double precision, double precision, double precision, boolean) owner to postgres;

create function st_asraster(geom geometry, ref raster, pixeltype text[] DEFAULT ARRAY['8BUI'::text], value double precision[] DEFAULT ARRAY[(1)::double precision], nodataval double precision[] DEFAULT ARRAY[(0)::double precision], touched boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
g public.geometry;
		g_srid integer;

		ul_x double precision;
		ul_y double precision;
		scale_x double precision;
		scale_y double precision;
		skew_x double precision;
		skew_y double precision;
		sr_id integer;
BEGIN
SELECT upperleftx, upperlefty, scalex, scaley, skewx, skewy, srid INTO ul_x, ul_y, scale_x, scale_y, skew_x, skew_y, sr_id FROM public.ST_Metadata(ref);
--RAISE NOTICE '%, %, %, %, %, %, %', ul_x, ul_y, scale_x, scale_y, skew_x, skew_y, sr_id;

-- geometry and raster has different SRID
g_srid := public.ST_SRID(geom);
		IF g_srid != sr_id THEN
			RAISE NOTICE 'The geometry''s SRID (%) is not the same as the raster''s SRID (%).  The geometry will be transformed to the raster''s projection', g_srid, sr_id;
			g := public.ST_Transform(geom, sr_id);
ELSE
			g := geom;
END IF;

RETURN public._ST_asraster(g, scale_x, scale_y, NULL, NULL, $3, $4, $5, NULL, NULL, ul_x, ul_y, skew_x, skew_y, $6);
END;
	$$;

comment on function st_asraster(geometry, raster, text[], double precision[], double precision[], boolean) is 'args: geom, ref, pixeltype=ARRAY[''8BUI''], value=ARRAY[1], nodataval=ARRAY[0], touched=false - Converts a PostGIS geometry to a PostGIS raster.';

alter function st_asraster(geometry, raster, text[], double precision[], double precision[], boolean) owner to postgres;

create function st_asraster(geom geometry, ref raster, pixeltype text, value double precision DEFAULT 1, nodataval double precision DEFAULT 0, touched boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT  public.ST_AsRaster($1, $2, ARRAY[$3]::text[], ARRAY[$4]::double precision[], ARRAY[$5]::double precision[], $6) $$;

comment on function st_asraster(geometry, raster, text, double precision, double precision, boolean) is 'args: geom, ref, pixeltype, value=1, nodataval=0, touched=false - Converts a PostGIS geometry to a PostGIS raster.';

alter function st_asraster(geometry, raster, text, double precision, double precision, boolean) owner to postgres;

create function _st_gdalwarp(rast raster, algorithm text default 'NearestNeighbour'::text, maxerr double precision default 0.125, srid integer default NULL::integer, scalex double precision default 0, scaley double precision default 0, gridx double precision default NULL::double precision, gridy double precision default NULL::double precision, skewx double precision default 0, skewy double precision default 0, width integer default NULL::integer, height integer default NULL::integer) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_gdalwarp(raster, text, double precision, integer, double precision, double precision, double precision, double precision, double precision, double precision, integer, integer) owner to postgres;

create function st_resample(rast raster, scalex double precision DEFAULT 0, scaley double precision DEFAULT 0, gridx double precision DEFAULT NULL::double precision, gridy double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_gdalwarp($1, $8,	$9, NULL, $2, $3, $4, $5, $6, $7) $$;

comment on function st_resample(raster, double precision, double precision, double precision, double precision, double precision, double precision, text, double precision) is 'args: rast, scalex=0, scaley=0, gridx=NULL, gridy=NULL, skewx=0, skewy=0, algorithm=NearestNeighbor, maxerr=0.125 - Resample a raster using a specified resampling algorithm, new dimensions, an arbitrary grid corner and a set of raster georeferencing attributes defined or borrowed from another raster.';

alter function st_resample(raster, double precision, double precision, double precision, double precision, double precision, double precision, text, double precision) owner to postgres;

create function st_resample(rast raster, width integer, height integer, gridx double precision DEFAULT NULL::double precision, gridy double precision DEFAULT NULL::double precision, skewx double precision DEFAULT 0, skewy double precision DEFAULT 0, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_gdalwarp($1, $8,	$9, NULL, NULL, NULL, $4, $5, $6, $7, $2, $3) $$;

comment on function st_resample(raster, integer, integer, double precision, double precision, double precision, double precision, text, double precision) is 'args: rast, width, height, gridx=NULL, gridy=NULL, skewx=0, skewy=0, algorithm=NearestNeighbor, maxerr=0.125 - Resample a raster using a specified resampling algorithm, new dimensions, an arbitrary grid corner and a set of raster georeferencing attributes defined or borrowed from another raster.';

alter function st_resample(raster, integer, integer, double precision, double precision, double precision, double precision, text, double precision) owner to postgres;

create function st_resample(rast raster, ref raster, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125, usescale boolean DEFAULT true) returns raster
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
rastsrid int;

		_srid int;
		_dimx int;
		_dimy int;
		_scalex double precision;
		_scaley double precision;
		_gridx double precision;
		_gridy double precision;
		_skewx double precision;
		_skewy double precision;
BEGIN
SELECT srid, width, height, scalex, scaley, upperleftx, upperlefty, skewx, skewy INTO _srid, _dimx, _dimy, _scalex, _scaley, _gridx, _gridy, _skewx, _skewy FROM st_metadata($2);

rastsrid := public.ST_SRID($1);

		-- both rasters must have the same SRID
		IF (rastsrid != _srid) THEN
			RAISE EXCEPTION 'The raster to be resampled has a different SRID from the reference raster';
RETURN NULL;
END IF;

		IF usescale IS TRUE THEN
			_dimx := NULL;
_dimy := NULL;
ELSE
			_scalex := NULL;
_scaley := NULL;
END IF;

RETURN public._ST_gdalwarp($1, $3, $4, NULL, _scalex, _scaley, _gridx, _gridy, _skewx, _skewy, _dimx, _dimy);
END;
	$$;

comment on function st_resample(raster, raster, text, double precision, boolean) is 'args: rast, ref, algorithm=NearestNeighbor, maxerr=0.125, usescale=true - Resample a raster using a specified resampling algorithm, new dimensions, an arbitrary grid corner and a set of raster georeferencing attributes defined or borrowed from another raster.';

alter function st_resample(raster, raster, text, double precision, boolean) owner to postgres;

create function st_resample(rast raster, ref raster, usescale boolean, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.st_resample($1, $2, $4, $5, $3) $$;

comment on function st_resample(raster, raster, boolean, text, double precision) is 'args: rast, ref, usescale, algorithm=NearestNeighbor, maxerr=0.125 - Resample a raster using a specified resampling algorithm, new dimensions, an arbitrary grid corner and a set of raster georeferencing attributes defined or borrowed from another raster.';

alter function st_resample(raster, raster, boolean, text, double precision) owner to postgres;

create function st_transform(rast raster, srid integer, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125, scalex double precision DEFAULT 0, scaley double precision DEFAULT 0) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_gdalwarp($1, $3, $4, $2, $5, $6) $$;

comment on function st_transform(raster, integer, text, double precision, double precision, double precision) is 'args: rast, srid, algorithm=NearestNeighbor, maxerr=0.125, scalex, scaley - Reprojects a raster in a known spatial reference system to another known spatial reference system using specified resampling algorithm. Options are NearestNeighbor, Bilinear, Cubic, CubicSpline, Lanczos defaulting to NearestNeighbor.';

alter function st_transform(raster, integer, text, double precision, double precision, double precision) owner to postgres;

create function st_transform(rast raster, srid integer, scalex double precision, scaley double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_gdalwarp($1, $5, $6, $2, $3, $4) $$;

comment on function st_transform(raster, integer, double precision, double precision, text, double precision) is 'args: rast, srid, scalex, scaley, algorithm=NearestNeighbor, maxerr=0.125 - Reprojects a raster in a known spatial reference system to another known spatial reference system using specified resampling algorithm. Options are NearestNeighbor, Bilinear, Cubic, CubicSpline, Lanczos defaulting to NearestNeighbor.';

alter function st_transform(raster, integer, double precision, double precision, text, double precision) owner to postgres;

create function st_transform(rast raster, srid integer, scalexy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_gdalwarp($1, $4, $5, $2, $3, $3) $$;

alter function st_transform(raster, integer, double precision, text, double precision) owner to postgres;

create function st_transform(rast raster, alignto raster, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
_srid integer;
		_scalex double precision;
		_scaley double precision;
		_gridx double precision;
		_gridy double precision;
		_skewx double precision;
		_skewy double precision;
BEGIN
SELECT srid, scalex, scaley, upperleftx, upperlefty, skewx, skewy INTO _srid, _scalex, _scaley, _gridx, _gridy, _skewx, _skewy FROM st_metadata($2);

RETURN public._ST_gdalwarp($1, $3, $4, _srid, _scalex, _scaley, _gridx, _gridy, _skewx, _skewy, NULL, NULL);
END;
	$$;

comment on function st_transform(raster, raster, text, double precision) is 'args: rast, alignto, algorithm=NearestNeighbor, maxerr=0.125 - Reprojects a raster in a known spatial reference system to another known spatial reference system using specified resampling algorithm. Options are NearestNeighbor, Bilinear, Cubic, CubicSpline, Lanczos defaulting to NearestNeighbor.';

alter function st_transform(raster, raster, text, double precision) owner to postgres;

create function st_rescale(rast raster, scalex double precision, scaley double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT  public._ST_GdalWarp($1, $4, $5, NULL, $2, $3) $$;

comment on function st_rescale(raster, double precision, double precision, text, double precision) is 'args: rast, scalex, scaley, algorithm=NearestNeighbor, maxerr=0.125 - Resample a raster by adjusting only its scale (or pixel size). New pixel values are computed using the NearestNeighbor (english or american spelling), Bilinear, Cubic, CubicSpline or Lanczos resampling algorithm. Default is NearestNeighbor.';

alter function st_rescale(raster, double precision, double precision, text, double precision) owner to postgres;

create function st_rescale(rast raster, scalexy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT  public._ST_GdalWarp($1, $3, $4, NULL, $2, $2) $$;

comment on function st_rescale(raster, double precision, text, double precision) is 'args: rast, scalexy, algorithm=NearestNeighbor, maxerr=0.125 - Resample a raster by adjusting only its scale (or pixel size). New pixel values are computed using the NearestNeighbor (english or american spelling), Bilinear, Cubic, CubicSpline or Lanczos resampling algorithm. Default is NearestNeighbor.';

alter function st_rescale(raster, double precision, text, double precision) owner to postgres;

create function st_reskew(rast raster, skewx double precision, skewy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_GdalWarp($1, $4, $5, NULL, 0, 0, NULL, NULL, $2, $3) $$;

comment on function st_reskew(raster, double precision, double precision, text, double precision) is 'args: rast, skewx, skewy, algorithm=NearestNeighbor, maxerr=0.125 - Resample a raster by adjusting only its skew (or rotation parameters). New pixel values are computed using the NearestNeighbor (english or american spelling), Bilinear, Cubic, CubicSpline or Lanczos resampling algorithm. Default is NearestNeighbor.';

alter function st_reskew(raster, double precision, double precision, text, double precision) owner to postgres;

create function st_reskew(rast raster, skewxy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_GdalWarp($1, $3, $4, NULL, 0, 0, NULL, NULL, $2, $2) $$;

comment on function st_reskew(raster, double precision, text, double precision) is 'args: rast, skewxy, algorithm=NearestNeighbor, maxerr=0.125 - Resample a raster by adjusting only its skew (or rotation parameters). New pixel values are computed using the NearestNeighbor (english or american spelling), Bilinear, Cubic, CubicSpline or Lanczos resampling algorithm. Default is NearestNeighbor.';

alter function st_reskew(raster, double precision, text, double precision) owner to postgres;

create function st_snaptogrid(rast raster, gridx double precision, gridy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125, scalex double precision DEFAULT 0, scaley double precision DEFAULT 0) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_GdalWarp($1, $4, $5, NULL, $6, $7, $2, $3) $$;

comment on function st_snaptogrid(raster, double precision, double precision, text, double precision, double precision, double precision) is 'args: rast, gridx, gridy, algorithm=NearestNeighbor, maxerr=0.125, scalex=DEFAULT 0, scaley=DEFAULT 0 - Resample a raster by snapping it to a grid. New pixel values are computed using the NearestNeighbor (english or american spelling), Bilinear, Cubic, CubicSpline or Lanczos resampling algorithm. Default is NearestNeighbor.';

alter function st_snaptogrid(raster, double precision, double precision, text, double precision, double precision, double precision) owner to postgres;

create function st_snaptogrid(rast raster, gridx double precision, gridy double precision, scalex double precision, scaley double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_gdalwarp($1, $6, $7, NULL, $4, $5, $2, $3) $$;

comment on function st_snaptogrid(raster, double precision, double precision, double precision, double precision, text, double precision) is 'args: rast, gridx, gridy, scalex, scaley, algorithm=NearestNeighbor, maxerr=0.125 - Resample a raster by snapping it to a grid. New pixel values are computed using the NearestNeighbor (english or american spelling), Bilinear, Cubic, CubicSpline or Lanczos resampling algorithm. Default is NearestNeighbor.';

alter function st_snaptogrid(raster, double precision, double precision, double precision, double precision, text, double precision) owner to postgres;

create function st_snaptogrid(rast raster, gridx double precision, gridy double precision, scalexy double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_gdalwarp($1, $5, $6, NULL, $4, $4, $2, $3) $$;

comment on function st_snaptogrid(raster, double precision, double precision, double precision, text, double precision) is 'args: rast, gridx, gridy, scalexy, algorithm=NearestNeighbor, maxerr=0.125 - Resample a raster by snapping it to a grid. New pixel values are computed using the NearestNeighbor (english or american spelling), Bilinear, Cubic, CubicSpline or Lanczos resampling algorithm. Default is NearestNeighbor.';

alter function st_snaptogrid(raster, double precision, double precision, double precision, text, double precision) owner to postgres;

create function st_resize(rast raster, width text, height text, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
i integer;

		wh text[2];

		whi integer[2];
		whd double precision[2];

		_width integer;
		_height integer;
BEGIN
		wh[1] := trim(both from $2);
		wh[2] := trim(both from $3);

		-- see if width and height are percentages
FOR i IN 1..2 LOOP
			IF position('%' in wh[i]) > 0 THEN
BEGIN
					wh[i] := (regexp_matches(wh[i], E'^(\\d*.?\\d*)%{1}$'))[1];
					IF length(wh[i]) < 1 THEN
						RAISE invalid_parameter_value;
END IF;

					whd[i] := wh[i]::double precision * 0.01;
EXCEPTION WHEN OTHERS THEN -- TODO: WHEN invalid_parameter_value !
					RAISE EXCEPTION 'Invalid percentage value provided for width/height';
RETURN NULL;
END;
ELSE
BEGIN
					whi[i] := abs(wh[i]::integer);
EXCEPTION WHEN OTHERS THEN -- TODO: only handle appropriate SQLSTATE
					RAISE EXCEPTION 'Non-integer value provided for width/height';
RETURN NULL;
END;
END IF;
END LOOP;

		IF whd[1] IS NOT NULL OR whd[2] IS NOT NULL THEN
SELECT foo.width, foo.height INTO _width, _height FROM public.ST_Metadata($1) AS foo;

IF whd[1] IS NOT NULL THEN
				whi[1] := round(_width::double precision * whd[1])::integer;
END IF;

			IF whd[2] IS NOT NULL THEN
				whi[2] := round(_height::double precision * whd[2])::integer;
END IF;

END IF;

		-- should NEVER be here
		IF whi[1] IS NULL OR whi[2] IS NULL THEN
			RAISE EXCEPTION 'Unable to determine appropriate width or height';
RETURN NULL;
END IF;

FOR i IN 1..2 LOOP
			IF whi[i] < 1 THEN
				whi[i] = 1;
END IF;
END LOOP;

RETURN public._ST_gdalwarp(
    $1,
    $4, $5,
    NULL,
    NULL, NULL,
    NULL, NULL,
    NULL, NULL,
    whi[1], whi[2]
    );
END;
	$$;

comment on function st_resize(raster, text, text, text, double precision) is 'args: rast, width, height, algorithm=NearestNeighbor, maxerr=0.125 - Resize a raster to a new width/height';

alter function st_resize(raster, text, text, text, double precision) owner to postgres;

create function st_resize(rast raster, width integer, height integer, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_gdalwarp($1, $4, $5, NULL, NULL, NULL, NULL, NULL, NULL, NULL, abs($2), abs($3)) $$;

comment on function st_resize(raster, integer, integer, text, double precision) is 'args: rast, width, height, algorithm=NearestNeighbor, maxerr=0.125 - Resize a raster to a new width/height';

alter function st_resize(raster, integer, integer, text, double precision) owner to postgres;

create function st_resize(rast raster, percentwidth double precision, percentheight double precision, algorithm text DEFAULT 'NearestNeighbour'::text, maxerr double precision DEFAULT 0.125) returns raster
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
_width integer;
		_height integer;
BEGIN
		-- range check
		IF $2 <= 0. OR $2 > 1. OR $3 <= 0. OR $3 > 1. THEN
			RAISE EXCEPTION 'Percentages must be a value greater than zero and less than or equal to one, e.g. 0.5 for 50%%';
END IF;

SELECT width, height INTO _width, _height FROM public.ST_Metadata($1);

_width := round(_width::double precision * $2)::integer;
_height:= round(_height::double precision * $3)::integer;

		IF _width < 1 THEN
			_width := 1;
END IF;
		IF _height < 1 THEN
			_height := 1;
END IF;

RETURN public._ST_gdalwarp(
    $1,
    $4, $5,
    NULL,
    NULL, NULL,
    NULL, NULL,
    NULL, NULL,
    _width, _height
    );
END;
	$$;

comment on function st_resize(raster, double precision, double precision, text, double precision) is 'args: rast, percentwidth, percentheight, algorithm=NearestNeighbor, maxerr=0.125 - Resize a raster to a new width/height';

alter function st_resize(raster, double precision, double precision, text, double precision) owner to postgres;

create function st_mapalgebraexpr(rast raster, band integer, pixeltype text, expression text, nodataval double precision default NULL::double precision) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_mapalgebraexpr(raster, integer, text, text, double precision) is 'args: rast, band, pixeltype, expression, nodataval=NULL - 1 raster band version: Creates a new one band raster formed by applying a valid PostgreSQL algebraic operation on the input raster band and of pixeltype provided. Band 1 is assumed if no band is specified.';

alter function st_mapalgebraexpr(raster, integer, text, text, double precision) owner to postgres;

create function st_mapalgebraexpr(rast raster, pixeltype text, expression text, nodataval double precision DEFAULT NULL::double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebraexpr($1, 1, $2, $3, $4) $$;

comment on function st_mapalgebraexpr(raster, text, text, double precision) is 'args: rast, pixeltype, expression, nodataval=NULL - 1 raster band version: Creates a new one band raster formed by applying a valid PostgreSQL algebraic operation on the input raster band and of pixeltype provided. Band 1 is assumed if no band is specified.';

alter function st_mapalgebraexpr(raster, text, text, double precision) owner to postgres;

create function st_mapalgebrafct(rast raster, band integer, pixeltype text, onerastuserfunc regprocedure, args text[]) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_mapalgebrafct(raster, integer, text, regprocedure, text[]) is 'args: rast, band, pixeltype, onerasteruserfunc, VARIADIC args - 1 band version - Creates a new one band raster formed by applying a valid PostgreSQL function on the input raster band and of pixeltype prodived. Band 1 is assumed if no band is specified.';

alter function st_mapalgebrafct(raster, integer, text, regprocedure, text[]) owner to postgres;

create function st_mapalgebrafct(rast raster, band integer, pixeltype text, onerastuserfunc regprocedure) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebrafct($1, $2, $3, $4, NULL) $$;

comment on function st_mapalgebrafct(raster, integer, text, regprocedure) is 'args: rast, band, pixeltype, onerasteruserfunc - 1 band version - Creates a new one band raster formed by applying a valid PostgreSQL function on the input raster band and of pixeltype prodived. Band 1 is assumed if no band is specified.';

alter function st_mapalgebrafct(raster, integer, text, regprocedure) owner to postgres;

create function st_mapalgebrafct(rast raster, band integer, onerastuserfunc regprocedure, VARIADIC args text[]) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebrafct($1, $2, NULL, $3, VARIADIC $4) $$;

comment on function st_mapalgebrafct(raster, integer, regprocedure, text[]) is 'args: rast, band, onerasteruserfunc, VARIADIC args - 1 band version - Creates a new one band raster formed by applying a valid PostgreSQL function on the input raster band and of pixeltype prodived. Band 1 is assumed if no band is specified.';

alter function st_mapalgebrafct(raster, integer, regprocedure, text[]) owner to postgres;

create function st_mapalgebrafct(rast raster, band integer, onerastuserfunc regprocedure) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebrafct($1, $2, NULL, $3, NULL) $$;

comment on function st_mapalgebrafct(raster, integer, regprocedure) is 'args: rast, band, onerasteruserfunc - 1 band version - Creates a new one band raster formed by applying a valid PostgreSQL function on the input raster band and of pixeltype prodived. Band 1 is assumed if no band is specified.';

alter function st_mapalgebrafct(raster, integer, regprocedure) owner to postgres;

create function st_mapalgebrafct(rast raster, pixeltype text, onerastuserfunc regprocedure, VARIADIC args text[]) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebrafct($1, 1, $2, $3, VARIADIC $4) $$;

comment on function st_mapalgebrafct(raster, text, regprocedure, text[]) is 'args: rast, pixeltype, onerasteruserfunc, VARIADIC args - 1 band version - Creates a new one band raster formed by applying a valid PostgreSQL function on the input raster band and of pixeltype prodived. Band 1 is assumed if no band is specified.';

alter function st_mapalgebrafct(raster, text, regprocedure, text[]) owner to postgres;

create function st_mapalgebrafct(rast raster, pixeltype text, onerastuserfunc regprocedure) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebrafct($1, 1, $2, $3, NULL) $$;

comment on function st_mapalgebrafct(raster, text, regprocedure) is 'args: rast, pixeltype, onerasteruserfunc - 1 band version - Creates a new one band raster formed by applying a valid PostgreSQL function on the input raster band and of pixeltype prodived. Band 1 is assumed if no band is specified.';

alter function st_mapalgebrafct(raster, text, regprocedure) owner to postgres;

create function st_mapalgebrafct(rast raster, onerastuserfunc regprocedure, VARIADIC args text[]) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebrafct($1, 1, NULL, $2, VARIADIC $3) $$;

comment on function st_mapalgebrafct(raster, regprocedure, text[]) is 'args: rast, onerasteruserfunc, VARIADIC args - 1 band version - Creates a new one band raster formed by applying a valid PostgreSQL function on the input raster band and of pixeltype prodived. Band 1 is assumed if no band is specified.';

alter function st_mapalgebrafct(raster, regprocedure, text[]) owner to postgres;

create function st_mapalgebrafct(rast raster, onerastuserfunc regprocedure) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebrafct($1, 1, NULL, $2, NULL) $$;

comment on function st_mapalgebrafct(raster, regprocedure) is 'args: rast, onerasteruserfunc - 1 band version - Creates a new one band raster formed by applying a valid PostgreSQL function on the input raster band and of pixeltype prodived. Band 1 is assumed if no band is specified.';

alter function st_mapalgebrafct(raster, regprocedure) owner to postgres;

create function st_mapalgebraexpr(rast1 raster, band1 integer, rast2 raster, band2 integer, expression text, pixeltype text default NULL::text, extenttype text default 'INTERSECTION'::text, nodata1expr text default NULL::text, nodata2expr text default NULL::text, nodatanodataval double precision default NULL::double precision) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_mapalgebraexpr(raster, integer, raster, integer, text, text, text, text, text, double precision) is 'args: rast1, band1, rast2, band2, expression, pixeltype=same_as_rast1_band, extenttype=INTERSECTION, nodata1expr=NULL, nodata2expr=NULL, nodatanodataval=NULL - 2 raster band version: Creates a new one band raster formed by applying a valid PostgreSQL algebraic operation on the two input raster bands and of pixeltype provided. band 1 of each raster is assumed if no band numbers are specified. The resulting raster will be aligned (scale, skew and pixel corners) on the grid defined by the first raster and have its extent defined by the "extenttype" parameter. Values for "extenttype" can be: INTERSECTION, UNION, FIRST, SECOND.';

alter function st_mapalgebraexpr(raster, integer, raster, integer, text, text, text, text, text, double precision) owner to postgres;

create function st_mapalgebraexpr(rast1 raster, rast2 raster, expression text, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, nodata1expr text DEFAULT NULL::text, nodata2expr text DEFAULT NULL::text, nodatanodataval double precision DEFAULT NULL::double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebraexpr($1, 1, $2, 1, $3, $4, $5, $6, $7, $8) $$;

comment on function st_mapalgebraexpr(raster, raster, text, text, text, text, text, double precision) is 'args: rast1, rast2, expression, pixeltype=same_as_rast1_band, extenttype=INTERSECTION, nodata1expr=NULL, nodata2expr=NULL, nodatanodataval=NULL - 2 raster band version: Creates a new one band raster formed by applying a valid PostgreSQL algebraic operation on the two input raster bands and of pixeltype provided. band 1 of each raster is assumed if no band numbers are specified. The resulting raster will be aligned (scale, skew and pixel corners) on the grid defined by the first raster and have its extent defined by the "extenttype" parameter. Values for "extenttype" can be: INTERSECTION, UNION, FIRST, SECOND.';

alter function st_mapalgebraexpr(raster, raster, text, text, text, text, text, double precision) owner to postgres;

create function st_mapalgebrafct(rast1 raster, band1 integer, rast2 raster, band2 integer, tworastuserfunc regprocedure, pixeltype text default NULL::text, extenttype text default 'INTERSECTION'::text, userargs text[] default NULL::text[]) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_mapalgebrafct(raster, integer, raster, integer, regprocedure, text, text, text[]) is 'args: rast1, band1, rast2, band2, tworastuserfunc, pixeltype=same_as_rast1, extenttype=INTERSECTION, VARIADIC userargs - 2 band version - Creates a new one band raster formed by applying a valid PostgreSQL function on the 2 input raster bands and of pixeltype prodived. Band 1 is assumed if no band is specified. Extent type defaults to INTERSECTION if not specified.';

alter function st_mapalgebrafct(raster, integer, raster, integer, regprocedure, text, text, text[]) owner to postgres;

create function st_mapalgebrafct(rast1 raster, rast2 raster, tworastuserfunc regprocedure, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, VARIADIC userargs text[] DEFAULT NULL::text[]) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebrafct($1, 1, $2, 1, $3, $4, $5, VARIADIC $6) $$;

comment on function st_mapalgebrafct(raster, raster, regprocedure, text, text, text[]) is 'args: rast1, rast2, tworastuserfunc, pixeltype=same_as_rast1, extenttype=INTERSECTION, VARIADIC userargs - 2 band version - Creates a new one band raster formed by applying a valid PostgreSQL function on the 2 input raster bands and of pixeltype prodived. Band 1 is assumed if no band is specified. Extent type defaults to INTERSECTION if not specified.';

alter function st_mapalgebrafct(raster, raster, regprocedure, text, text, text[]) owner to postgres;

create function st_mapalgebrafctngb(rast raster, band integer, pixeltype text, ngbwidth integer, ngbheight integer, onerastngbuserfunc regprocedure, nodatamode text, args text[]) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_mapalgebrafctngb(raster, integer, text, integer, integer, regprocedure, text, text[]) is 'args: rast, band, pixeltype, ngbwidth, ngbheight, onerastngbuserfunc, nodatamode, VARIADIC args - 1-band version: Map Algebra Nearest Neighbor using user-defined PostgreSQL function. Return a raster which values are the result of a PLPGSQL user function involving a neighborhood of values from the input raster band.';

alter function st_mapalgebrafctngb(raster, integer, text, integer, integer, regprocedure, text, text[]) owner to postgres;

create function st_max4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_matrix float[][];
max float;
BEGIN
_matrix := matrix;
max := '-Infinity'::float;
FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
END IF;
END IF;
                IF max < _matrix[x][y] THEN
                    max := _matrix[x][y];
END IF;
END LOOP;
END LOOP;
RETURN max;
END;
    $$;

comment on function st_max4ma(double precision[], text, text[]) is 'args: matrix, nodatamode, VARIADIC args - Raster processing function that calculates the maximum pixel value in a neighborhood.';

alter function st_max4ma(double precision[], text, text[]) owner to postgres;

create function st_min4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_matrix float[][];
min float;
BEGIN
_matrix := matrix;
min := 'Infinity'::float;
FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
END IF;
END IF;
                IF min > _matrix[x][y] THEN
                    min := _matrix[x][y];
END IF;
END LOOP;
END LOOP;
RETURN min;
END;
    $$;

comment on function st_min4ma(double precision[], text, text[]) is 'args: matrix, nodatamode, VARIADIC args - Raster processing function that calculates the minimum pixel value in a neighborhood.';

alter function st_min4ma(double precision[], text, text[]) owner to postgres;

create function st_sum4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_matrix float[][];
sum float;
BEGIN
_matrix := matrix;
sum := 0;
FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
ELSE
                        _matrix[x][y] := nodatamode::float;
END IF;
END IF;
sum := sum + _matrix[x][y];
END LOOP;
END LOOP;
RETURN sum;
END;
    $$;

comment on function st_sum4ma(double precision[], text, text[]) is 'args: matrix, nodatamode, VARIADIC args - Raster processing function that calculates the sum of all pixel values in a neighborhood.';

alter function st_sum4ma(double precision[], text, text[]) owner to postgres;

create function st_mean4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_matrix float[][];
sum float;
count float;
BEGIN
_matrix := matrix;
sum := 0;
count := 0;
FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
ELSE
                        _matrix[x][y] := nodatamode::float;
count := count + 1;
END IF;
ELSE
                    count := count + 1;
END IF;
sum := sum + _matrix[x][y];
END LOOP;
END LOOP;
        IF count = 0 THEN
            RETURN NULL;
END IF;
RETURN sum / count;
END;
    $$;

comment on function st_mean4ma(double precision[], text, text[]) is 'args: matrix, nodatamode, VARIADIC args - Raster processing function that calculates the mean pixel value in a neighborhood.';

alter function st_mean4ma(double precision[], text, text[]) owner to postgres;

create function st_range4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_matrix float[][];
min float;
max float;
BEGIN
_matrix := matrix;
min := 'Infinity'::float;
max := '-Infinity'::float;
FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
END IF;
END IF;
                IF min > _matrix[x][y] THEN
                    min = _matrix[x][y];
END IF;
                IF max < _matrix[x][y] THEN
                    max = _matrix[x][y];
END IF;
END LOOP;
END LOOP;
        IF max = '-Infinity'::float OR min = 'Infinity'::float THEN
            RETURN NULL;
END IF;
RETURN max - min;
END;
    $$;

comment on function st_range4ma(double precision[], text, text[]) is 'args: matrix, nodatamode, VARIADIC args - Raster processing function that calculates the range of pixel values in a neighborhood.';

alter function st_range4ma(double precision[], text, text[]) owner to postgres;

create function st_distinct4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) returns double precision
    immutable
    parallel safe
    language sql
as
$$ SELECT COUNT(DISTINCT unnest)::float FROM unnest($1) $$;

comment on function st_distinct4ma(double precision[], text, text[]) is 'args: matrix, nodatamode, VARIADIC args - Raster processing function that calculates the number of unique pixel values in a neighborhood.';

alter function st_distinct4ma(double precision[], text, text[]) owner to postgres;

create function st_stddev4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) returns double precision
    immutable
    parallel safe
    language sql
as
$$ SELECT stddev(unnest) FROM unnest($1) $$;

comment on function st_stddev4ma(double precision[], text, text[]) is 'args: matrix, nodatamode, VARIADIC args - Raster processing function that calculates the standard deviation of pixel values in a neighborhood.';

alter function st_stddev4ma(double precision[], text, text[]) owner to postgres;

create function _st_mapalgebra(rastbandargset rastbandarg[], callbackfunc regprocedure, pixeltype text default NULL::text, distancex integer default 0, distancey integer default 0, extenttype text default 'INTERSECTION'::text, customextent raster default NULL::raster, mask double precision[] default NULL::double precision[], weighted boolean default NULL::boolean, userargs text[] default NULL::text[]) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_mapalgebra(rastbandarg[], regprocedure, text, integer, integer, text, raster, double precision[], boolean, text[]) owner to postgres;

create function st_mapalgebra(rastbandargset rastbandarg[], callbackfunc regprocedure, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, customextent raster DEFAULT NULL::raster, distancex integer DEFAULT 0, distancey integer DEFAULT 0, VARIADIC userargs text[] DEFAULT NULL::text[]) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_MapAlgebra($1, $2, $3, $6, $7, $4, $5,NULL::double precision [],NULL::boolean, VARIADIC $8) $$;

comment on function st_mapalgebra(rastbandarg[], regprocedure, text, text, raster, integer, integer, text[]) is 'args: rastbandargset, callbackfunc, pixeltype=NULL, extenttype=INTERSECTION, customextent=NULL, distancex=0, distancey=0, VARIADIC userargs=NULL - Callback function version - Returns a one-band raster given one or more input rasters, band indexes and one user-specified callback function.';

alter function st_mapalgebra(rastbandarg[], regprocedure, text, text, raster, integer, integer, text[]) owner to postgres;

create function st_mapalgebra(rast raster, nband integer[], callbackfunc regprocedure, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'FIRST'::text, customextent raster DEFAULT NULL::raster, distancex integer DEFAULT 0, distancey integer DEFAULT 0, VARIADIC userargs text[] DEFAULT NULL::text[]) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
x int;
		argset rastbandarg[];
BEGIN
		IF $2 IS NULL OR array_ndims($2) < 1 OR array_length($2, 1) < 1 THEN
			RAISE EXCEPTION 'Populated 1D array must be provided for nband';
RETURN NULL;
END IF;

FOR x IN array_lower($2, 1)..array_upper($2, 1) LOOP
			IF $2[x] IS NULL THEN
				CONTINUE;
END IF;

			argset := argset || ROW($1, $2[x])::rastbandarg;
END LOOP;

		IF array_length(argset, 1) < 1 THEN
			RAISE EXCEPTION 'Populated 1D array must be provided for nband';
RETURN NULL;
END IF;

RETURN public._ST_MapAlgebra(argset, $3, $4, $7, $8, $5, $6,NULL::double precision [],NULL::boolean, VARIADIC $9);
END;
	$$;

comment on function st_mapalgebra(raster, integer[], regprocedure, text, text, raster, integer, integer, text[]) is 'args: rast, nband, callbackfunc, pixeltype=NULL, extenttype=FIRST, customextent=NULL, distancex=0, distancey=0, VARIADIC userargs=NULL - Callback function version - Returns a one-band raster given one or more input rasters, band indexes and one user-specified callback function.';

alter function st_mapalgebra(raster, integer[], regprocedure, text, text, raster, integer, integer, text[]) owner to postgres;

create function st_mapalgebra(rast raster, nband integer, callbackfunc regprocedure, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'FIRST'::text, customextent raster DEFAULT NULL::raster, distancex integer DEFAULT 0, distancey integer DEFAULT 0, VARIADIC userargs text[] DEFAULT NULL::text[]) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_MapAlgebra(ARRAY[ROW($1, $2)]::rastbandarg[], $3, $4, $7, $8, $5, $6,NULL::double precision [],NULL::boolean, VARIADIC $9) $$;

comment on function st_mapalgebra(raster, integer, regprocedure, text, text, raster, integer, integer, text[]) is 'args: rast, nband, callbackfunc, pixeltype=NULL, extenttype=FIRST, customextent=NULL, distancex=0, distancey=0, VARIADIC userargs=NULL - Callback function version - Returns a one-band raster given one or more input rasters, band indexes and one user-specified callback function.';

alter function st_mapalgebra(raster, integer, regprocedure, text, text, raster, integer, integer, text[]) owner to postgres;

create function st_mapalgebra(rast1 raster, nband1 integer, rast2 raster, nband2 integer, callbackfunc regprocedure, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, customextent raster DEFAULT NULL::raster, distancex integer DEFAULT 0, distancey integer DEFAULT 0, VARIADIC userargs text[] DEFAULT NULL::text[]) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_MapAlgebra(ARRAY[ROW($1, $2), ROW($3, $4)]::rastbandarg[], $5, $6, $9, $10, $7, $8,NULL::double precision [],NULL::boolean, VARIADIC $11) $$;

comment on function st_mapalgebra(raster, integer, raster, integer, regprocedure, text, text, raster, integer, integer, text[]) is 'args: rast1, nband1, rast2, nband2, callbackfunc, pixeltype=NULL, extenttype=INTERSECTION, customextent=NULL, distancex=0, distancey=0, VARIADIC userargs=NULL - Callback function version - Returns a one-band raster given one or more input rasters, band indexes and one user-specified callback function.';

alter function st_mapalgebra(raster, integer, raster, integer, regprocedure, text, text, raster, integer, integer, text[]) owner to postgres;

create function st_mapalgebra(rast raster, nband integer, callbackfunc regprocedure, mask double precision[], weighted boolean, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, customextent raster DEFAULT NULL::raster, VARIADIC userargs text[] DEFAULT NULL::text[]) returns raster
    immutable
    parallel safe
    language sql
as
$$
select public._ST_mapalgebra(ARRAY[ROW($1,$2)]::rastbandarg[],$3,$6,NULL::integer,NULL::integer,$7,$8,$4,$5,VARIADIC $9)
    $$;

comment on function st_mapalgebra(raster, integer, regprocedure, double precision[], boolean, text, text, raster, text[]) is 'args: rast, nband, callbackfunc, mask, weighted, pixeltype=NULL, extenttype=INTERSECTION, customextent=NULL, VARIADIC userargs=NULL - Callback function version - Returns a one-band raster given one or more input rasters, band indexes and one user-specified callback function.';

alter function st_mapalgebra(raster, integer, regprocedure, double precision[], boolean, text, text, raster, text[]) owner to postgres;

create function _st_mapalgebra(rastbandargset rastbandarg[], expression text, pixeltype text default NULL::text, extenttype text default 'INTERSECTION'::text, nodata1expr text default NULL::text, nodata2expr text default NULL::text, nodatanodataval double precision default NULL::double precision) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_mapalgebra(rastbandarg[], text, text, text, text, text, double precision) owner to postgres;

create function st_mapalgebra(rast raster, nband integer, pixeltype text, expression text, nodataval double precision DEFAULT NULL::double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_mapalgebra(ARRAY[ROW($1, $2)]::rastbandarg[], $4, $3, 'FIRST', $5::text) $$;

comment on function st_mapalgebra(raster, integer, text, text, double precision) is 'args: rast, nband, pixeltype, expression, nodataval=NULL - Expression version - Returns a one-band raster given one or two input rasters, band indexes and one or more user-specified SQL expressions.';

alter function st_mapalgebra(raster, integer, text, text, double precision) owner to postgres;

create function st_mapalgebra(rast raster, pixeltype text, expression text, nodataval double precision DEFAULT NULL::double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebra($1, 1, $2, $3, $4) $$;

comment on function st_mapalgebra(raster, text, text, double precision) is 'args: rast, pixeltype, expression, nodataval=NULL - Expression version - Returns a one-band raster given one or two input rasters, band indexes and one or more user-specified SQL expressions.';

alter function st_mapalgebra(raster, text, text, double precision) owner to postgres;

create function st_mapalgebra(rast1 raster, band1 integer, rast2 raster, band2 integer, expression text, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, nodata1expr text DEFAULT NULL::text, nodata2expr text DEFAULT NULL::text, nodatanodataval double precision DEFAULT NULL::double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_mapalgebra(ARRAY[ROW($1, $2), ROW($3, $4)]::rastbandarg[], $5, $6, $7, $8, $9, $10) $$;

comment on function st_mapalgebra(raster, integer, raster, integer, text, text, text, text, text, double precision) is 'args: rast1, nband1, rast2, nband2, expression, pixeltype=NULL, extenttype=INTERSECTION, nodata1expr=NULL, nodata2expr=NULL, nodatanodataval=NULL - Expression version - Returns a one-band raster given one or two input rasters, band indexes and one or more user-specified SQL expressions.';

alter function st_mapalgebra(raster, integer, raster, integer, text, text, text, text, text, double precision) owner to postgres;

create function st_mapalgebra(rast1 raster, rast2 raster, expression text, pixeltype text DEFAULT NULL::text, extenttype text DEFAULT 'INTERSECTION'::text, nodata1expr text DEFAULT NULL::text, nodata2expr text DEFAULT NULL::text, nodatanodataval double precision DEFAULT NULL::double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_mapalgebra($1, 1, $2, 1, $3, $4, $5, $6, $7, $8) $$;

comment on function st_mapalgebra(raster, raster, text, text, text, text, text, double precision) is 'args: rast1, rast2, expression, pixeltype=NULL, extenttype=INTERSECTION, nodata1expr=NULL, nodata2expr=NULL, nodatanodataval=NULL - Expression version - Returns a one-band raster given one or two input rasters, band indexes and one or more user-specified SQL expressions.';

alter function st_mapalgebra(raster, raster, text, text, text, text, text, double precision) owner to postgres;

create function _st_convertarray4ma(value double precision[]) returns double precision[]
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
_value double precision[][][];
		x int;
		y int;
BEGIN
		IF array_ndims(value) != 2 THEN
			RAISE EXCEPTION 'Function parameter must be a 2-dimension array';
END IF;

_value := array_fill(NULL::double precision, ARRAY[1, array_length(value, 1), array_length(value, 2)]::int[], ARRAY[1, array_lower(value, 1), array_lower(value, 2)]::int[]);

		-- row
FOR y IN array_lower(value, 1)..array_upper(value, 1) LOOP
			-- column
			FOR x IN array_lower(value, 2)..array_upper(value, 2) LOOP
				_value[1][y][x] = value[y][x];
END LOOP;
END LOOP;

		RETURN _value;
END;
	$$;

alter function _st_convertarray4ma(double precision[]) owner to postgres;

create function st_max4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_value double precision[][][];
max double precision;
		x int;
		y int;
		z int;
		ndims int;
BEGIN
max := '-Infinity'::double precision;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		-- raster
FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
ELSE
							CONTINUE;
END IF;
END IF;

					IF _value[z][y][x] > max THEN
						max := _value[z][y][x];
END IF;
END LOOP;
END LOOP;
END LOOP;

		IF max = '-Infinity'::double precision THEN
			RETURN NULL;
END IF;

RETURN max;
END;
	$$;

comment on function st_max4ma(double precision[], integer[], text[]) is 'args: value, pos, VARIADIC userargs - Raster processing function that calculates the maximum pixel value in a neighborhood.';

alter function st_max4ma(double precision[], integer[], text[]) owner to postgres;

create function st_min4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_value double precision[][][];
min double precision;
		x int;
		y int;
		z int;
		ndims int;
BEGIN
min := 'Infinity'::double precision;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		-- raster
FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
ELSE
							CONTINUE;
END IF;
END IF;

					IF _value[z][y][x] < min THEN
						min := _value[z][y][x];
END IF;
END LOOP;
END LOOP;
END LOOP;

		IF min = 'Infinity'::double precision THEN
			RETURN NULL;
END IF;

RETURN min;
END;
	$$;

comment on function st_min4ma(double precision[], integer[], text[]) is 'args: value, pos, VARIADIC userargs - Raster processing function that calculates the minimum pixel value in a neighborhood.';

alter function st_min4ma(double precision[], integer[], text[]) owner to postgres;

create function st_sum4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_value double precision[][][];
sum double precision;
		x int;
		y int;
		z int;
		ndims int;
BEGIN
sum := 0;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		-- raster
FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
ELSE
							CONTINUE;
END IF;
END IF;

sum := sum + _value[z][y][x];
END LOOP;
END LOOP;
END LOOP;

RETURN sum;
END;
	$$;

comment on function st_sum4ma(double precision[], integer[], text[]) is 'args: value, pos, VARIADIC userargs - Raster processing function that calculates the sum of all pixel values in a neighborhood.';

alter function st_sum4ma(double precision[], integer[], text[]) owner to postgres;

create function st_mean4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_value double precision[][][];
sum double precision;
count int;
		x int;
		y int;
		z int;
		ndims int;
BEGIN
sum := 0;
count := 0;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		-- raster
FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
ELSE
							CONTINUE;
END IF;
END IF;

sum := sum + _value[z][y][x];
count := count + 1;
END LOOP;
END LOOP;
END LOOP;

		IF count < 1 THEN
			RETURN NULL;
END IF;

RETURN sum / count::double precision;
END;
	$$;

comment on function st_mean4ma(double precision[], integer[], text[]) is 'args: value, pos, VARIADIC userargs - Raster processing function that calculates the mean pixel value in a neighborhood.';

alter function st_mean4ma(double precision[], integer[], text[]) owner to postgres;

create function st_range4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_value double precision[][][];
min double precision;
max double precision;
		x int;
		y int;
		z int;
		ndims int;
BEGIN
min := 'Infinity'::double precision;
max := '-Infinity'::double precision;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		-- raster
FOR z IN array_lower(_value, 1)..array_upper(_value, 1) LOOP
			-- row
			FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
				-- column
				FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
					IF _value[z][y][x] IS NULL THEN
						IF array_length(userargs, 1) > 0 THEN
							_value[z][y][x] = userargs[array_lower(userargs, 1)]::double precision;
ELSE
							CONTINUE;
END IF;
END IF;

					IF _value[z][y][x] < min THEN
						min := _value[z][y][x];
END IF;
					IF _value[z][y][x] > max THEN
						max := _value[z][y][x];
END IF;
END LOOP;
END LOOP;
END LOOP;

		IF max = '-Infinity'::double precision OR min = 'Infinity'::double precision THEN
			RETURN NULL;
END IF;

RETURN max - min;
END;
	$$;

comment on function st_range4ma(double precision[], integer[], text[]) is 'args: value, pos, VARIADIC userargs - Raster processing function that calculates the range of pixel values in a neighborhood.';

alter function st_range4ma(double precision[], integer[], text[]) owner to postgres;

create function st_distinct4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language sql
as
$$ SELECT COUNT(DISTINCT unnest)::double precision FROM unnest($1) $$;

comment on function st_distinct4ma(double precision[], integer[], text[]) is 'args: value, pos, VARIADIC userargs - Raster processing function that calculates the number of unique pixel values in a neighborhood.';

alter function st_distinct4ma(double precision[], integer[], text[]) owner to postgres;

create function st_stddev4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language sql
as
$$ SELECT stddev(unnest) FROM unnest($1) $$;

comment on function st_stddev4ma(double precision[], integer[], text[]) is 'args: value, pos, VARIADIC userargs - Raster processing function that calculates the standard deviation of pixel values in a neighborhood.';

alter function st_stddev4ma(double precision[], integer[], text[]) owner to postgres;

create function st_invdistweight4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_value double precision[][][];
		ndims int;

		k double precision DEFAULT 1.;
		_k double precision DEFAULT 1.;
		z double precision[];
		d double precision[];
		_d double precision;
		z0 double precision;

		_z integer;
		x integer;
		y integer;

		cx integer;
		cy integer;
		cv double precision;
		cw double precision DEFAULT NULL;

		w integer;
		h integer;
		max_dx double precision;
		max_dy double precision;
BEGIN
--		RAISE NOTICE 'value = %', value;
--		RAISE NOTICE 'userargs = %', userargs;

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
END IF;
_z := array_lower(_value, 1);

		-- width and height (0-based)
		h := array_upper(_value, 2) - array_lower(_value, 2);
		w := array_upper(_value, 3) - array_lower(_value, 3);

		-- max distance from center pixel
		max_dx := w / 2;
		max_dy := h / 2;
--		RAISE NOTICE 'max_dx, max_dy = %, %', max_dx, max_dy;

		-- correct width and height (1-based)
		w := w + 1;
		h := h + 1;
--		RAISE NOTICE 'w, h = %, %', w, h;

		-- width and height should be odd numbers
		IF w % 2. != 1 THEN
			RAISE EXCEPTION 'Width of neighborhood array does not permit for a center pixel';
END IF;
		IF h % 2. != 1 THEN
			RAISE EXCEPTION 'Height of neighborhood array does not permit for a center pixel';
END IF;

		-- center pixel's coordinates
		cy := max_dy + array_lower(_value, 2);
		cx := max_dx + array_lower(_value, 3);
--		RAISE NOTICE 'cx, cy = %, %', cx, cy;

		-- if userargs provided, only use the first two args
		IF userargs IS NOT NULL AND array_ndims(userargs) = 1 THEN
			-- first arg is power factor
			k := userargs[array_lower(userargs, 1)]::double precision;
			IF k IS NULL THEN
				k := _k;
			ELSEIF k < 0. THEN
				RAISE NOTICE 'Power factor (< 0) must be between 0 and 1.  Defaulting to 0';
				k := 0.;
			ELSEIF k > 1. THEN
				RAISE NOTICE 'Power factor (> 1) must be between 0 and 1.  Defaulting to 1';
				k := 1.;
END IF;

			-- second arg is what to do if center pixel has a value
			-- this will be a weight to apply for the center pixel
			IF array_length(userargs, 1) > 1 THEN
				cw := abs(userargs[array_lower(userargs, 1) + 1]::double precision);
				IF cw IS NOT NULL THEN
					IF cw < 0. THEN
						RAISE NOTICE 'Weight (< 0) of center pixel value must be between 0 and 1.  Defaulting to 0';
						cw := 0.;
					ELSEIF cw > 1 THEN
						RAISE NOTICE 'Weight (> 1) of center pixel value must be between 0 and 1.  Defaulting to 1';
						cw := 1.;
END IF;
END IF;
END IF;
END IF;
--		RAISE NOTICE 'k = %', k;
		k = abs(k) * -1;

		-- center pixel value
		cv := _value[_z][cy][cx];

		-- check to see if center pixel has value
--		RAISE NOTICE 'cw = %', cw;
		IF cw IS NULL AND cv IS NOT NULL THEN
			RETURN cv;
END IF;

FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
			FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP
--				RAISE NOTICE 'value[%][%][%] = %', _z, y, x, _value[_z][y][x];

				-- skip NODATA values and center pixel
				IF _value[_z][y][x] IS NULL OR (x = cx AND y = cy) THEN
					CONTINUE;
END IF;

				z := z || _value[_z][y][x];

				-- use pythagorean theorem
_d := sqrt(power(cx - x, 2) + power(cy - y, 2));
--				RAISE NOTICE 'distance = %', _d;

				d := d || _d;
END LOOP;
END LOOP;
--		RAISE NOTICE 'z = %', z;
--		RAISE NOTICE 'd = %', d;

		-- neighborhood is NODATA
		IF z IS NULL OR array_length(z, 1) < 1 THEN
			-- center pixel has value
			IF cv IS NOT NULL THEN
				RETURN cv;
ELSE
				RETURN NULL;
END IF;
END IF;

		z0 := 0;
_d := 0;
FOR x IN array_lower(z, 1)..array_upper(z, 1) LOOP
			d[x] := power(d[x], k);
			z[x] := z[x] * d[x];
_d := _d + d[x];
			z0 := z0 + z[x];
END LOOP;
		z0 := z0 / _d;
--		RAISE NOTICE 'z0 = %', z0;

		-- apply weight for center pixel if center pixel has value
		IF cv IS NOT NULL THEN
			z0 := (cw * cv) + ((1 - cw) * z0);
--			RAISE NOTICE '*z0 = %', z0;
END IF;

RETURN z0;
END;
	$$;

comment on function st_invdistweight4ma(double precision[], integer[], text[]) is 'args: value, pos, VARIADIC userargs - Raster processing function that interpolates a pixels value from the pixels neighborhood.';

alter function st_invdistweight4ma(double precision[], integer[], text[]) owner to postgres;

create function st_mindist4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_value double precision[][][];
		ndims int;

		d double precision DEFAULT NULL;
		_d double precision;

		z integer;
		x integer;
		y integer;

		cx integer;
		cy integer;
		cv double precision;

		w integer;
		h integer;
		max_dx double precision;
		max_dy double precision;
BEGIN

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
END IF;
		z := array_lower(_value, 1);

		-- width and height (0-based)
		h := array_upper(_value, 2) - array_lower(_value, 2);
		w := array_upper(_value, 3) - array_lower(_value, 3);

		-- max distance from center pixel
		max_dx := w / 2;
		max_dy := h / 2;

		-- correct width and height (1-based)
		w := w + 1;
		h := h + 1;

		-- width and height should be odd numbers
		IF w % 2. != 1 THEN
			RAISE EXCEPTION 'Width of neighborhood array does not permit for a center pixel';
END IF;
		IF h % 2. != 1 THEN
			RAISE EXCEPTION 'Height of neighborhood array does not permit for a center pixel';
END IF;

		-- center pixel's coordinates
		cy := max_dy + array_lower(_value, 2);
		cx := max_dx + array_lower(_value, 3);

		-- center pixel value
		cv := _value[z][cy][cx];

		-- check to see if center pixel has value
		IF cv IS NOT NULL THEN
			RETURN 0.;
END IF;

FOR y IN array_lower(_value, 2)..array_upper(_value, 2) LOOP
			FOR x IN array_lower(_value, 3)..array_upper(_value, 3) LOOP

				-- skip NODATA values and center pixel
				IF _value[z][y][x] IS NULL OR (x = cx AND y = cy) THEN
					CONTINUE;
END IF;

				-- use pythagorean theorem
_d := sqrt(power(cx - x, 2) + power(cy - y, 2));
--				RAISE NOTICE 'distance = %', _d;

				IF d IS NULL OR _d < d THEN
					d := _d;
END IF;
END LOOP;
END LOOP;
--		RAISE NOTICE 'd = %', d;

RETURN d;
END;
	$$;

comment on function st_mindist4ma(double precision[], integer[], text[]) is 'args: value, pos, VARIADIC userargs - Raster processing function that returns the minimum distance (in number of pixels) between the pixel of interest and a neighboring pixel with value.';

alter function st_mindist4ma(double precision[], integer[], text[]) owner to postgres;

create function _st_slope4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
x integer;
		y integer;
		z integer;

		_pixwidth double precision;
		_pixheight double precision;
		_width double precision;
		_height double precision;
		_units text;
		_scale double precision;

		dz_dx double precision;
		dz_dy double precision;

		slope double precision;

		_value double precision[][][];
		ndims int;
BEGIN

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
END IF;
		z := array_lower(_value, 1);

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
END IF;

		IF array_length(userargs, 1) < 6 THEN
			RAISE EXCEPTION 'At least six elements must be provided for the third parameter';
END IF;

_pixwidth := userargs[1]::double precision;
_pixheight := userargs[2]::double precision;
_width := userargs[3]::double precision;
_height := userargs[4]::double precision;
_units := userargs[5];
_scale := userargs[6]::double precision;


		-- check that center pixel isn't NODATA
		IF _value[z][2][2] IS NULL THEN
			RETURN NULL;
		-- substitute center pixel for any neighbor pixels that are NODATA
ELSE
			FOR y IN 1..3 LOOP
				FOR x IN 1..3 LOOP
					IF _value[z][y][x] IS NULL THEN
						_value[z][y][x] = _value[z][2][2];
END IF;
END LOOP;
END LOOP;
END IF;

		dz_dy := ((_value[z][3][1] + _value[z][3][2] + _value[z][3][2] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][1][2] + _value[z][1][2] + _value[z][1][3])) / _pixheight;
		dz_dx := ((_value[z][1][3] + _value[z][2][3] + _value[z][2][3] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][2][1] + _value[z][2][1] + _value[z][3][1])) / _pixwidth;

		slope := sqrt(dz_dx * dz_dx + dz_dy * dz_dy) / (8 * _scale);

		-- output depends on user preference
CASE substring(upper(trim(leading from _units)) for 3)
			-- percentages
			WHEN 'PER' THEN
				slope := 100.0 * slope;
			-- radians
WHEN 'rad' THEN
				slope := atan(slope);
			-- degrees (default)
ELSE
				slope := degrees(atan(slope));
END CASE;

RETURN slope;
END;
	$$;

alter function _st_slope4ma(double precision[], integer[], text[]) owner to postgres;

create function st_slope(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, units text DEFAULT 'DEGREES'::text, scale double precision DEFAULT 1.0, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_rast public.raster;
		_nband integer;
		_pixtype text;
		_pixwidth double precision;
		_pixheight double precision;
		_width integer;
		_height integer;
		_customextent public.raster;
		_extenttype text;
BEGIN
_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
ELSE
			_extenttype := 'CUSTOM';
END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := public.ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'public.st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
_nband := 1;
_pixtype := NULL;
ELSE
			_rast := rast;
_nband := nband;
_pixtype := pixeltype;
END IF;

		-- get properties
_pixwidth := public.ST_PixelWidth(_rast);
_pixheight := public.ST_PixelHeight(_rast);
SELECT width, height INTO _width, _height FROM public.ST_Metadata(_rast);

RETURN public.ST_MapAlgebra(
        ARRAY[ROW(_rast, _nband)]::rastbandarg[],
        ' public._ST_slope4ma(double precision[][][], integer[][], text[])'::regprocedure,
        _pixtype,
        _extenttype, _customextent,
        1, 1,
        _pixwidth::text, _pixheight::text,
        _width::text, _height::text,
        units::text, scale::text
    );
END;
	$$;

comment on function st_slope(raster, integer, raster, text, text, double precision, boolean) is 'args: rast, nband, customextent, pixeltype=32BF, units=DEGREES, scale=1.0, interpolate_nodata=FALSE - Returns the slope (in degrees by default) of an elevation raster band. Useful for analyzing terrain.';

alter function st_slope(raster, integer, raster, text, text, double precision, boolean) owner to postgres;

create function st_slope(rast raster, nband integer DEFAULT 1, pixeltype text DEFAULT '32BF'::text, units text DEFAULT 'DEGREES'::text, scale double precision DEFAULT 1.0, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_slope($1, $2, NULL::public.raster, $3, $4, $5, $6) $$;

comment on function st_slope(raster, integer, text, text, double precision, boolean) is 'args: rast, nband=1, pixeltype=32BF, units=DEGREES, scale=1.0, interpolate_nodata=FALSE - Returns the slope (in degrees by default) of an elevation raster band. Useful for analyzing terrain.';

alter function st_slope(raster, integer, text, text, double precision, boolean) owner to postgres;

create function _st_aspect4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
x integer;
		y integer;
		z integer;

		_width double precision;
		_height double precision;
		_units text;

		dz_dx double precision;
		dz_dy double precision;
		aspect double precision;
		halfpi double precision;

		_value double precision[][][];
		ndims int;
BEGIN
		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
END IF;

		IF array_length(userargs, 1) < 3 THEN
			RAISE EXCEPTION 'At least three elements must be provided for the third parameter';
END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
END IF;
		z := array_lower(_value, 1);

_width := userargs[1]::double precision;
_height := userargs[2]::double precision;
_units := userargs[3];


		-- check that center pixel isn't NODATA
		IF _value[z][2][2] IS NULL THEN
			RETURN NULL;
		-- substitute center pixel for any neighbor pixels that are NODATA
ELSE
			FOR y IN 1..3 LOOP
				FOR x IN 1..3 LOOP
					IF _value[z][y][x] IS NULL THEN
						_value[z][y][x] = _value[z][2][2];
END IF;
END LOOP;
END LOOP;
END IF;

		dz_dy := ((_value[z][3][1] + _value[z][3][2] + _value[z][3][2] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][1][2] + _value[z][1][2] + _value[z][1][3]));
		dz_dx := ((_value[z][1][3] + _value[z][2][3] + _value[z][2][3] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][2][1] + _value[z][2][1] + _value[z][3][1]));

		-- aspect is flat
		IF abs(dz_dx) = 0::double precision AND abs(dz_dy) = 0::double precision THEN
			RETURN -1;
END IF;

		-- aspect is in radians
		aspect := atan2(dz_dy, -dz_dx);

		-- north = 0, pi/2 = east, 3pi/2 = west
		halfpi := pi() / 2.0;
		IF aspect > halfpi THEN
			aspect := (5.0 * halfpi) - aspect;
ELSE
			aspect := halfpi - aspect;
END IF;

		IF aspect = 2 * pi() THEN
			aspect := 0.;
END IF;

		-- output depends on user preference
CASE substring(upper(trim(leading from _units)) for 3)
			-- radians
			WHEN 'rad' THEN
				RETURN aspect;
			-- degrees (default)
ELSE
				RETURN degrees(aspect);
END CASE;

END;
	$$;

alter function _st_aspect4ma(double precision[], integer[], text[]) owner to postgres;

create function st_aspect(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, units text DEFAULT 'DEGREES'::text, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_rast public.raster;
		_nband integer;
		_pixtype text;
		_width integer;
		_height integer;
		_customextent public.raster;
		_extenttype text;
BEGIN
_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
ELSE
			_extenttype := 'CUSTOM';
END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := public.ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'public.st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
_nband := 1;
_pixtype := NULL;
ELSE
			_rast := rast;
_nband := nband;
_pixtype := pixeltype;
END IF;

		-- get properties
SELECT width, height INTO _width, _height FROM public.ST_Metadata(_rast);

RETURN public.ST_MapAlgebra(
        ARRAY[ROW(_rast, _nband)]::rastbandarg[],
        ' public._ST_aspect4ma(double precision[][][], integer[][], text[])'::regprocedure,
        _pixtype,
        _extenttype, _customextent,
        1, 1,
        _width::text, _height::text,
        units::text
    );
END;
	$$;

comment on function st_aspect(raster, integer, raster, text, text, boolean) is 'args: rast, band, customextent, pixeltype=32BF, units=DEGREES, interpolate_nodata=FALSE - Returns the aspect (in degrees by default) of an elevation raster band. Useful for analyzing terrain.';

alter function st_aspect(raster, integer, raster, text, text, boolean) owner to postgres;

create function st_aspect(rast raster, nband integer DEFAULT 1, pixeltype text DEFAULT '32BF'::text, units text DEFAULT 'DEGREES'::text, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_aspect($1, $2, NULL::public.raster, $3, $4, $5) $$;

comment on function st_aspect(raster, integer, text, text, boolean) is 'args: rast, band=1, pixeltype=32BF, units=DEGREES, interpolate_nodata=FALSE - Returns the aspect (in degrees by default) of an elevation raster band. Useful for analyzing terrain.';

alter function st_aspect(raster, integer, text, text, boolean) owner to postgres;

create function _st_hillshade4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_pixwidth double precision;
		_pixheight double precision;
		_width double precision;
		_height double precision;
		_azimuth double precision;
		_altitude double precision;
		_bright double precision;
		_scale double precision;

		dz_dx double precision;
		dz_dy double precision;
		azimuth double precision;
		zenith double precision;
		slope double precision;
		aspect double precision;
		shade double precision;

		_value double precision[][][];
		ndims int;
		z int;
BEGIN
		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
END IF;

		IF array_length(userargs, 1) < 8 THEN
			RAISE EXCEPTION 'At least eight elements must be provided for the third parameter';
END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
END IF;
		z := array_lower(_value, 1);

_pixwidth := userargs[1]::double precision;
_pixheight := userargs[2]::double precision;
_width := userargs[3]::double precision;
_height := userargs[4]::double precision;
_azimuth := userargs[5]::double precision;
_altitude := userargs[6]::double precision;
_bright := userargs[7]::double precision;
_scale := userargs[8]::double precision;

		-- check that pixel is not edge pixel
		IF (pos[1][1] = 1 OR pos[1][2] = 1) OR (pos[1][1] = _width OR pos[1][2] = _height) THEN
			RETURN NULL;
END IF;

		-- clamp azimuth
		IF _azimuth < 0. THEN
			RAISE NOTICE 'Clamping provided azimuth value % to 0', _azimuth;
_azimuth := 0.;
		ELSEIF _azimuth >= 360. THEN
			RAISE NOTICE 'Converting provided azimuth value % to be between 0 and 360', _azimuth;
_azimuth := _azimuth - (360. * floor(_azimuth / 360.));
END IF;
		azimuth := 360. - _azimuth + 90.;
		IF azimuth >= 360. THEN
			azimuth := azimuth - 360.;
END IF;
		azimuth := radians(azimuth);
		--RAISE NOTICE 'azimuth = %', azimuth;

		-- clamp altitude
		IF _altitude < 0. THEN
			RAISE NOTICE 'Clamping provided altitude value % to 0', _altitude;
_altitude := 0.;
		ELSEIF _altitude > 90. THEN
			RAISE NOTICE 'Clamping provided altitude value % to 90', _altitude;
_altitude := 90.;
END IF;
		zenith := radians(90. - _altitude);
		--RAISE NOTICE 'zenith = %', zenith;

		-- clamp bright
		IF _bright < 0. THEN
			RAISE NOTICE 'Clamping provided bright value % to 0', _bright;
_bright := 0.;
		ELSEIF _bright > 255. THEN
			RAISE NOTICE 'Clamping provided bright value % to 255', _bright;
_bright := 255.;
END IF;

		dz_dy := ((_value[z][3][1] + _value[z][3][2] + _value[z][3][2] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][1][2] + _value[z][1][2] + _value[z][1][3])) / (8 * _pixheight);
		dz_dx := ((_value[z][1][3] + _value[z][2][3] + _value[z][2][3] + _value[z][3][3]) -
			(_value[z][1][1] + _value[z][2][1] + _value[z][2][1] + _value[z][3][1])) / (8 * _pixwidth);

		slope := atan(sqrt(dz_dx * dz_dx + dz_dy * dz_dy) / _scale);

		IF dz_dx != 0. THEN
			aspect := atan2(dz_dy, -dz_dx);

			IF aspect < 0. THEN
				aspect := aspect + (2.0 * pi());
END IF;
ELSE
			IF dz_dy > 0. THEN
				aspect := pi() / 2.;
			ELSEIF dz_dy < 0. THEN
				aspect := (2. * pi()) - (pi() / 2.);
			-- set to pi as that is the expected PostgreSQL answer in Linux
ELSE
				aspect := pi();
END IF;
END IF;

		shade := _bright * ((cos(zenith) * cos(slope)) + (sin(zenith) * sin(slope) * cos(azimuth - aspect)));

		IF shade < 0. THEN
			shade := 0;
END IF;

RETURN shade;
END;
	$$;

alter function _st_hillshade4ma(double precision[], integer[], text[]) owner to postgres;

create function st_hillshade(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, azimuth double precision DEFAULT 315.0, altitude double precision DEFAULT 45.0, max_bright double precision DEFAULT 255.0, scale double precision DEFAULT 1.0, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_rast public.raster;
		_nband integer;
		_pixtype text;
		_pixwidth double precision;
		_pixheight double precision;
		_width integer;
		_height integer;
		_customextent public.raster;
		_extenttype text;
BEGIN
_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
ELSE
			_extenttype := 'CUSTOM';
END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := public.ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'public.st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
_nband := 1;
_pixtype := NULL;
ELSE
			_rast := rast;
_nband := nband;
_pixtype := pixeltype;
END IF;

		-- get properties
_pixwidth := public.ST_PixelWidth(_rast);
_pixheight := public.ST_PixelHeight(_rast);
SELECT width, height, scalex INTO _width, _height FROM public.ST_Metadata(_rast);

RETURN public.ST_MapAlgebra(
        ARRAY[ROW(_rast, _nband)]::rastbandarg[],
        ' public._ST_hillshade4ma(double precision[][][], integer[][], text[])'::regprocedure,
        _pixtype,
        _extenttype, _customextent,
        1, 1,
        _pixwidth::text, _pixheight::text,
        _width::text, _height::text,
        $5::text, $6::text,
        $7::text, $8::text
    );
END;
	$$;

comment on function st_hillshade(raster, integer, raster, text, double precision, double precision, double precision, double precision, boolean) is 'args: rast, band, customextent, pixeltype=32BF, azimuth=315, altitude=45, max_bright=255, scale=1.0, interpolate_nodata=FALSE - Returns the hypothetical illumination of an elevation raster band using provided azimuth, altitude, brightness and scale inputs.';

alter function st_hillshade(raster, integer, raster, text, double precision, double precision, double precision, double precision, boolean) owner to postgres;

create function st_hillshade(rast raster, nband integer DEFAULT 1, pixeltype text DEFAULT '32BF'::text, azimuth double precision DEFAULT 315.0, altitude double precision DEFAULT 45.0, max_bright double precision DEFAULT 255.0, scale double precision DEFAULT 1.0, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_hillshade($1, $2, NULL::public.raster, $3, $4, $5, $6, $7, $8) $$;

comment on function st_hillshade(raster, integer, text, double precision, double precision, double precision, double precision, boolean) is 'args: rast, band=1, pixeltype=32BF, azimuth=315, altitude=45, max_bright=255, scale=1.0, interpolate_nodata=FALSE - Returns the hypothetical illumination of an elevation raster band using provided azimuth, altitude, brightness and scale inputs.';

alter function st_hillshade(raster, integer, text, double precision, double precision, double precision, double precision, boolean) owner to postgres;

create function _st_tpi4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
x integer;
		y integer;
		z integer;

		Z1 double precision;
		Z2 double precision;
		Z3 double precision;
		Z4 double precision;
		Z5 double precision;
		Z6 double precision;
		Z7 double precision;
		Z8 double precision;
		Z9 double precision;

		tpi double precision;
		mean double precision;
		_value double precision[][][];
		ndims int;
BEGIN
		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
END IF;
		z := array_lower(_value, 1);

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
END IF;

		-- check that center pixel isn't NODATA
		IF _value[z][2][2] IS NULL THEN
			RETURN NULL;
		-- substitute center pixel for any neighbor pixels that are NODATA
ELSE
			FOR y IN 1..3 LOOP
				FOR x IN 1..3 LOOP
					IF _value[z][y][x] IS NULL THEN
						_value[z][y][x] = _value[z][2][2];
END IF;
END LOOP;
END LOOP;
END IF;

		-------------------------------------------------
		--|   Z1= Z(-1,1) |  Z2= Z(0,1)	| Z3= Z(1,1)  |--
		-------------------------------------------------
		--|   Z4= Z(-1,0) |  Z5= Z(0,0) | Z6= Z(1,0)  |--
		-------------------------------------------------
		--|   Z7= Z(-1,-1)|  Z8= Z(0,-1)|  Z9= Z(1,-1)|--
		-------------------------------------------------

		Z1 := _value[z][1][1];
		Z2 := _value[z][2][1];
		Z3 := _value[z][3][1];
		Z4 := _value[z][1][2];
		Z5 := _value[z][2][2];
		Z6 := _value[z][3][2];
		Z7 := _value[z][1][3];
		Z8 := _value[z][2][3];
		Z9 := _value[z][3][3];

		mean := (Z1 + Z2 + Z3 + Z4 + Z6 + Z7 + Z8 + Z9)/8;
		tpi := Z5-mean;

return tpi;
END;
	$$;

alter function _st_tpi4ma(double precision[], integer[], text[]) owner to postgres;

create function st_tpi(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_rast public.raster;
		_nband integer;
		_pixtype text;
		_pixwidth double precision;
		_pixheight double precision;
		_width integer;
		_height integer;
		_customextent public.raster;
		_extenttype text;
BEGIN
_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
ELSE
			_extenttype := 'CUSTOM';
END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := public.ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'public.st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
_nband := 1;
_pixtype := NULL;
ELSE
			_rast := rast;
_nband := nband;
_pixtype := pixeltype;
END IF;

		-- get properties
_pixwidth := public.ST_PixelWidth(_rast);
_pixheight := public.ST_PixelHeight(_rast);
SELECT width, height INTO _width, _height FROM public.ST_Metadata(_rast);

RETURN public.ST_MapAlgebra(
        ARRAY[ROW(_rast, _nband)]::rastbandarg[],
        ' public._ST_tpi4ma(double precision[][][], integer[][], text[])'::regprocedure,
        _pixtype,
        _extenttype, _customextent,
        1, 1);
END;
	$$;

comment on function st_tpi(raster, integer, raster, text, boolean) is 'args: rast, nband, customextent, pixeltype="32BF", interpolate_nodata=FALSE - Returns a raster with the calculated Topographic Position Index.';

alter function st_tpi(raster, integer, raster, text, boolean) owner to postgres;

create function st_tpi(rast raster, nband integer DEFAULT 1, pixeltype text DEFAULT '32BF'::text, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_tpi($1, $2, NULL::public.raster, $3, $4) $$;

alter function st_tpi(raster, integer, text, boolean) owner to postgres;

create function _st_roughness4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
x integer;
		y integer;
		z integer;

		minimum double precision;
		maximum double precision;

		_value double precision[][][];
		ndims int;
BEGIN

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
END IF;
		z := array_lower(_value, 1);

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
END IF;

		-- check that center pixel isn't NODATA
		IF _value[z][2][2] IS NULL THEN
			RETURN NULL;
		-- substitute center pixel for any neighbor pixels that are NODATA
ELSE
			FOR y IN 1..3 LOOP
				FOR x IN 1..3 LOOP
					IF _value[z][y][x] IS NULL THEN
						_value[z][y][x] = _value[z][2][2];
END IF;
END LOOP;
END LOOP;
END IF;

		minimum := _value[z][1][1];
		maximum := _value[z][1][1];

FOR Y IN 1..3 LOOP
		    FOR X IN 1..3 LOOP
		    	 IF _value[z][y][x] < minimum THEN
			    minimum := _value[z][y][x];
			 ELSIF _value[z][y][x] > maximum THEN
			    maximum := _value[z][y][x];
END IF;
END LOOP;
END LOOP;

RETURN maximum - minimum;
END;
	$$;

alter function _st_roughness4ma(double precision[], integer[], text[]) owner to postgres;

create function st_roughness(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_rast public.raster;
		_nband integer;
		_pixtype text;
		_pixwidth double precision;
		_pixheight double precision;
		_width integer;
		_height integer;
		_customextent public.raster;
		_extenttype text;
BEGIN
_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
ELSE
			_extenttype := 'CUSTOM';
END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := public.ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'public.st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
_nband := 1;
_pixtype := NULL;
ELSE
			_rast := rast;
_nband := nband;
_pixtype := pixeltype;
END IF;

RETURN public.ST_MapAlgebra(
        ARRAY[ROW(_rast, _nband)]::rastbandarg[],
        ' public._ST_roughness4ma(double precision[][][], integer[][], text[])'::regprocedure,
        _pixtype,
        _extenttype, _customextent,
        1, 1);
END;
	$$;

comment on function st_roughness(raster, integer, raster, text, boolean) is 'args: rast, nband, customextent, pixeltype="32BF", interpolate_nodata=FALSE - Returns a raster with the calculated "roughness" of a DEM.';

alter function st_roughness(raster, integer, raster, text, boolean) owner to postgres;

create function st_roughness(rast raster, nband integer DEFAULT 1, pixeltype text DEFAULT '32BF'::text, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_roughness($1, $2, NULL::public.raster, $3, $4) $$;

alter function st_roughness(raster, integer, text, boolean) owner to postgres;

create function _st_tri4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
x integer;
		y integer;
		z integer;

		Z1 double precision;
		Z2 double precision;
		Z3 double precision;
		Z4 double precision;
		Z5 double precision;
		Z6 double precision;
		Z7 double precision;
		Z8 double precision;
		Z9 double precision;

		tri double precision;
		_value double precision[][][];
		ndims int;
BEGIN
		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		-- only use the first raster passed to this function
		IF array_length(_value, 1) > 1 THEN
			RAISE NOTICE 'Only using the values from the first raster';
END IF;
		z := array_lower(_value, 1);

		IF (
			array_lower(_value, 2) != 1 OR array_upper(_value, 2) != 3 OR
			array_lower(_value, 3) != 1 OR array_upper(_value, 3) != 3
		) THEN
			RAISE EXCEPTION 'First parameter of function must be a 1x3x3 array with each of the lower bounds starting from 1';
END IF;

		-- check that center pixel isn't NODATA
		IF _value[z][2][2] IS NULL THEN
			RETURN NULL;
		-- substitute center pixel for any neighbor pixels that are NODATA
ELSE
			FOR y IN 1..3 LOOP
				FOR x IN 1..3 LOOP
					IF _value[z][y][x] IS NULL THEN
						_value[z][y][x] = _value[z][2][2];
END IF;
END LOOP;
END LOOP;
END IF;

		-------------------------------------------------
		--|   Z1= Z(-1,1) |  Z2= Z(0,1)	| Z3= Z(1,1)  |--
		-------------------------------------------------
		--|   Z4= Z(-1,0) |  Z5= Z(0,0) | Z6= Z(1,0)  |--
		-------------------------------------------------
		--|   Z7= Z(-1,-1)|  Z8= Z(0,-1)|  Z9= Z(1,-1)|--
		-------------------------------------------------

		-- _scale width and height units / z units to make z units equal to height width units
		Z1 := _value[z][1][1];
		Z2 := _value[z][2][1];
		Z3 := _value[z][3][1];
		Z4 := _value[z][1][2];
		Z5 := _value[z][2][2];
		Z6 := _value[z][3][2];
		Z7 := _value[z][1][3];
		Z8 := _value[z][2][3];
		Z9 := _value[z][3][3];

		tri := ( abs(Z1 - Z5 ) + abs( Z2 - Z5 ) + abs( Z3 - Z5 ) + abs( Z4 - Z5 ) + abs( Z6 - Z5 ) + abs( Z7 - Z5 ) + abs( Z8 - Z5 ) + abs ( Z9 - Z5 )) / 8;

return tri;
END;
	$$;

alter function _st_tri4ma(double precision[], integer[], text[]) owner to postgres;

create function st_tri(rast raster, nband integer, customextent raster, pixeltype text DEFAULT '32BF'::text, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
_rast public.raster;
		_nband integer;
		_pixtype text;
		_pixwidth double precision;
		_pixheight double precision;
		_width integer;
		_height integer;
		_customextent public.raster;
		_extenttype text;
BEGIN
_customextent := customextent;
		IF _customextent IS NULL THEN
			_extenttype := 'FIRST';
ELSE
			_extenttype := 'CUSTOM';
END IF;

		IF interpolate_nodata IS TRUE THEN
			_rast := public.ST_MapAlgebra(
				ARRAY[ROW(rast, nband)]::rastbandarg[],
				'public.st_invdistweight4ma(double precision[][][], integer[][], text[])'::regprocedure,
				pixeltype,
				'FIRST', NULL,
				1, 1
			);
_nband := 1;
_pixtype := NULL;
ELSE
			_rast := rast;
_nband := nband;
_pixtype := pixeltype;
END IF;

		-- get properties
_pixwidth := public.ST_PixelWidth(_rast);
_pixheight := public.ST_PixelHeight(_rast);
SELECT width, height INTO _width, _height FROM public.ST_Metadata(_rast);

RETURN public.ST_MapAlgebra(
        ARRAY[ROW(_rast, _nband)]::rastbandarg[],
        ' public._ST_tri4ma(double precision[][][], integer[][], text[])'::regprocedure,
        _pixtype,
        _extenttype, _customextent,
        1, 1);
END;
	$$;

comment on function st_tri(raster, integer, raster, text, boolean) is 'args: rast, nband, customextent, pixeltype="32BF", interpolate_nodata=FALSE - Returns a raster with the calculated Terrain Ruggedness Index.';

alter function st_tri(raster, integer, raster, text, boolean) owner to postgres;

create function st_tri(rast raster, nband integer DEFAULT 1, pixeltype text DEFAULT '32BF'::text, interpolate_nodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_tri($1, $2, NULL::public.raster, $3, $4) $$;

alter function st_tri(raster, integer, text, boolean) owner to postgres;

create function _st_grayscale4ma(value double precision[], pos integer[], VARIADIC userargs text[] DEFAULT NULL::text[]) returns double precision
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
ndims integer;
		_value double precision[][][];

		red double precision;
		green double precision;
		blue double precision;

		gray double precision;
BEGIN

		ndims := array_ndims(value);
		-- add a third dimension if 2-dimension
		IF ndims = 2 THEN
			_value := public._ST_convertarray4ma(value);
		ELSEIF ndims != 3 THEN
			RAISE EXCEPTION 'First parameter of function must be a 3-dimension array';
ELSE
			_value := value;
END IF;

		red := _value[1][1][1];
		green := _value[2][1][1];
		blue := _value[3][1][1];

		gray = round(0.2989 * red + 0.5870 * green + 0.1140 * blue);
RETURN gray;

END;
	$$;

alter function _st_grayscale4ma(double precision[], integer[], text[]) owner to postgres;

create function st_grayscale(rastbandargset rastbandarg[], extenttype text DEFAULT 'INTERSECTION'::text) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE

_NBANDS integer DEFAULT 3;
		_NODATA integer DEFAULT 255;
		_PIXTYPE text DEFAULT '8BUI';

		_set rastbandarg[];

		nrast integer;
		idx integer;
		rast public.raster;
		nband integer;

		stats summarystats;
		nodata double precision;
		nodataval integer;
		reclassexpr text;

BEGIN

		-- check for three rastbandarg
		nrast := array_length(rastbandargset, 1);
		IF nrast < _NBANDS THEN
			RAISE EXCEPTION '''rastbandargset'' must have three bands for red, green and blue';
		ELSIF nrast > _NBANDS THEN
			RAISE WARNING 'Only the first three elements of ''rastbandargset'' will be used';
_set := rastbandargset[1:3];
ELSE
			_set := rastbandargset;
END IF;

FOR idx IN 1.._NBANDS LOOP

			rast := _set[idx].rast;
			nband := _set[idx].nband;

			-- check that each raster has the specified band
			IF public.ST_HasNoBand(rast, nband) THEN

				RAISE EXCEPTION 'Band at index ''%'' not found for raster ''%''', nband, idx;

			-- check that each band is 8BUI. if not, reclassify to 8BUI
			ELSIF public.ST_BandPixelType(rast, nband) != _PIXTYPE THEN

				stats := public.ST_SummaryStats(rast, nband);
				nodata := public.ST_BandNoDataValue(rast, nband);

				IF nodata IS NOT NULL THEN
					nodataval := _NODATA;
					reclassexpr := concat(
						concat('[', nodata , '-', nodata, ']:', _NODATA, '-', _NODATA, ','),
						concat('[', stats.min , '-', stats.max , ']:0-', _NODATA - 1)
					);
ELSE
					nodataval := NULL;
					reclassexpr := concat('[', stats.min , '-', stats.max , ']:0-', _NODATA);
END IF;

_set[idx] := ROW(
					public.ST_Reclass(
						rast,
						ROW(nband, reclassexpr, _PIXTYPE, nodataval)::reclassarg
					),
					nband
				)::rastbandarg;

END IF;

END LOOP;

		-- call map algebra with _st_grayscale4ma
RETURN public.ST_MapAlgebra(
        _set,
        'public._ST_Grayscale4MA(double precision[][][], integer[][], text[])'::regprocedure,
        '8BUI',
        extenttype
    );

END;
	$$;

comment on function st_grayscale(rastbandarg[], text) is 'args: rastbandargset, extenttype=INTERSECTION - Creates a new one-8BUI band raster from the source raster and specified bands representing Red, Green and Blue';

alter function st_grayscale(rastbandarg[], text) owner to postgres;

create function st_grayscale(rast raster, redband integer DEFAULT 1, greenband integer DEFAULT 2, blueband integer DEFAULT 3, extenttype text DEFAULT 'INTERSECTION'::text) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
BEGIN

RETURN public.ST_Grayscale(
        ARRAY[
            ROW(rast, redband)::rastbandarg,
        ROW(rast, greenband)::rastbandarg,
        ROW(rast, blueband)::rastbandarg
			]::rastbandarg[],
        extenttype
    );

END;
	$$;

comment on function st_grayscale(raster, integer, integer, integer, text) is 'args: rast, redband=1, greenband=2, blueband=3, extenttype=INTERSECTION - Creates a new one-8BUI band raster from the source raster and specified bands representing Red, Green and Blue';

alter function st_grayscale(raster, integer, integer, integer, text) owner to postgres;

create function st_isempty(rast raster) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_isempty(raster) is 'args: rast - Returns true if the raster is empty (width = 0 and height = 0). Otherwise, returns false.';

alter function st_isempty(raster) owner to postgres;

create function st_hasnoband(rast raster, nband integer default 1) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_hasnoband(raster, integer) is 'args: rast, bandnum=1 - Returns true if there is no band with given band number. If no band number is specified, then band number 1 is assumed.';

alter function st_hasnoband(raster, integer) owner to postgres;

create function st_bandnodatavalue(rast raster, band integer default 1) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_bandnodatavalue(raster, integer) is 'args: rast, bandnum=1 - Returns the value in a given band that represents no data. If no band num 1 is assumed.';

alter function st_bandnodatavalue(raster, integer) owner to postgres;

create function st_bandisnodata(rast raster, band integer default 1, forcechecking boolean default false) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_bandisnodata(raster, integer, boolean) is 'args: rast, band, forceChecking=true - Returns true if the band is filled with only nodata values.';

alter function st_bandisnodata(raster, integer, boolean) owner to postgres;

create function st_bandisnodata(rast raster, forcechecking boolean) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_bandisnodata($1, 1, $2) $$;

comment on function st_bandisnodata(raster, boolean) is 'args: rast, forceChecking=true - Returns true if the band is filled with only nodata values.';

alter function st_bandisnodata(raster, boolean) owner to postgres;

create function st_bandpath(rast raster, band integer default 1) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_bandpath(raster, integer) is 'args: rast, bandnum=1 - Returns system file path to a band stored in file system. If no bandnum specified, 1 is assumed.';

alter function st_bandpath(raster, integer) owner to postgres;

create function st_bandpixeltype(rast raster, band integer default 1) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_bandpixeltype(raster, integer) is 'args: rast, bandnum=1 - Returns the type of pixel for given band. If no bandnum specified, 1 is assumed.';

alter function st_bandpixeltype(raster, integer) owner to postgres;

create function st_bandmetadata(rast raster, band integer[]) returns setof table("bandnum" integer, "pixeltype" text, "nodatavalue" double precision, "isoutdb" boolean, "path" text, "outdbbandnum" integer, "filesize" bigint, "filetimestamp" bigint)
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_bandmetadata(raster, integer[]) is 'args: rast, band - Returns basic meta data for a specific raster band. band num 1 is assumed if none-specified.';

alter function st_bandmetadata(raster, integer[]) owner to postgres;

create function st_bandmetadata(rast raster, band integer DEFAULT 1)
    returns TABLE(pixeltype text, nodatavalue double precision, isoutdb boolean, path text, outdbbandnum integer, filesize bigint, filetimestamp bigint)
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT pixeltype, nodatavalue, isoutdb, path, outdbbandnum, filesize, filetimestamp FROM public.ST_BandMetaData($1, ARRAY[$2]::int[]) LIMIT 1 $$;

comment on function st_bandmetadata(raster, integer) is 'args: rast, band=1 - Returns basic meta data for a specific raster band. band num 1 is assumed if none-specified.';

alter function st_bandmetadata(raster, integer) owner to postgres;

create function st_bandfilesize(rast raster, band integer default 1) returns bigint
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_bandfilesize(raster, integer) is 'args: rast, bandnum=1 - Returns the file size of a band stored in file system. If no bandnum specified, 1 is assumed.';

alter function st_bandfilesize(raster, integer) owner to postgres;

create function st_bandfiletimestamp(rast raster, band integer default 1) returns bigint
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_bandfiletimestamp(raster, integer) is 'args: rast, bandnum=1 - Returns the file timestamp of a band stored in file system. If no bandnum specified, 1 is assumed.';

alter function st_bandfiletimestamp(raster, integer) owner to postgres;

create function st_value(rast raster, band integer, x integer, y integer, exclude_nodata_value boolean default true) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_value(raster, integer, integer, integer, boolean) is 'args: rast, band, x, y, exclude_nodata_value=true - Returns the value of a given band in a given columnx, rowy pixel or at a particular geometric point. Band numbers start at 1 and assumed to be 1 if not specified. If exclude_nodata_value is set to false, then all pixels include nodata pixels are considered to intersect and return value. If exclude_nodata_value is not passed in then reads it from metadata of raster.';

alter function st_value(raster, integer, integer, integer, boolean) owner to postgres;

create function st_value(rast raster, band integer, pt geometry, exclude_nodata_value boolean default true, resample text default 'nearest'::text) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_value(raster, integer, geometry, boolean, text) is 'args: rast, band, pt, exclude_nodata_value=true, resample=''nearest'' - Returns the value of a given band in a given columnx, rowy pixel or at a particular geometric point. Band numbers start at 1 and assumed to be 1 if not specified. If exclude_nodata_value is set to false, then all pixels include nodata pixels are considered to intersect and return value. If exclude_nodata_value is not passed in then reads it from metadata of raster.';

alter function st_value(raster, integer, geometry, boolean, text) owner to postgres;

create function st_value(rast raster, x integer, y integer, exclude_nodata_value boolean DEFAULT true) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT st_value($1, 1::integer, $2, $3, $4) $$;

comment on function st_value(raster, integer, integer, boolean) is 'args: rast, x, y, exclude_nodata_value=true - Returns the value of a given band in a given columnx, rowy pixel or at a particular geometric point. Band numbers start at 1 and assumed to be 1 if not specified. If exclude_nodata_value is set to false, then all pixels include nodata pixels are considered to intersect and return value. If exclude_nodata_value is not passed in then reads it from metadata of raster.';

alter function st_value(raster, integer, integer, boolean) owner to postgres;

create function st_value(rast raster, pt geometry, exclude_nodata_value boolean DEFAULT true) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_value($1, 1::integer, $2, $3, 'nearest'::text) $$;

comment on function st_value(raster, geometry, boolean) is 'args: rast, pt, exclude_nodata_value=true - Returns the value of a given band in a given columnx, rowy pixel or at a particular geometric point. Band numbers start at 1 and assumed to be 1 if not specified. If exclude_nodata_value is set to false, then all pixels include nodata pixels are considered to intersect and return value. If exclude_nodata_value is not passed in then reads it from metadata of raster.';

alter function st_value(raster, geometry, boolean) owner to postgres;

create function st_setz(rast raster, geom geometry, resample text default 'nearest'::text, band integer default 1) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setz(raster, geometry, text, integer) is 'args: rast, geom, resample=nearest, band=1 - Returns a geometry with the same X/Y coordinates as the input geometry, and values from the raster copied into the Z dimension using the requested resample algorithm.';

alter function st_setz(raster, geometry, text, integer) owner to postgres;

create function st_setm(rast raster, geom geometry, resample text default 'nearest'::text, band integer default 1) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setm(raster, geometry, text, integer) is 'args: rast, geom, resample=nearest, band=1 - Returns a geometry with the same X/Y coordinates as the input geometry, and values from the raster copied into the Z dimension using the requested resample algorithm.';

alter function st_setm(raster, geometry, text, integer) owner to postgres;

create function st_pixelofvalue(rast raster, nband integer, search double precision[], exclude_nodata_value boolean default true) returns setof table("val" double precision, "x" integer, "y" integer)
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_pixelofvalue(raster, integer, double precision[], boolean) is 'args: rast, nband, search, exclude_nodata_value=true - Get the columnx, rowy coordinates of the pixel whose value equals the search value.';

alter function st_pixelofvalue(raster, integer, double precision[], boolean) owner to postgres;

create function st_pixelofvalue(rast raster, search double precision[], exclude_nodata_value boolean DEFAULT true)
    returns TABLE(val double precision, x integer, y integer)
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT val, x, y FROM public.ST_PixelOfValue($1, 1, $2, $3) $$;

comment on function st_pixelofvalue(raster, double precision[], boolean) is 'args: rast, search, exclude_nodata_value=true - Get the columnx, rowy coordinates of the pixel whose value equals the search value.';

alter function st_pixelofvalue(raster, double precision[], boolean) owner to postgres;

create function st_pixelofvalue(rast raster, nband integer, search double precision, exclude_nodata_value boolean DEFAULT true)
    returns TABLE(x integer, y integer)
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT x, y FROM public.ST_PixelofValue($1, $2, ARRAY[$3], $4) $$;

comment on function st_pixelofvalue(raster, integer, double precision, boolean) is 'args: rast, nband, search, exclude_nodata_value=true - Get the columnx, rowy coordinates of the pixel whose value equals the search value.';

alter function st_pixelofvalue(raster, integer, double precision, boolean) owner to postgres;

create function st_pixelofvalue(rast raster, search double precision, exclude_nodata_value boolean DEFAULT true)
    returns TABLE(x integer, y integer)
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT x, y FROM public.ST_PixelOfValue($1, 1, ARRAY[$2], $3) $$;

comment on function st_pixelofvalue(raster, double precision, boolean) is 'args: rast, search, exclude_nodata_value=true - Get the columnx, rowy coordinates of the pixel whose value equals the search value.';

alter function st_pixelofvalue(raster, double precision, boolean) owner to postgres;

create function st_georeference(rast raster, format text DEFAULT 'GDAL'::text) returns text
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
scale_x numeric;
				scale_y numeric;
				skew_x numeric;
				skew_y numeric;
				ul_x numeric;
				ul_y numeric;

        result text;
BEGIN
SELECT scalex::numeric, scaley::numeric, skewx::numeric, skewy::numeric, upperleftx::numeric, upperlefty::numeric
INTO scale_x, scale_y, skew_x, skew_y, ul_x, ul_y FROM public.ST_Metadata(rast);

-- scale x
result := trunc(scale_x, 10) || E'\n';

						-- skew y
            result := result || trunc(skew_y, 10) || E'\n';

						-- skew x
            result := result || trunc(skew_x, 10) || E'\n';

						-- scale y
            result := result || trunc(scale_y, 10) || E'\n';

        IF format = 'ESRI' THEN
						-- upper left x
            result := result || trunc((ul_x + scale_x * 0.5), 10) || E'\n';

						-- upper left y
            result = result || trunc((ul_y + scale_y * 0.5), 10) || E'\n';
ELSE -- IF format = 'GDAL' THEN
						-- upper left x
            result := result || trunc(ul_x, 10) || E'\n';

						-- upper left y
            result := result || trunc(ul_y, 10) || E'\n';
END IF;

RETURN result;
END;
    $$;

comment on function st_georeference(raster, text) is 'args: rast, format=GDAL - Returns the georeference meta data in GDAL or ESRI format as commonly seen in a world file. Default is GDAL.';

alter function st_georeference(raster, text) owner to postgres;

create function st_setscale(rast raster, scale double precision) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setscale(raster, double precision) is 'args: rast, xy - Sets the X and Y size of pixels in units of coordinate reference system. Number units/pixel width/height.';

alter function st_setscale(raster, double precision) owner to postgres;

create function st_setscale(rast raster, scalex double precision, scaley double precision) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setscale(raster, double precision, double precision) is 'args: rast, x, y - Sets the X and Y size of pixels in units of coordinate reference system. Number units/pixel width/height.';

alter function st_setscale(raster, double precision, double precision) owner to postgres;

create function st_setskew(rast raster, skew double precision) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setskew(raster, double precision) is 'args: rast, skewxy - Sets the georeference X and Y skew (or rotation parameter). If only one is passed in, sets X and Y to the same value.';

alter function st_setskew(raster, double precision) owner to postgres;

create function st_setskew(rast raster, skewx double precision, skewy double precision) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setskew(raster, double precision, double precision) is 'args: rast, skewx, skewy - Sets the georeference X and Y skew (or rotation parameter). If only one is passed in, sets X and Y to the same value.';

alter function st_setskew(raster, double precision, double precision) owner to postgres;

create function st_setsrid(rast raster, srid integer) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setsrid(raster, integer) is 'args: rast, srid - Sets the SRID of a raster to a particular integer srid defined in the spatial_ref_sys table.';

alter function st_setsrid(raster, integer) owner to postgres;

create function st_setupperleft(rast raster, upperleftx double precision, upperlefty double precision) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setupperleft(raster, double precision, double precision) is 'args: rast, x, y - Sets the value of the upper left corner of the pixel of the raster to projected X and Y coordinates.';

alter function st_setupperleft(raster, double precision, double precision) owner to postgres;

create function st_setrotation(rast raster, rotation double precision) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setrotation(raster, double precision) is 'args: rast, rotation - Set the rotation of the raster in radian.';

alter function st_setrotation(raster, double precision) owner to postgres;

create function st_setgeotransform(rast raster, imag double precision, jmag double precision, theta_i double precision, theta_ij double precision, xoffset double precision, yoffset double precision) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function st_setgeotransform(raster, double precision, double precision, double precision, double precision, double precision, double precision) owner to postgres;

create function st_setgeoreference(rast raster, georef text, format text DEFAULT 'GDAL'::text) returns raster
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
params text[];
        rastout public.raster;
BEGIN
        IF rast IS NULL THEN
            RAISE WARNING 'Cannot set georeferencing on a null raster in st_setgeoreference.';
RETURN rastout;
END IF;

SELECT regexp_matches(georef,
                      E'(-?\\d+(?:\\.\\d+)?)\\s(-?\\d+(?:\\.\\d+)?)\\s(-?\\d+(?:\\.\\d+)?)\\s' ||
            E'(-?\\d+(?:\\.\\d+)?)\\s(-?\\d+(?:\\.\\d+)?)\\s(-?\\d+(?:\\.\\d+)?)') INTO params;

IF NOT FOUND THEN
            RAISE EXCEPTION 'st_setgeoreference requires a string with 6 floating point values.';
END IF;

        IF format = 'ESRI' THEN
            -- params array is now:
            -- {scalex, skewy, skewx, scaley, upperleftx, upperlefty}
            rastout := public.ST_setscale(rast, params[1]::float8, params[4]::float8);
            rastout := public.ST_setskew(rastout, params[3]::float8, params[2]::float8);
            rastout := public.ST_setupperleft(rastout,
                                   params[5]::float8 - (params[1]::float8 * 0.5),
                                   params[6]::float8 - (params[4]::float8 * 0.5));
ELSE
            IF format != 'GDAL' THEN
                RAISE WARNING 'Format ''%'' is not recognized, defaulting to GDAL format.', format;
END IF;
            -- params array is now:
            -- {scalex, skewy, skewx, scaley, upperleftx, upperlefty}

            rastout := public.ST_setscale(rast, params[1]::float8, params[4]::float8);
            rastout := public.ST_setskew( rastout, params[3]::float8, params[2]::float8);
            rastout := public.ST_setupperleft(rastout, params[5]::float8, params[6]::float8);
END IF;
RETURN rastout;
END;
    $$;

comment on function st_setgeoreference(raster, text, text) is 'args: rast, georefcoords, format=GDAL - Set Georeference 6 georeference parameters in a single call. Numbers should be separated by white space. Accepts inputs in GDAL or ESRI format. Default is GDAL.';

alter function st_setgeoreference(raster, text, text) owner to postgres;

create function st_setgeoreference(rast raster, upperleftx double precision, upperlefty double precision, scalex double precision, scaley double precision, skewx double precision, skewy double precision) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_setgeoreference($1, array_to_string(ARRAY[$4, $7, $6, $5, $2, $3], ' ')) $$;

comment on function st_setgeoreference(raster, double precision, double precision, double precision, double precision, double precision, double precision) is 'args: rast, upperleftx, upperlefty, scalex, scaley, skewx, skewy - Set Georeference 6 georeference parameters in a single call. Numbers should be separated by white space. Accepts inputs in GDAL or ESRI format. Default is GDAL.';

alter function st_setgeoreference(raster, double precision, double precision, double precision, double precision, double precision, double precision) owner to postgres;

create function _st_tile(rast raster, width integer, height integer, nband integer[] default NULL::integer[], padwithnodata boolean default false, nodataval double precision default NULL::double precision) returns setof setof raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;

$$;

alter function _st_tile(raster, integer, integer, integer[], boolean, double precision) owner to postgres;

create function st_tile(rast raster, nband integer[], width integer, height integer, padwithnodata boolean DEFAULT false, nodataval double precision DEFAULT NULL::double precision) returns SETOF raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_tile($1, $3, $4, $2, $5, $6) $$;

comment on function st_tile(raster, integer[], integer, integer, boolean, double precision) is 'args: rast, nband, width, height, padwithnodata=FALSE, nodataval=NULL - Returns a set of rasters resulting from the split of the input raster based upon the desired dimensions of the output rasters.';

alter function st_tile(raster, integer[], integer, integer, boolean, double precision) owner to postgres;

create function st_tile(rast raster, nband integer, width integer, height integer, padwithnodata boolean DEFAULT false, nodataval double precision DEFAULT NULL::double precision) returns SETOF raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_tile($1, $3, $4, ARRAY[$2]::integer[], $5, $6) $$;

comment on function st_tile(raster, integer, integer, integer, boolean, double precision) is 'args: rast, nband, width, height, padwithnodata=FALSE, nodataval=NULL - Returns a set of rasters resulting from the split of the input raster based upon the desired dimensions of the output rasters.';

alter function st_tile(raster, integer, integer, integer, boolean, double precision) owner to postgres;

create function st_tile(rast raster, width integer, height integer, padwithnodata boolean DEFAULT false, nodataval double precision DEFAULT NULL::double precision) returns SETOF raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_tile($1, $2, $3, NULL::integer[], $4, $5) $$;

comment on function st_tile(raster, integer, integer, boolean, double precision) is 'args: rast, width, height, padwithnodata=FALSE, nodataval=NULL - Returns a set of rasters resulting from the split of the input raster based upon the desired dimensions of the output rasters.';

alter function st_tile(raster, integer, integer, boolean, double precision) owner to postgres;

create function st_setbandnodatavalue(rast raster, band integer, nodatavalue double precision, forcechecking boolean default false) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setbandnodatavalue(raster, integer, double precision, boolean) is 'args: rast, band, nodatavalue, forcechecking=false - Sets the value for the given band that represents no data. Band 1 is assumed if no band is specified. To mark a band as having no nodata value, set the nodata value = NULL.';

alter function st_setbandnodatavalue(raster, integer, double precision, boolean) owner to postgres;

create function st_setbandnodatavalue(rast raster, nodatavalue double precision) returns raster
    language sql
    as
$$ SELECT public.ST_setbandnodatavalue($1, 1, $2, FALSE) $$;

comment on function st_setbandnodatavalue(raster, double precision) is 'args: rast, nodatavalue - Sets the value for the given band that represents no data. Band 1 is assumed if no band is specified. To mark a band as having no nodata value, set the nodata value = NULL.';

alter function st_setbandnodatavalue(raster, double precision) owner to postgres;

create function st_setbandisnodata(rast raster, band integer default 1) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setbandisnodata(raster, integer) is 'args: rast, band=1 - Sets the isnodata flag of the band to TRUE.';

alter function st_setbandisnodata(raster, integer) owner to postgres;

create function st_setbandpath(rast raster, band integer, outdbpath text, outdbindex integer, force boolean default false) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setbandpath(raster, integer, text, integer, boolean) is 'args: rast, band, outdbpath, outdbindex, force=false - Update the external path and band number of an out-db band';

alter function st_setbandpath(raster, integer, text, integer, boolean) owner to postgres;

create function st_setbandindex(rast raster, band integer, outdbindex integer, force boolean DEFAULT false) returns raster
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_SetBandPath($1, $2, NULL, $3, $4) $$;

comment on function st_setbandindex(raster, integer, integer, boolean) is 'args: rast, band, outdbindex, force=false - Update the external band number of an out-db band';

alter function st_setbandindex(raster, integer, integer, boolean) owner to postgres;

create function _st_setvalues(rast raster, nband integer, x integer, y integer, newvalueset double precision[], noset boolean[] default NULL::boolean[], hasnosetvalue boolean default false, nosetvalue double precision default NULL::double precision, keepnodata boolean default false) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_setvalues(raster, integer, integer, integer, double precision[], boolean[], boolean, double precision, boolean) owner to postgres;

create function st_setvalues(rast raster, nband integer, x integer, y integer, newvalueset double precision[], noset boolean[] DEFAULT NULL::boolean[], keepnodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_setvalues($1, $2, $3, $4, $5, $6, FALSE, NULL, $7) $$;

comment on function st_setvalues(raster, integer, integer, integer, double precision[], boolean[], boolean) is 'args: rast, nband, columnx, rowy, newvalueset, noset=NULL, keepnodata=FALSE - Returns modified raster resulting from setting the values of a given band.';

alter function st_setvalues(raster, integer, integer, integer, double precision[], boolean[], boolean) owner to postgres;

create function st_setvalues(rast raster, nband integer, x integer, y integer, newvalueset double precision[], nosetvalue double precision, keepnodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public._ST_setvalues($1, $2, $3, $4, $5, NULL, TRUE, $6, $7) $$;

comment on function st_setvalues(raster, integer, integer, integer, double precision[], double precision, boolean) is 'args: rast, nband, columnx, rowy, newvalueset, nosetvalue, keepnodata=FALSE - Returns modified raster resulting from setting the values of a given band.';

alter function st_setvalues(raster, integer, integer, integer, double precision[], double precision, boolean) owner to postgres;

create function st_setvalues(rast raster, nband integer, x integer, y integer, width integer, height integer, newvalue double precision, keepnodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
BEGIN
		IF width <= 0 OR height <= 0 THEN
			RAISE EXCEPTION 'Values for width and height must be greater than zero';
RETURN NULL;
END IF;
RETURN public._ST_setvalues($1, $2, $3, $4, array_fill($7, ARRAY[$6, $5]::int[]), NULL, FALSE, NULL, $8);
END;
	$$;

comment on function st_setvalues(raster, integer, integer, integer, integer, integer, double precision, boolean) is 'args: rast, nband, columnx, rowy, width, height, newvalue, keepnodata=FALSE - Returns modified raster resulting from setting the values of a given band.';

alter function st_setvalues(raster, integer, integer, integer, integer, integer, double precision, boolean) owner to postgres;

create function st_setvalues(rast raster, x integer, y integer, width integer, height integer, newvalue double precision, keepnodata boolean DEFAULT false) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
BEGIN
		IF width <= 0 OR height <= 0 THEN
			RAISE EXCEPTION 'Values for width and height must be greater than zero';
RETURN NULL;
END IF;
RETURN public._ST_setvalues($1, 1, $2, $3, array_fill($6, ARRAY[$5, $4]::int[]), NULL, FALSE, NULL, $7);
END;
	$$;

comment on function st_setvalues(raster, integer, integer, integer, integer, double precision, boolean) is 'args: rast, columnx, rowy, width, height, newvalue, keepnodata=FALSE - Returns modified raster resulting from setting the values of a given band.';

alter function st_setvalues(raster, integer, integer, integer, integer, double precision, boolean) owner to postgres;

create function st_setvalues(rast raster, nband integer, geomvalset geomval[], keepnodata boolean default false) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setvalues(raster, integer, geomval[], boolean) is 'args: rast, nband, geomvalset, keepnodata=FALSE - Returns modified raster resulting from setting the values of a given band.';

alter function st_setvalues(raster, integer, geomval[], boolean) owner to postgres;

create function st_setvalue(rast raster, band integer, x integer, y integer, newvalue double precision) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_setvalue(raster, integer, integer, integer, double precision) is 'args: rast, bandnum, columnx, rowy, newvalue - Returns modified raster resulting from setting the value of a given band in a given columnx, rowy pixel or the pixels that intersect a particular geometry. Band numbers start at 1 and assumed to be 1 if not specified.';

alter function st_setvalue(raster, integer, integer, integer, double precision) owner to postgres;

create function st_setvalue(rast raster, x integer, y integer, newvalue double precision) returns raster
    language sql
    as
$$ SELECT public.ST_SetValue($1, 1, $2, $3, $4) $$;

comment on function st_setvalue(raster, integer, integer, double precision) is 'args: rast, columnx, rowy, newvalue - Returns modified raster resulting from setting the value of a given band in a given columnx, rowy pixel or the pixels that intersect a particular geometry. Band numbers start at 1 and assumed to be 1 if not specified.';

alter function st_setvalue(raster, integer, integer, double precision) owner to postgres;

create function st_setvalue(rast raster, nband integer, geom geometry, newvalue double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_setvalues($1, $2, ARRAY[ROW($3, $4)]::geomval[], FALSE) $$;

comment on function st_setvalue(raster, integer, geometry, double precision) is 'args: rast, bandnum, geom, newvalue - Returns modified raster resulting from setting the value of a given band in a given columnx, rowy pixel or the pixels that intersect a particular geometry. Band numbers start at 1 and assumed to be 1 if not specified.';

alter function st_setvalue(raster, integer, geometry, double precision) owner to postgres;

create function st_setvalue(rast raster, geom geometry, newvalue double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_setvalues($1, 1, ARRAY[ROW($2, $3)]::geomval[], FALSE) $$;

comment on function st_setvalue(raster, geometry, double precision) is 'args: rast, geom, newvalue - Returns modified raster resulting from setting the value of a given band in a given columnx, rowy pixel or the pixels that intersect a particular geometry. Band numbers start at 1 and assumed to be 1 if not specified.';

alter function st_setvalue(raster, geometry, double precision) owner to postgres;

create function st_dumpaspolygons(rast raster, band integer default 1, exclude_nodata_value boolean default true) returns setof setof geomval
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_dumpaspolygons(raster, integer, boolean) is 'args: rast, band_num=1, exclude_nodata_value=TRUE - Returns a set of geomval (geom,val) rows, from a given raster band. If no band number is specified, band num defaults to 1.';

alter function st_dumpaspolygons(raster, integer, boolean) owner to postgres;

create function st_dumpvalues(rast raster, nband integer[] default NULL::integer[], exclude_nodata_value boolean default true) returns setof table("nband" integer, "valarray" double precision[])
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;

$$;

comment on function st_dumpvalues(raster, integer[], boolean) is 'args: rast, nband=NULL, exclude_nodata_value=true - Get the values of the specified band as a 2-dimension array.';

alter function st_dumpvalues(raster, integer[], boolean) owner to postgres;

create function st_dumpvalues(rast raster, nband integer, exclude_nodata_value boolean DEFAULT true) returns double precision[]
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT valarray FROM public.ST_dumpvalues($1, ARRAY[$2]::integer[], $3) $$;

comment on function st_dumpvalues(raster, integer, boolean) is 'args: rast, nband, exclude_nodata_value=true - Get the values of the specified band as a 2-dimension array.';

alter function st_dumpvalues(raster, integer, boolean) owner to postgres;

create function st_polygon(rast raster, band integer default 1) returns geometry
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_polygon(raster, integer) is 'args: rast, band_num=1 - Returns a multipolygon geometry formed by the union of pixels that have a pixel value that is not no data value. If no band number is specified, band num defaults to 1.';

alter function st_polygon(raster, integer) owner to postgres;

create function _st_pixelaspolygons(rast raster, band integer default 1, columnx integer default NULL::integer, rowy integer default NULL::integer, exclude_nodata_value boolean default true) returns setof table("geom" geometry, "val" double precision, "x" integer, "y" integer)
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;

$$;

alter function _st_pixelaspolygons(raster, integer, integer, integer, boolean) owner to postgres;

create function st_pixelaspolygons(rast raster, band integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true)
    returns TABLE(geom geometry, val double precision, x integer, y integer)
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT geom, val, x, y FROM public._ST_pixelaspolygons($1, $2, NULL, NULL, $3) $$;

comment on function st_pixelaspolygons(raster, integer, boolean) is 'args: rast, band=1, exclude_nodata_value=TRUE - Returns the polygon geometry that bounds every pixel of a raster band along with the value, the X and the Y raster coordinates of each pixel.';

alter function st_pixelaspolygons(raster, integer, boolean) owner to postgres;

create function st_pixelaspolygon(rast raster, x integer, y integer) returns geometry
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT geom FROM public._ST_pixelaspolygons($1, NULL, $2, $3) $$;

comment on function st_pixelaspolygon(raster, integer, integer) is 'args: rast, columnx, rowy - Returns the polygon geometry that bounds the pixel for a particular row and column.';

alter function st_pixelaspolygon(raster, integer, integer) owner to postgres;

create function st_pixelaspoints(rast raster, band integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true)
    returns TABLE(geom geometry, val double precision, x integer, y integer)
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_PointN(  public.ST_ExteriorRing(geom), 1), val, x, y FROM public._ST_pixelaspolygons($1, $2, NULL, NULL, $3) $$;

comment on function st_pixelaspoints(raster, integer, boolean) is 'args: rast, band=1, exclude_nodata_value=TRUE - Returns a point geometry for each pixel of a raster band along with the value, the X and the Y raster coordinates of each pixel. The coordinates of the point geometry are of the pixels upper-left corner.';

alter function st_pixelaspoints(raster, integer, boolean) owner to postgres;

create function st_pixelaspoint(rast raster, x integer, y integer) returns geometry
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT ST_PointN(ST_ExteriorRing(geom), 1) FROM public._ST_pixelaspolygons($1, NULL, $2, $3) $$;

comment on function st_pixelaspoint(raster, integer, integer) is 'args: rast, columnx, rowy - Returns a point geometry of the pixels upper-left corner.';

alter function st_pixelaspoint(raster, integer, integer) owner to postgres;

create function _st_pixelascentroids(rast raster, band integer default 1, columnx integer default NULL::integer, rowy integer default NULL::integer, exclude_nodata_value boolean default true) returns setof table("geom" geometry, "val" double precision, "x" integer, "y" integer)
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;

$$;

alter function _st_pixelascentroids(raster, integer, integer, integer, boolean) owner to postgres;

create function st_pixelascentroids(rast raster, band integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true)
    returns TABLE(geom geometry, val double precision, x integer, y integer)
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT geom, val, x, y FROM public._ST_pixelascentroids($1, $2, NULL, NULL, $3) $$;

comment on function st_pixelascentroids(raster, integer, boolean) is 'args: rast, band=1, exclude_nodata_value=TRUE - Returns the centroid (point geometry) for each pixel of a raster band along with the value, the X and the Y raster coordinates of each pixel. The point geometry is the centroid of the area represented by a pixel.';

alter function st_pixelascentroids(raster, integer, boolean) owner to postgres;

create function st_pixelascentroid(rast raster, x integer, y integer) returns geometry
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT geom FROM public._ST_pixelascentroids($1, NULL, $2, $3) $$;

comment on function st_pixelascentroid(raster, integer, integer) is 'args: rast, x, y - Returns the centroid (point geometry) of the area represented by a pixel.';

alter function st_pixelascentroid(raster, integer, integer) owner to postgres;

create function _st_worldtorastercoord(rast raster, longitude double precision default NULL::double precision, latitude double precision default NULL::double precision, out columnx integer, out rowy integer) returns record
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_worldtorastercoord(raster, double precision, double precision, out integer, out integer) owner to postgres;

create function st_worldtorastercoord(rast raster, longitude double precision, latitude double precision, OUT columnx integer, OUT rowy integer) returns record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT columnx, rowy FROM public._ST_worldtorastercoord($1, $2, $3) $$;

comment on function st_worldtorastercoord(raster, double precision, double precision, out integer, out integer) is 'args: rast, longitude, latitude - Returns the upper left corner as column and row given geometric X and Y (longitude and latitude) or a point geometry expressed in the spatial reference coordinate system of the raster.';

alter function st_worldtorastercoord(raster, double precision, double precision, out integer, out integer) owner to postgres;

create function st_worldtorastercoord(rast raster, pt geometry, OUT columnx integer, OUT rowy integer) returns record
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
rx integer;
		ry integer;
BEGIN
		IF public.ST_geometrytype(pt) != 'ST_Point' THEN
			RAISE EXCEPTION 'Attempting to compute raster coordinate with a non-point geometry';
END IF;
		IF public.ST_SRID(rast) != public.ST_SRID(pt) THEN
			RAISE EXCEPTION 'Raster and geometry do not have the same SRID';
END IF;

SELECT rc.columnx AS x, rc.rowy AS y INTO columnx, rowy FROM public._ST_worldtorastercoord($1, public.ST_x(pt), public.ST_y(pt)) AS rc;
RETURN;
END;
	$$;

comment on function st_worldtorastercoord(raster, geometry, out integer, out integer) is 'args: rast, pt - Returns the upper left corner as column and row given geometric X and Y (longitude and latitude) or a point geometry expressed in the spatial reference coordinate system of the raster.';

alter function st_worldtorastercoord(raster, geometry, out integer, out integer) owner to postgres;

create function st_worldtorastercoordx(rast raster, xw double precision, yw double precision) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT columnx FROM public._ST_worldtorastercoord($1, $2, $3) $$;

comment on function st_worldtorastercoordx(raster, double precision, double precision) is 'args: rast, xw, yw - Returns the column in the raster of the point geometry (pt) or a X and Y world coordinate (xw, yw) represented in world spatial reference system of raster.';

alter function st_worldtorastercoordx(raster, double precision, double precision) owner to postgres;

create function st_worldtorastercoordx(rast raster, xw double precision) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT columnx FROM public._ST_worldtorastercoord($1, $2, NULL) $$;

comment on function st_worldtorastercoordx(raster, double precision) is 'args: rast, xw - Returns the column in the raster of the point geometry (pt) or a X and Y world coordinate (xw, yw) represented in world spatial reference system of raster.';

alter function st_worldtorastercoordx(raster, double precision) owner to postgres;

create function st_worldtorastercoordx(rast raster, pt geometry) returns integer
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
xr integer;
BEGIN
		IF ( public.ST_geometrytype(pt) != 'ST_Point' ) THEN
			RAISE EXCEPTION 'Attempting to compute raster coordinate with a non-point geometry';
END IF;
		IF public.ST_SRID(rast) != public.ST_SRID(pt) THEN
			RAISE EXCEPTION 'Raster and geometry do not have the same SRID';
END IF;
SELECT columnx INTO xr FROM public._ST_worldtorastercoord($1, public.ST_x(pt), public.ST_y(pt));
RETURN xr;
END;
	$$;

comment on function st_worldtorastercoordx(raster, geometry) is 'args: rast, pt - Returns the column in the raster of the point geometry (pt) or a X and Y world coordinate (xw, yw) represented in world spatial reference system of raster.';

alter function st_worldtorastercoordx(raster, geometry) owner to postgres;

create function st_worldtorastercoordy(rast raster, xw double precision, yw double precision) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT rowy FROM public._ST_worldtorastercoord($1, $2, $3) $$;

comment on function st_worldtorastercoordy(raster, double precision, double precision) is 'args: rast, xw, yw - Returns the row in the raster of the point geometry (pt) or a X and Y world coordinate (xw, yw) represented in world spatial reference system of raster.';

alter function st_worldtorastercoordy(raster, double precision, double precision) owner to postgres;

create function st_worldtorastercoordy(rast raster, yw double precision) returns integer
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT rowy FROM public._ST_worldtorastercoord($1, NULL, $2) $$;

comment on function st_worldtorastercoordy(raster, double precision) is 'args: rast, xw - Returns the row in the raster of the point geometry (pt) or a X and Y world coordinate (xw, yw) represented in world spatial reference system of raster.';

alter function st_worldtorastercoordy(raster, double precision) owner to postgres;

create function st_worldtorastercoordy(rast raster, pt geometry) returns integer
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
yr integer;
BEGIN
		IF ( st_geometrytype(pt) != 'ST_Point' ) THEN
			RAISE EXCEPTION 'Attempting to compute raster coordinate with a non-point geometry';
END IF;
		IF ST_SRID(rast) != ST_SRID(pt) THEN
			RAISE EXCEPTION 'Raster and geometry do not have the same SRID';
END IF;
SELECT rowy INTO yr FROM public._ST_worldtorastercoord($1, st_x(pt), st_y(pt));
RETURN yr;
END;
	$$;

comment on function st_worldtorastercoordy(raster, geometry) is 'args: rast, pt - Returns the row in the raster of the point geometry (pt) or a X and Y world coordinate (xw, yw) represented in world spatial reference system of raster.';

alter function st_worldtorastercoordy(raster, geometry) owner to postgres;

create function _st_rastertoworldcoord(rast raster, columnx integer default NULL::integer, rowy integer default NULL::integer, out longitude double precision, out latitude double precision) returns record
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_rastertoworldcoord(raster, integer, integer, out double precision, out double precision) owner to postgres;

create function st_rastertoworldcoord(rast raster, columnx integer, rowy integer, OUT longitude double precision, OUT latitude double precision) returns record
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT longitude, latitude FROM public._ST_rastertoworldcoord($1, $2, $3) $$;

comment on function st_rastertoworldcoord(raster, integer, integer, out double precision, out double precision) is 'args: rast, xcolumn, yrow - Returns the rasters upper left corner as geometric X and Y (longitude and latitude) given a column and row. Column and row starts at 1.';

alter function st_rastertoworldcoord(raster, integer, integer, out double precision, out double precision) owner to postgres;

create function st_rastertoworldcoordx(rast raster, xr integer, yr integer) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT longitude FROM public._ST_rastertoworldcoord($1, $2, $3) $$;

comment on function st_rastertoworldcoordx(raster, integer, integer) is 'args: rast, xcolumn, yrow - Returns the geometric X coordinate upper left of a raster, column and row. Numbering of columns and rows starts at 1.';

alter function st_rastertoworldcoordx(raster, integer, integer) owner to postgres;

create function st_rastertoworldcoordx(rast raster, xr integer) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT longitude FROM public._ST_rastertoworldcoord($1, $2, NULL) $$;

comment on function st_rastertoworldcoordx(raster, integer) is 'args: rast, xcolumn - Returns the geometric X coordinate upper left of a raster, column and row. Numbering of columns and rows starts at 1.';

alter function st_rastertoworldcoordx(raster, integer) owner to postgres;

create function st_rastertoworldcoordy(rast raster, xr integer, yr integer) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT latitude FROM public._ST_rastertoworldcoord($1, $2, $3) $$;

comment on function st_rastertoworldcoordy(raster, integer, integer) is 'args: rast, xcolumn, yrow - Returns the geometric Y coordinate upper left corner of a raster, column and row. Numbering of columns and rows starts at 1.';

alter function st_rastertoworldcoordy(raster, integer, integer) owner to postgres;

create function st_rastertoworldcoordy(rast raster, yr integer) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT latitude FROM public._ST_rastertoworldcoord($1, NULL, $2) $$;

comment on function st_rastertoworldcoordy(raster, integer) is 'args: rast, yrow - Returns the geometric Y coordinate upper left corner of a raster, column and row. Numbering of columns and rows starts at 1.';

alter function st_rastertoworldcoordy(raster, integer) owner to postgres;

create function st_minpossiblevalue(pixeltype text) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_minpossiblevalue(text) is 'args: pixeltype - Returns the minimum value this pixeltype can store.';

alter function st_minpossiblevalue(text) owner to postgres;

create function st_rastfromwkb(bytea) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_rastfromwkb(bytea) is 'args: wkb - Return a raster value from a Well-Known Binary (WKB) raster.';

alter function st_rastfromwkb(bytea) owner to postgres;

create function st_rastfromhexwkb(text) returns raster
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_rastfromhexwkb(text) is 'args: wkb - Return a raster value from a Hex representation of Well-Known Binary (WKB) raster.';

alter function st_rastfromhexwkb(text) owner to postgres;

create function st_aswkb(raster, outasin boolean default false) returns bytea
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_aswkb(raster, boolean) is 'args: rast, outasin=FALSE - Return the Well-Known Binary (WKB) representation of the raster.';

alter function st_aswkb(raster, boolean) owner to postgres;

create function st_asbinary(raster, outasin boolean DEFAULT false) returns bytea
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_AsWKB($1, $2) $$;

comment on function st_asbinary(raster, boolean) is 'args: rast, outasin=FALSE - Return the Well-Known Binary (WKB) representation of the raster.';

alter function st_asbinary(raster, boolean) owner to postgres;

create function st_ashexwkb(raster, outasin boolean default false) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_ashexwkb(raster, boolean) is 'args: rast, outasin=FALSE - Return the Well-Known Binary (WKB) in Hex representation of the raster.';

alter function st_ashexwkb(raster, boolean) owner to postgres;

create function bytea(raster) returns bytea
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function bytea(raster) owner to postgres;

create function raster_hash(raster) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

alter function raster_hash(raster) owner to postgres;

create function raster_eq(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.raster_hash($1) = public.raster_hash($2) $$;

alter function raster_eq(raster, raster) owner to postgres;

create function raster_overleft(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry &< $2::public.geometry$$;

alter function raster_overleft(raster, raster) owner to postgres;

create function raster_overright(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry &> $2::public.geometry$$;

alter function raster_overright(raster, raster) owner to postgres;

create function raster_left(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry << $2::public.geometry$$;

alter function raster_left(raster, raster) owner to postgres;

create function raster_right(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry >> $2::public.geometry$$;

alter function raster_right(raster, raster) owner to postgres;

create function raster_overabove(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry |&> $2::public.geometry$$;

alter function raster_overabove(raster, raster) owner to postgres;

create function raster_overbelow(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry &<| $2::public.geometry$$;

alter function raster_overbelow(raster, raster) owner to postgres;

create function raster_above(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry |>> $2::public.geometry$$;

alter function raster_above(raster, raster) owner to postgres;

create function raster_below(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry <<| $2::public.geometry$$;

alter function raster_below(raster, raster) owner to postgres;

create function raster_same(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry ~= $2::public.geometry$$;

alter function raster_same(raster, raster) owner to postgres;

create function raster_contained(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry OPERATOR(public.@) $2::public.geometry$$;

alter function raster_contained(raster, raster) owner to postgres;

create function raster_contain(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry ~ $2::public.geometry$$;

alter function raster_contain(raster, raster) owner to postgres;

create function raster_overlap(raster, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry OPERATOR(public.&&) $2::public.geometry$$;

alter function raster_overlap(raster, raster) owner to postgres;

create function raster_geometry_contain(raster, geometry) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry ~ $2$$;

alter function raster_geometry_contain(raster, geometry) owner to postgres;

create function raster_contained_by_geometry(raster, geometry) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry OPERATOR(public.@) $2$$;

alter function raster_contained_by_geometry(raster, geometry) owner to postgres;

create function raster_geometry_overlap(raster, geometry) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1::public.geometry OPERATOR(public.&&) $2$$;

alter function raster_geometry_overlap(raster, geometry) owner to postgres;

create function geometry_raster_contain(geometry, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1 OPERATOR(public.~) $2::public.geometry$$;

alter function geometry_raster_contain(geometry, raster) owner to postgres;

create function geometry_contained_by_raster(geometry, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1 OPERATOR(public.@) $2::public.geometry$$;

alter function geometry_contained_by_raster(geometry, raster) owner to postgres;

create function geometry_raster_overlap(geometry, raster) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$select $1 OPERATOR(public.&&) $2::public.geometry$$;

alter function geometry_raster_overlap(geometry, raster) owner to postgres;

create function st_samealignment(rast1 raster, rast2 raster) returns boolean
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_samealignment(raster, raster) is 'args: rastA, rastB - Returns true if rasters have same skew, scale, spatial ref, and offset (pixels can be put on same grid without cutting into pixels) and false if they dont with notice detailing issue.';

alter function st_samealignment(raster, raster) owner to postgres;

create function st_samealignment(ulx1 double precision, uly1 double precision, scalex1 double precision, scaley1 double precision, skewx1 double precision, skewy1 double precision, ulx2 double precision, uly2 double precision, scalex2 double precision, scaley2 double precision, skewx2 double precision, skewy2 double precision) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT st_samealignment(st_makeemptyraster(1, 1, $1, $2, $3, $4, $5, $6), st_makeemptyraster(1, 1, $7, $8, $9, $10, $11, $12)) $$;

comment on function st_samealignment(double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) is 'args: ulx1, uly1, scalex1, scaley1, skewx1, skewy1, ulx2, uly2, scalex2, scaley2, skewx2, skewy2 - Returns true if rasters have same skew, scale, spatial ref, and offset (pixels can be put on same grid without cutting into pixels) and false if they dont with notice detailing issue.';

alter function st_samealignment(double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision) owner to postgres;

create function _st_samealignment_transfn(agg agg_samealignment, rast raster) returns agg_samealignment
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
m record;
		aligned boolean;
BEGIN
		IF agg IS NULL THEN
			agg.refraster := NULL;
			agg.aligned := NULL;
END IF;

		IF rast IS NULL THEN
			agg.aligned := NULL;
ELSE
			IF agg.refraster IS NULL THEN
				m := ST_Metadata(rast);
				agg.refraster := ST_MakeEmptyRaster(1, 1, m.upperleftx, m.upperlefty, m.scalex, m.scaley, m.skewx, m.skewy, m.srid);
				agg.aligned := TRUE;
			ELSIF agg.aligned IS TRUE THEN
				agg.aligned := ST_SameAlignment(agg.refraster, rast);
END IF;
END IF;
RETURN agg;
END;
	$$;

alter function _st_samealignment_transfn(agg_samealignment, raster) owner to postgres;

create function _st_samealignment_finalfn(agg agg_samealignment) returns boolean
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT $1.aligned $$;

alter function _st_samealignment_finalfn(agg_samealignment) owner to postgres;

create function st_notsamealignmentreason(rast1 raster, rast2 raster) returns text
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_notsamealignmentreason(raster, raster) is 'args: rastA, rastB - Returns text stating if rasters are aligned and if not aligned, a reason why.';

alter function st_notsamealignmentreason(raster, raster) owner to postgres;

create function st_iscoveragetile(rast raster, coverage raster, tilewidth integer, tileheight integer) returns boolean
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
_rastmeta record;
		_covmeta record;
		cr record;
max integer[];
		tile integer[];
		edge integer[];
BEGIN
		IF NOT ST_SameAlignment(rast, coverage) THEN
			RAISE NOTICE 'Raster and coverage are not aligned';
RETURN FALSE;
END IF;

_rastmeta := ST_Metadata(rast);
_covmeta := ST_Metadata(coverage);

		-- get coverage grid coordinates of upper-left of rast
		cr := ST_WorldToRasterCoord(coverage, _rastmeta.upperleftx, _rastmeta.upperlefty);

		-- rast is not part of coverage
		IF
(cr.columnx < 1 OR cr.columnx > _covmeta.width) OR
			(cr.rowy < 1 OR cr.rowy > _covmeta.height)
		THEN
			RAISE NOTICE 'Raster is not in the coverage';
RETURN FALSE;
END IF;

		-- rast isn't on the coverage's grid
		IF
((cr.columnx - 1) % tilewidth != 0) OR
			((cr.rowy - 1) % tileheight != 0)
		THEN
			RAISE NOTICE 'Raster is not aligned to tile grid of coverage';
RETURN FALSE;
END IF;

		-- max # of tiles on X and Y for coverage
max[0] := ceil(_covmeta.width::double precision / tilewidth::double precision)::integer;
max[1] := ceil(_covmeta.height::double precision / tileheight::double precision)::integer;

		-- tile # of rast in coverge
		tile[0] := (cr.columnx / tilewidth) + 1;
		tile[1] := (cr.rowy / tileheight) + 1;

		-- inner tile
		IF tile[0] < max[0] AND tile[1] < max[1] THEN
			IF
				(_rastmeta.width != tilewidth) OR
				(_rastmeta.height != tileheight)
			THEN
				RAISE NOTICE 'Raster width/height is invalid for interior tile of coverage';
RETURN FALSE;
ELSE
				RETURN TRUE;
END IF;
END IF;

		-- edge tile

		-- edge tile may have same size as inner tile
		IF
(_rastmeta.width = tilewidth) AND
			(_rastmeta.height = tileheight)
		THEN
			RETURN TRUE;
END IF;

		-- get edge tile width and height
		edge[0] := _covmeta.width - ((max[0] - 1) * tilewidth);
		edge[1] := _covmeta.height - ((max[1] - 1) * tileheight);

		-- edge tile not of expected tile size
		-- right and bottom
		IF tile[0] = max[0] AND tile[1] = max[1] THEN
			IF
				_rastmeta.width != edge[0] OR
				_rastmeta.height != edge[1]
			THEN
				RAISE NOTICE 'Raster width/height is invalid for right-most AND bottom-most tile of coverage';
RETURN FALSE;
END IF;
		ELSEIF tile[0] = max[0] THEN
			IF
				_rastmeta.width != edge[0] OR
				_rastmeta.height != tileheight
			THEN
				RAISE NOTICE 'Raster width/height is invalid for right-most tile of coverage';
RETURN FALSE;
END IF;
ELSE
			IF
				_rastmeta.width != tilewidth OR
				_rastmeta.height != edge[1]
			THEN
				RAISE NOTICE 'Raster width/height is invalid for bottom-most tile of coverage';
RETURN FALSE;
END IF;
END IF;

RETURN TRUE;
END;
	$$;

alter function st_iscoveragetile(raster, raster, integer, integer) owner to postgres;

create function _st_intersects(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    strict
    parallel safe
    cost 1000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_intersects(raster, integer, raster, integer) owner to postgres;

create function st_intersects(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1 OPERATOR(public.&&) $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN public._st_intersects(public.st_convexhull($1), public.st_convexhull($3)) ELSE public._st_intersects($1, $2, $3, $4) END $$;

comment on function st_intersects(raster, integer, raster, integer) is 'args: rastA, nbandA, rastB, nbandB - Return true if raster rastA spatially intersects raster rastB.';

alter function st_intersects(raster, integer, raster, integer) owner to postgres;

create function st_intersects(rast1 raster, rast2 raster) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public.st_intersects($1, NULL::integer, $2, NULL::integer) $$;

comment on function st_intersects(raster, raster) is 'args: rastA, rastB - Return true if raster rastA spatially intersects raster rastB.';

alter function st_intersects(raster, raster) owner to postgres;

create function _st_intersects(geom geometry, rast raster, nband integer DEFAULT NULL::integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language plpgsql
as
$$
DECLARE
hasnodata boolean := TRUE;
		_geom public.geometry;
BEGIN
		IF public.ST_SRID(rast) != public.ST_SRID(geom) THEN
			RAISE EXCEPTION 'Raster and geometry do not have the same SRID';
END IF;

_geom := public.ST_ConvexHull(rast);
		IF nband IS NOT NULL THEN
SELECT CASE WHEN bmd.nodatavalue IS NULL THEN FALSE ELSE NULL END INTO hasnodata FROM public.ST_BandMetaData(rast, nband) AS bmd;
END IF;

		IF public.ST_Intersects(geom, _geom) IS NOT TRUE THEN
			RETURN FALSE;
		ELSEIF nband IS NULL OR hasnodata IS FALSE THEN
			RETURN TRUE;
END IF;

SELECT public.ST_Buffer(public.ST_Collect(t.geom), 0) INTO _geom FROM public.ST_PixelAsPolygons(rast, nband) AS t;
RETURN public.ST_Intersects(geom, _geom);
END;
	$$;

alter function _st_intersects(geometry, raster, integer) owner to postgres;

create function st_intersects(geom geometry, rast raster, nband integer DEFAULT NULL::integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1 OPERATOR(public.&&) $2::public.geometry AND public._st_intersects($1, $2, $3); $$;

comment on function st_intersects(geometry, raster, integer) is 'args: geommin, rast, nband=NULL - Return true if raster rastA spatially intersects raster rastB.';

alter function st_intersects(geometry, raster, integer) owner to postgres;

create function st_intersects(rast raster, geom geometry, nband integer DEFAULT NULL::integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1::public.geometry OPERATOR(public.&&) $2 AND public._st_intersects($2, $1, $3) $$;

comment on function st_intersects(raster, geometry, integer) is 'args: rast, geommin, nband=NULL - Return true if raster rastA spatially intersects raster rastB.';

alter function st_intersects(raster, geometry, integer) owner to postgres;

create function st_intersects(rast raster, nband integer, geom geometry) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1::public.geometry OPERATOR(public.&&) $3 AND public._st_intersects($3, $1, $2) $$;

comment on function st_intersects(raster, integer, geometry) is 'args: rast, nband, geommin - Return true if raster rastA spatially intersects raster rastB.';

alter function st_intersects(raster, integer, geometry) owner to postgres;

create function _st_overlaps(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    strict
    cost 1000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_overlaps(raster, integer, raster, integer) owner to postgres;

create function st_overlaps(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1 OPERATOR(public.&&) $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN public._st_overlaps(public.st_convexhull($1), public.st_convexhull($3)) ELSE public._ST_overlaps($1, $2, $3, $4) END $$;

comment on function st_overlaps(raster, integer, raster, integer) is 'args: rastA, nbandA, rastB, nbandB - Return true if raster rastA and rastB intersect but one does not completely contain the other.';

alter function st_overlaps(raster, integer, raster, integer) owner to postgres;

create function st_overlaps(rast1 raster, rast2 raster) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public.st_overlaps($1, NULL::integer, $2, NULL::integer) $$;

comment on function st_overlaps(raster, raster) is 'args: rastA, rastB - Return true if raster rastA and rastB intersect but one does not completely contain the other.';

alter function st_overlaps(raster, raster) owner to postgres;

create function _st_touches(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    strict
    parallel safe
    cost 1000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_touches(raster, integer, raster, integer) owner to postgres;

create function st_touches(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1 OPERATOR(public.&&) $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN public._st_touches(public.st_convexhull($1), public.st_convexhull($3)) ELSE public._st_touches($1, $2, $3, $4) END $$;

comment on function st_touches(raster, integer, raster, integer) is 'args: rastA, nbandA, rastB, nbandB - Return true if raster rastA and rastB have at least one point in common but their interiors do not intersect.';

alter function st_touches(raster, integer, raster, integer) owner to postgres;

create function st_touches(rast1 raster, rast2 raster) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public.st_touches($1, NULL::integer, $2, NULL::integer) $$;

comment on function st_touches(raster, raster) is 'args: rastA, rastB - Return true if raster rastA and rastB have at least one point in common but their interiors do not intersect.';

alter function st_touches(raster, raster) owner to postgres;

create function _st_contains(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    strict
    cost 1000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_contains(raster, integer, raster, integer) owner to postgres;

create function st_contains(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1 OPERATOR(public.&&) $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN public._st_contains(public.st_convexhull($1), public.st_convexhull($3)) ELSE public._st_contains($1, $2, $3, $4) END $$;

comment on function st_contains(raster, integer, raster, integer) is 'args: rastA, nbandA, rastB, nbandB - Return true if no points of raster rastB lie in the exterior of raster rastA and at least one point of the interior of rastB lies in the interior of rastA.';

alter function st_contains(raster, integer, raster, integer) owner to postgres;

create function st_contains(rast1 raster, rast2 raster) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public.st_contains($1, NULL::integer, $2, NULL::integer) $$;

comment on function st_contains(raster, raster) is 'args: rastA, rastB - Return true if no points of raster rastB lie in the exterior of raster rastA and at least one point of the interior of rastB lies in the interior of rastA.';

alter function st_contains(raster, raster) owner to postgres;

create function _st_containsproperly(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    strict
    parallel safe
    cost 1000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_containsproperly(raster, integer, raster, integer) owner to postgres;

create function st_containsproperly(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1 OPERATOR(public.&&) $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN public._st_containsproperly(public.st_convexhull($1), public.st_convexhull($3)) ELSE public._st_containsproperly($1, $2, $3, $4) END $$;

comment on function st_containsproperly(raster, integer, raster, integer) is 'args: rastA, nbandA, rastB, nbandB - Return true if rastB intersects the interior of rastA but not the boundary or exterior of rastA.';

alter function st_containsproperly(raster, integer, raster, integer) owner to postgres;

create function st_containsproperly(rast1 raster, rast2 raster) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public.st_containsproperly($1, NULL::integer, $2, NULL::integer) $$;

comment on function st_containsproperly(raster, raster) is 'args: rastA, rastB - Return true if rastB intersects the interior of rastA but not the boundary or exterior of rastA.';

alter function st_containsproperly(raster, raster) owner to postgres;

create function _st_covers(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    strict
    parallel safe
    cost 1000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_covers(raster, integer, raster, integer) owner to postgres;

create function st_covers(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1 OPERATOR(public.&&) $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN public._st_covers(public.st_convexhull($1), public.st_convexhull($3)) ELSE public._st_covers($1, $2, $3, $4) END $$;

comment on function st_covers(raster, integer, raster, integer) is 'args: rastA, nbandA, rastB, nbandB - Return true if no points of raster rastB lie outside raster rastA.';

alter function st_covers(raster, integer, raster, integer) owner to postgres;

create function st_covers(rast1 raster, rast2 raster) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public.st_covers($1, NULL::integer, $2, NULL::integer) $$;

comment on function st_covers(raster, raster) is 'args: rastA, rastB - Return true if no points of raster rastB lie outside raster rastA.';

alter function st_covers(raster, raster) owner to postgres;

create function _st_coveredby(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    strict
    parallel safe
    cost 1000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_coveredby(raster, integer, raster, integer) owner to postgres;

create function st_coveredby(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1 OPERATOR(public.&&) $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN public._st_coveredby(public.st_convexhull($1), public.st_convexhull($3)) ELSE public._st_coveredby($1, $2, $3, $4) END $$;

comment on function st_coveredby(raster, integer, raster, integer) is 'args: rastA, nbandA, rastB, nbandB - Return true if no points of raster rastA lie outside raster rastB.';

alter function st_coveredby(raster, integer, raster, integer) owner to postgres;

create function st_coveredby(rast1 raster, rast2 raster) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public.st_coveredby($1, NULL::integer, $2, NULL::integer) $$;

comment on function st_coveredby(raster, raster) is 'args: rastA, rastB - Return true if no points of raster rastA lie outside raster rastB.';

alter function st_coveredby(raster, raster) owner to postgres;

create function _st_within(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public._st_contains($3, $4, $1, $2) $$;

alter function _st_within(raster, integer, raster, integer) owner to postgres;

create function st_within(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1 OPERATOR(public.&&) $3 AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN public._st_within(public.st_convexhull($1), public.st_convexhull($3)) ELSE public._st_contains($3, $4, $1, $2) END $$;

comment on function st_within(raster, integer, raster, integer) is 'args: rastA, nbandA, rastB, nbandB - Return true if no points of raster rastA lie in the exterior of raster rastB and at least one point of the interior of rastA lies in the interior of rastB.';

alter function st_within(raster, integer, raster, integer) owner to postgres;

create function st_within(rast1 raster, rast2 raster) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public.st_within($1, NULL::integer, $2, NULL::integer) $$;

comment on function st_within(raster, raster) is 'args: rastA, rastB - Return true if no points of raster rastA lie in the exterior of raster rastB and at least one point of the interior of rastA lies in the interior of rastB.';

alter function st_within(raster, raster) owner to postgres;

create function _st_dwithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 1000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_dwithin(raster, integer, raster, integer, double precision) owner to postgres;

create function st_dwithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1::public.geometry OPERATOR(public.&&) ST_Expand(ST_ConvexHull($3), $5) AND $3::geometry OPERATOR(public.&&) ST_Expand(ST_ConvexHull($1), $5) AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN public._ST_dwithin(st_convexhull($1), st_convexhull($3), $5) ELSE public._ST_dwithin($1, $2, $3, $4, $5) END $$;

comment on function st_dwithin(raster, integer, raster, integer, double precision) is 'args: rastA, nbandA, rastB, nbandB, distance_of_srid - Return true if rasters rastA and rastB are within the specified distance of each other.';

alter function st_dwithin(raster, integer, raster, integer, double precision) owner to postgres;

create function st_dwithin(rast1 raster, rast2 raster, distance double precision) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public.st_dwithin($1, NULL::integer, $2, NULL::integer, $3) $$;

comment on function st_dwithin(raster, raster, double precision) is 'args: rastA, rastB, distance_of_srid - Return true if rasters rastA and rastB are within the specified distance of each other.';

alter function st_dwithin(raster, raster, double precision) owner to postgres;

create function _st_dfullywithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) returns boolean
    immutable
    strict
    parallel safe
    cost 1000
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_dfullywithin(raster, integer, raster, integer, double precision) owner to postgres;

create function st_dfullywithin(rast1 raster, nband1 integer, rast2 raster, nband2 integer, distance double precision) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT $1::public.geometry OPERATOR(public.&&) public.ST_Expand(public.ST_ConvexHull($3), $5) AND $3::geometry OPERATOR(public.&&) public.ST_Expand(public.ST_ConvexHull($1), $5) AND CASE WHEN $2 IS NULL OR $4 IS NULL THEN public._ST_DFullyWithin(public.ST_ConvexHull($1), public.ST_Convexhull($3), $5) ELSE public._ST_DFullyWithin($1, $2, $3, $4, $5) END $$;

comment on function st_dfullywithin(raster, integer, raster, integer, double precision) is 'args: rastA, nbandA, rastB, nbandB, distance_of_srid - Return true if rasters rastA and rastB are fully within the specified distance of each other.';

alter function st_dfullywithin(raster, integer, raster, integer, double precision) owner to postgres;

create function st_dfullywithin(rast1 raster, rast2 raster, distance double precision) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public.ST_DFullyWithin($1, NULL::integer, $2, NULL::integer, $3) $$;

comment on function st_dfullywithin(raster, raster, double precision) is 'args: rastA, rastB, distance_of_srid - Return true if rasters rastA and rastB are fully within the specified distance of each other.';

alter function st_dfullywithin(raster, raster, double precision) owner to postgres;

create function st_disjoint(rast1 raster, nband1 integer, rast2 raster, nband2 integer) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT CASE WHEN $2 IS NULL OR $4 IS NULL THEN public.ST_Disjoint(public.ST_ConvexHull($1), public.ST_ConvexHull($3)) ELSE NOT public._ST_intersects($1, $2, $3, $4) END $$;

comment on function st_disjoint(raster, integer, raster, integer) is 'args: rastA, nbandA, rastB, nbandB - Return true if raster rastA does not spatially intersect rastB.';

alter function st_disjoint(raster, integer, raster, integer) owner to postgres;

create function st_disjoint(rast1 raster, rast2 raster) returns boolean
    immutable
    parallel safe
    cost 1000
    language sql
as
$$ SELECT public.ST_Disjoint($1, NULL::integer, $2, NULL::integer) $$;

comment on function st_disjoint(raster, raster) is 'args: rastA, rastB - Return true if raster rastA does not spatially intersect rastB.';

alter function st_disjoint(raster, raster) owner to postgres;

create function st_intersection(geomin geometry, rast raster, band integer DEFAULT 1) returns SETOF geomval
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
intersects boolean := FALSE; same_srid boolean := FALSE;
BEGIN
		same_srid :=  (public.ST_SRID(geomin) = public.ST_SRID(rast));
		IF NOT same_srid THEN
			RAISE EXCEPTION 'SRIDS of geometry: % and raster: % are not the same',
				public.ST_SRID(geomin), public.ST_SRID(rast)
				USING HINT = 'Verify using ST_SRID function';
END IF;
		intersects :=  public.ST_Intersects(geomin, rast, band);
		IF intersects THEN
			-- Return the intersections of the geometry with the vectorized parts of
			-- the raster and the values associated with those parts, if really their
			-- intersection is not empty.
			RETURN QUERY
SELECT
    intgeom,
    val
FROM (
         SELECT
             public.ST_Intersection((gv).geom, geomin) AS intgeom,
             (gv).val
         FROM public.ST_DumpAsPolygons(rast, band) gv
         WHERE public.ST_Intersects((gv).geom, geomin)
     ) foo
WHERE NOT public.ST_IsEmpty(intgeom);
ELSE
			-- If the geometry does not intersect with the raster, return an empty
			-- geometry and a null value
			RETURN QUERY
SELECT
    emptygeom,
    NULL::float8
FROM ST_GeomCollFromText('GEOMETRYCOLLECTION EMPTY', ST_SRID($1)) emptygeom;
END IF;
END;
	$$;

comment on function st_intersection(geometry, raster, integer) is 'args: geom, rast, band_num=1 - Returns a raster or a set of geometry-pixelvalue pairs representing the shared portion of two rasters or the geometrical intersection of a vectorization of the raster and a geometry.';

alter function st_intersection(geometry, raster, integer) owner to postgres;

create function st_intersection(rast raster, band integer, geomin geometry) returns SETOF geomval
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_Intersection($3, $1, $2) $$;

comment on function st_intersection(raster, integer, geometry) is 'args: rast, band, geomin - Returns a raster or a set of geometry-pixelvalue pairs representing the shared portion of two rasters or the geometrical intersection of a vectorization of the raster and a geometry.';

alter function st_intersection(raster, integer, geometry) owner to postgres;

create function st_intersection(rast raster, geomin geometry) returns SETOF geomval
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public.ST_Intersection($2, $1, 1) $$;

comment on function st_intersection(raster, geometry) is 'args: rast, geom - Returns a raster or a set of geometry-pixelvalue pairs representing the shared portion of two rasters or the geometrical intersection of a vectorization of the raster and a geometry.';

alter function st_intersection(raster, geometry) owner to postgres;

create function st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, returnband text DEFAULT 'BOTH'::text, nodataval double precision[] DEFAULT NULL::double precision[]) returns raster
    stable
    parallel safe
    language plpgsql
as
$$
DECLARE
rtn public.raster;
		_returnband text;
		newnodata1 float8;
		newnodata2 float8;
BEGIN
		IF ST_SRID(rast1) != ST_SRID(rast2) THEN
			RAISE EXCEPTION 'The two rasters do not have the same SRID';
END IF;

		newnodata1 := coalesce(nodataval[1], ST_BandNodataValue(rast1, band1), ST_MinPossibleValue(public.ST_BandPixelType(rast1, band1)));
		newnodata2 := coalesce(nodataval[2], ST_BandNodataValue(rast2, band2), ST_MinPossibleValue(public.ST_BandPixelType(rast2, band2)));

_returnband := upper(returnband);

		rtn := NULL;
CASE
			WHEN _returnband = 'BAND1' THEN
				rtn := public.ST_MapAlgebraExpr(rast1, band1, rast2, band2, '[rast1.val]', public.ST_BandPixelType(rast1, band1), 'INTERSECTION', newnodata1::text, newnodata1::text, newnodata1);
				rtn := public.ST_SetBandNodataValue(rtn, 1, newnodata1);
WHEN _returnband = 'BAND2' THEN
				rtn := public.ST_MapAlgebraExpr(rast1, band1, rast2, band2, '[rast2.val]', public.ST_BandPixelType(rast2, band2), 'INTERSECTION', newnodata2::text, newnodata2::text, newnodata2);
				rtn := public.ST_SetBandNodataValue(rtn, 1, newnodata2);
WHEN _returnband = 'BOTH' THEN
				rtn := public.ST_MapAlgebraExpr(rast1, band1, rast2, band2, '[rast1.val]', public.ST_BandPixelType(rast1, band1), 'INTERSECTION', newnodata1::text, newnodata1::text, newnodata1);
				rtn := ST_SetBandNodataValue(rtn, 1, newnodata1);
				rtn := ST_AddBand(rtn, ST_MapAlgebraExpr(rast1, band1, rast2, band2, '[rast2.val]', public.ST_BandPixelType(rast2, band2), 'INTERSECTION', newnodata2::text, newnodata2::text, newnodata2));
				rtn := ST_SetBandNodataValue(rtn, 2, newnodata2);
ELSE
				RAISE EXCEPTION 'Unknown value provided for returnband: %', returnband;
RETURN NULL;
END CASE;

RETURN rtn;
END;
	$$;

comment on function st_intersection(raster, integer, raster, integer, text, double precision[]) is 'args: rast1, band1, rast2, band2, returnband, nodataval - Returns a raster or a set of geometry-pixelvalue pairs representing the shared portion of two rasters or the geometrical intersection of a vectorization of the raster and a geometry.';

alter function st_intersection(raster, integer, raster, integer, text, double precision[]) owner to postgres;

create function st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, returnband text, nodataval double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT st_intersection($1, $2, $3, $4, $5, ARRAY[$6, $6]) $$;

alter function st_intersection(raster, integer, raster, integer, text, double precision) owner to postgres;

create function st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, nodataval double precision[]) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT st_intersection($1, $2, $3, $4, 'BOTH', $5) $$;

comment on function st_intersection(raster, integer, raster, integer, double precision[]) is 'args: rast1, band1, rast2, band2, nodataval - Returns a raster or a set of geometry-pixelvalue pairs representing the shared portion of two rasters or the geometrical intersection of a vectorization of the raster and a geometry.';

alter function st_intersection(raster, integer, raster, integer, double precision[]) owner to postgres;

create function st_intersection(rast1 raster, band1 integer, rast2 raster, band2 integer, nodataval double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT st_intersection($1, $2, $3, $4, 'BOTH', ARRAY[$5, $5]) $$;

alter function st_intersection(raster, integer, raster, integer, double precision) owner to postgres;

create function st_intersection(rast1 raster, rast2 raster, returnband text DEFAULT 'BOTH'::text, nodataval double precision[] DEFAULT NULL::double precision[]) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT st_intersection($1, 1, $2, 1, $3, $4) $$;

comment on function st_intersection(raster, raster, text, double precision[]) is 'args: rast1, rast2, returnband, nodataval - Returns a raster or a set of geometry-pixelvalue pairs representing the shared portion of two rasters or the geometrical intersection of a vectorization of the raster and a geometry.';

alter function st_intersection(raster, raster, text, double precision[]) owner to postgres;

create function st_intersection(rast1 raster, rast2 raster, returnband text, nodataval double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT st_intersection($1, 1, $2, 1, $3, ARRAY[$4, $4]) $$;

alter function st_intersection(raster, raster, text, double precision) owner to postgres;

create function st_intersection(rast1 raster, rast2 raster, nodataval double precision[]) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT st_intersection($1, 1, $2, 1, 'BOTH', $3) $$;

comment on function st_intersection(raster, raster, double precision[]) is 'args: rast1, rast2, nodataval - Returns a raster or a set of geometry-pixelvalue pairs representing the shared portion of two rasters or the geometrical intersection of a vectorization of the raster and a geometry.';

alter function st_intersection(raster, raster, double precision[]) owner to postgres;

create function st_intersection(rast1 raster, rast2 raster, nodataval double precision) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT st_intersection($1, 1, $2, 1, 'BOTH', ARRAY[$3, $3]) $$;

alter function st_intersection(raster, raster, double precision) owner to postgres;

create function _st_union_finalfn(internal) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_union_finalfn(internal) owner to postgres;

create function _st_union_transfn(internal, raster, unionarg[]) returns internal
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_union_transfn(internal, raster, unionarg[]) owner to postgres;

create function _st_union_transfn(internal, raster, integer, text) returns internal
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_union_transfn(internal, raster, integer, text) owner to postgres;

create function _st_union_transfn(internal, raster, integer) returns internal
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_union_transfn(internal, raster, integer) owner to postgres;

create function _st_union_transfn(internal, raster) returns internal
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_union_transfn(internal, raster) owner to postgres;

create function _st_union_transfn(internal, raster, text) returns internal
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_union_transfn(internal, raster, text) owner to postgres;

create function _st_clip(rast raster, nband integer[], geom geometry, nodataval double precision[] default NULL::double precision[], crop boolean default true) returns raster
    immutable
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_clip(raster, integer[], geometry, double precision[], boolean) owner to postgres;

create function st_clip(rast raster, nband integer[], geom geometry, nodataval double precision[] DEFAULT NULL::double precision[], crop boolean DEFAULT true) returns raster
    immutable
    parallel safe
    language plpgsql
as
$$
BEGIN
		-- short-cut if geometry's extent fully contains raster's extent
		IF (nodataval IS NULL OR array_length(nodataval, 1) < 1) AND public.ST_Contains(geom, public.ST_Envelope(rast)) THEN
			RETURN rast;
END IF;

RETURN public._ST_Clip($1, $2, $3, $4, $5);
END;
	$$;

comment on function st_clip(raster, integer[], geometry, double precision[], boolean) is 'args: rast, nband, geom, nodataval=NULL, crop=TRUE - Returns the raster clipped by the input geometry. If band number not is specified, all bands are processed. If crop is not specified or TRUE, the output raster is cropped.';

alter function st_clip(raster, integer[], geometry, double precision[], boolean) owner to postgres;

create function st_clip(rast raster, nband integer, geom geometry, nodataval double precision, crop boolean DEFAULT true) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_Clip($1, ARRAY[$2]::integer[], $3, ARRAY[$4]::double precision[], $5) $$;

comment on function st_clip(raster, integer, geometry, double precision, boolean) is 'args: rast, nband, geom, nodataval, crop=TRUE - Returns the raster clipped by the input geometry. If band number not is specified, all bands are processed. If crop is not specified or TRUE, the output raster is cropped.';

alter function st_clip(raster, integer, geometry, double precision, boolean) owner to postgres;

create function st_clip(rast raster, nband integer, geom geometry, crop boolean) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_Clip($1, ARRAY[$2]::integer[], $3, null::double precision[], $4) $$;

comment on function st_clip(raster, integer, geometry, boolean) is 'args: rast, nband, geom, crop - Returns the raster clipped by the input geometry. If band number not is specified, all bands are processed. If crop is not specified or TRUE, the output raster is cropped.';

alter function st_clip(raster, integer, geometry, boolean) owner to postgres;

create function st_clip(rast raster, geom geometry, nodataval double precision[] DEFAULT NULL::double precision[], crop boolean DEFAULT true) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_Clip($1, NULL, $2, $3, $4) $$;

comment on function st_clip(raster, geometry, double precision[], boolean) is 'args: rast, geom, nodataval=NULL, crop=TRUE - Returns the raster clipped by the input geometry. If band number not is specified, all bands are processed. If crop is not specified or TRUE, the output raster is cropped.';

alter function st_clip(raster, geometry, double precision[], boolean) owner to postgres;

create function st_clip(rast raster, geom geometry, nodataval double precision, crop boolean DEFAULT true) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_Clip($1, NULL, $2, ARRAY[$3]::double precision[], $4) $$;

comment on function st_clip(raster, geometry, double precision, boolean) is 'args: rast, geom, nodataval, crop=TRUE - Returns the raster clipped by the input geometry. If band number not is specified, all bands are processed. If crop is not specified or TRUE, the output raster is cropped.';

alter function st_clip(raster, geometry, double precision, boolean) owner to postgres;

create function st_clip(rast raster, geom geometry, crop boolean) returns raster
    immutable
    parallel safe
    language sql
as
$$ SELECT public.ST_Clip($1, NULL, $2, null::double precision[], $3) $$;

comment on function st_clip(raster, geometry, boolean) is 'args: rast, geom, crop - Returns the raster clipped by the input geometry. If band number not is specified, all bands are processed. If crop is not specified or TRUE, the output raster is cropped.';

alter function st_clip(raster, geometry, boolean) owner to postgres;

create function st_nearestvalue(rast raster, band integer, pt geometry, exclude_nodata_value boolean default true) returns double precision
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function st_nearestvalue(raster, integer, geometry, boolean) is 'args: rast, bandnum, pt, exclude_nodata_value=true - Returns the nearest non-NODATA value of a given bands pixel specified by a columnx and rowy or a geometric point expressed in the same spatial reference coordinate system as the raster.';

alter function st_nearestvalue(raster, integer, geometry, boolean) owner to postgres;

create function st_nearestvalue(rast raster, pt geometry, exclude_nodata_value boolean DEFAULT true) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT st_nearestvalue($1, 1, $2, $3) $$;

comment on function st_nearestvalue(raster, geometry, boolean) is 'args: rast, pt, exclude_nodata_value=true - Returns the nearest non-NODATA value of a given bands pixel specified by a columnx and rowy or a geometric point expressed in the same spatial reference coordinate system as the raster.';

alter function st_nearestvalue(raster, geometry, boolean) owner to postgres;

create function st_nearestvalue(rast raster, band integer, columnx integer, rowy integer, exclude_nodata_value boolean DEFAULT true) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT st_nearestvalue($1, $2, st_setsrid(st_makepoint(st_rastertoworldcoordx($1, $3, $4), st_rastertoworldcoordy($1, $3, $4)), st_srid($1)), $5) $$;

comment on function st_nearestvalue(raster, integer, integer, integer, boolean) is 'args: rast, bandnum, columnx, rowy, exclude_nodata_value=true - Returns the nearest non-NODATA value of a given bands pixel specified by a columnx and rowy or a geometric point expressed in the same spatial reference coordinate system as the raster.';

alter function st_nearestvalue(raster, integer, integer, integer, boolean) owner to postgres;

create function st_nearestvalue(rast raster, columnx integer, rowy integer, exclude_nodata_value boolean DEFAULT true) returns double precision
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT st_nearestvalue($1, 1, st_setsrid(st_makepoint(st_rastertoworldcoordx($1, $2, $3), st_rastertoworldcoordy($1, $2, $3)), st_srid($1)), $4) $$;

comment on function st_nearestvalue(raster, integer, integer, boolean) is 'args: rast, columnx, rowy, exclude_nodata_value=true - Returns the nearest non-NODATA value of a given bands pixel specified by a columnx and rowy or a geometric point expressed in the same spatial reference coordinate system as the raster.';

alter function st_nearestvalue(raster, integer, integer, boolean) owner to postgres;

create function _st_neighborhood(rast raster, band integer, columnx integer, rowy integer, distancex integer, distancey integer, exclude_nodata_value boolean default true) returns double precision[]
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function _st_neighborhood(raster, integer, integer, integer, integer, integer, boolean) owner to postgres;

create function st_neighborhood(rast raster, band integer, columnx integer, rowy integer, distancex integer, distancey integer, exclude_nodata_value boolean DEFAULT true) returns double precision[]
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_neighborhood($1, $2, $3, $4, $5, $6, $7) $$;

comment on function st_neighborhood(raster, integer, integer, integer, integer, integer, boolean) is 'args: rast, bandnum, columnX, rowY, distanceX, distanceY, exclude_nodata_value=true - Returns a 2-D double precision array of the non-NODATA values around a given bands pixel specified by either a columnX and rowY or a geometric point expressed in the same spatial reference coordinate system as the raster.';

alter function st_neighborhood(raster, integer, integer, integer, integer, integer, boolean) owner to postgres;

create function st_neighborhood(rast raster, columnx integer, rowy integer, distancex integer, distancey integer, exclude_nodata_value boolean DEFAULT true) returns double precision[]
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT public._ST_neighborhood($1, 1, $2, $3, $4, $5, $6) $$;

comment on function st_neighborhood(raster, integer, integer, integer, integer, boolean) is 'args: rast, columnX, rowY, distanceX, distanceY, exclude_nodata_value=true - Returns a 2-D double precision array of the non-NODATA values around a given bands pixel specified by either a columnX and rowY or a geometric point expressed in the same spatial reference coordinate system as the raster.';

alter function st_neighborhood(raster, integer, integer, integer, integer, boolean) owner to postgres;

create function st_neighborhood(rast raster, band integer, pt geometry, distancex integer, distancey integer, exclude_nodata_value boolean DEFAULT true) returns double precision[]
    immutable
    strict
    parallel safe
    language plpgsql
as
$$
DECLARE
wx double precision;
		wy double precision;
		rtn double precision[][];
BEGIN
		IF (st_geometrytype($3) != 'ST_Point') THEN
			RAISE EXCEPTION 'Attempting to get the neighbor of a pixel with a non-point geometry';
END IF;

		IF ST_SRID(rast) != ST_SRID(pt) THEN
			RAISE EXCEPTION 'Raster and geometry do not have the same SRID';
END IF;

		wx := st_x($3);
		wy := st_y($3);

SELECT public._ST_neighborhood(
        $1, $2,
    st_worldtorastercoordx(rast, wx, wy),
    st_worldtorastercoordy(rast, wx, wy),
    $4, $5,
    $6
    ) INTO rtn;
RETURN rtn;
END;
	$$;

comment on function st_neighborhood(raster, integer, geometry, integer, integer, boolean) is 'args: rast, bandnum, pt, distanceX, distanceY, exclude_nodata_value=true - Returns a 2-D double precision array of the non-NODATA values around a given bands pixel specified by either a columnX and rowY or a geometric point expressed in the same spatial reference coordinate system as the raster.';

alter function st_neighborhood(raster, integer, geometry, integer, integer, boolean) owner to postgres;

create function st_neighborhood(rast raster, pt geometry, distancex integer, distancey integer, exclude_nodata_value boolean DEFAULT true) returns double precision[]
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT st_neighborhood($1, 1, $2, $3, $4, $5) $$;

comment on function st_neighborhood(raster, geometry, integer, integer, boolean) is 'args: rast, pt, distanceX, distanceY, exclude_nodata_value=true - Returns a 2-D double precision array of the non-NODATA values around a given bands pixel specified by either a columnX and rowY or a geometric point expressed in the same spatial reference coordinate system as the raster.';

alter function st_neighborhood(raster, geometry, integer, integer, boolean) owner to postgres;

create function _add_raster_constraint(cn name, sql text) returns boolean
    strict
    language plpgsql
as
$$
BEGIN
BEGIN
EXECUTE sql;
EXCEPTION
			WHEN duplicate_object THEN
				RAISE NOTICE 'The constraint "%" already exists.  To replace the existing constraint, delete the constraint and call ApplyRasterConstraints again', cn;
WHEN OTHERS THEN
				RAISE NOTICE 'Unable to add constraint: %', cn;
				RAISE NOTICE 'SQL used for failed constraint: %', sql;
				RAISE NOTICE 'Returned error message: % (%)', SQLERRM, SQLSTATE;
RETURN FALSE;
END;

RETURN TRUE;
END;
	$$;

alter function _add_raster_constraint(name, text) owner to postgres;

create function _drop_raster_constraint(rastschema name, rasttable name, cn name) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

BEGIN
EXECUTE 'ALTER TABLE '
    || fqtn
    || ' DROP CONSTRAINT '
    || quote_ident(cn);
RETURN TRUE;
EXCEPTION
			WHEN undefined_object THEN
				RAISE NOTICE 'The constraint "%" does not exist.  Skipping', cn;
WHEN OTHERS THEN
				RAISE NOTICE 'Unable to drop constraint "%": % (%)',
          cn, SQLERRM, SQLSTATE;
RETURN FALSE;
END;

RETURN TRUE;
END;
	$$;

alter function _drop_raster_constraint(name, name, name) owner to postgres;

create function _raster_constraint_info_srid(rastschema name, rasttable name, rastcolumn name) returns integer
    stable
    strict
    language sql
as
$$
SELECT
    regexp_replace(
            split_part(s.consrc, ' = ', 2),
            '[\(\)]', '', 'g'
        )::integer
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%st_srid(% = %';
$$;

alter function _raster_constraint_info_srid(name, name, name) owner to postgres;

create function _add_raster_constraint_srid(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;
		attr int;
BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_srid_' || $3;

sql := 'SELECT st_srid('
			|| quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' WHERE '
			|| quote_ident($3)
			|| ' IS NOT NULL LIMIT 1;';
BEGIN
EXECUTE sql INTO attr;
EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the SRID of a sample raster: % (%)',
        SQLERRM, SQLSTATE;
RETURN FALSE;
END;

sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_srid('
			|| quote_ident($3)
			|| ') = ' || attr || ')';

RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_raster_constraint_srid(name, name, name) owner to postgres;

create function _drop_raster_constraint_srid(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language sql
as
$$ SELECT  public._drop_raster_constraint($1, $2, 'enforce_srid_' || $3) $$;

alter function _drop_raster_constraint_srid(name, name, name) owner to postgres;

create function _raster_constraint_info_scale(rastschema name, rasttable name, rastcolumn name, axis character) returns double precision
    stable
    strict
    language sql
as
$$
	WITH c AS (SELECT
		regexp_replace(
			replace(
				split_part(
					split_part(s.consrc, ' = ', 2),
					'::', 1
				),
				'round(', ''
			),
			'[ ''''\(\)]', '', 'g'
		)::text AS val
	FROM pg_class c, pg_namespace n, pg_attribute a
		, (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
		    FROM pg_constraint) AS s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%st_scale' || $4 || '(% = %')
-- if it is a comma separated list of two numbers then need to use round
SELECT CASE WHEN split_part(c.val,',', 2) > ''
                THEN round( split_part(c.val, ',',1)::numeric, split_part(c.val,',',2)::integer )::float8
            ELSE c.val::float8 END
FROM c;
$$;

alter function _raster_constraint_info_scale(name, name, name, char) owner to postgres;

create function _add_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;
		attr double precision;
BEGIN
		IF lower($4) != 'x' AND lower($4) != 'y' THEN
			RAISE EXCEPTION 'axis must be either "x" or "y"';
RETURN FALSE;
END IF;

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_scale' || $4 || '_' || $3;

sql := 'SELECT st_scale' || $4 || '('
			|| quote_ident($3)
			|| ') FROM '
			|| fqtn
			|| ' WHERE '
			|| quote_ident($3)
			|| ' IS NOT NULL LIMIT 1;';
BEGIN
EXECUTE sql INTO attr;
EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the %-scale of a sample raster: % (%)',
        upper($4), SQLERRM, SQLSTATE;
RETURN FALSE;
END;

sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (round(st_scale' || $4 || '('
			|| quote_ident($3)
			|| ')::numeric, 10) = round(' || text(attr) || '::numeric, 10))';
RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_raster_constraint_scale(name, name, name, char) owner to postgres;

create function _drop_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) returns boolean
    strict
    language plpgsql
as
$$
BEGIN
		IF lower($4) != 'x' AND lower($4) != 'y' THEN
			RAISE EXCEPTION 'axis must be either "x" or "y"';
RETURN FALSE;
END IF;

RETURN  public._drop_raster_constraint($1, $2, 'enforce_scale' || $4 || '_' || $3);
END;
	$$;

alter function _drop_raster_constraint_scale(name, name, name, char) owner to postgres;

create function _raster_constraint_info_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) returns integer
    stable
    strict
    language sql
as
$$
SELECT
    CASE
        WHEN strpos(s.consrc, 'ANY (ARRAY[') > 0 THEN
            split_part((substring(s.consrc FROM E'ARRAY\\[(.*?){1}\\]')), ',', 1)::integer
			ELSE
				regexp_replace(
					split_part(s.consrc, '= ', 2),
					'[\(\)]', '', 'g'
				)::integer
END
FROM pg_class c, pg_namespace n, pg_attribute a
		, (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
			FROM pg_constraint) AS s
	WHERE n.nspname = $1
		AND c.relname = $2
		AND a.attname = $3
		AND a.attrelid = c.oid
		AND s.connamespace = n.oid
		AND s.conrelid = c.oid
		AND a.attnum = ANY (s.conkey)
		AND s.consrc LIKE '%st_' || $4 || '(%= %';
	$$;

alter function _raster_constraint_info_blocksize(name, name, name, text) owner to postgres;

create function _add_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;
		attrset integer[];
		attr integer;
BEGIN
		IF lower($4) != 'width' AND lower($4) != 'height' THEN
			RAISE EXCEPTION 'axis must be either "width" or "height"';
RETURN FALSE;
END IF;

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_' || $4 || '_' || $3;

sql := 'SELECT st_' || $4 || '('
			|| quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' GROUP BY 1 ORDER BY count(*) DESC';
BEGIN
			attrset := ARRAY[]::integer[];
FOR attr IN EXECUTE sql LOOP
				attrset := attrset || attr;
END LOOP;
EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the % of a sample raster: % (%)',
        $4, SQLERRM, SQLSTATE;
RETURN FALSE;
END;

sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_' || $4 || '('
			|| quote_ident($3)
			|| ') IN (' || array_to_string(attrset, ',') || '))';
RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_raster_constraint_blocksize(name, name, name, text) owner to postgres;

create function _drop_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) returns boolean
    strict
    language plpgsql
as
$$
BEGIN
		IF lower($4) != 'width' AND lower($4) != 'height' THEN
			RAISE EXCEPTION 'axis must be either "width" or "height"';
RETURN FALSE;
END IF;

RETURN  public._drop_raster_constraint($1, $2, 'enforce_' || $4 || '_' || $3);
END;
	$$;

alter function _drop_raster_constraint_blocksize(name, name, name, text) owner to postgres;

create function _raster_constraint_info_extent(rastschema name, rasttable name, rastcolumn name) returns geometry
    stable
    strict
    language sql
as
$$
SELECT
    trim(both '''' from split_part(trim(split_part(s.consrc, ' @ ', 2)), '::', 1))::geometry
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%st_envelope(% @ %';
$$;

alter function _raster_constraint_info_extent(name, name, name) owner to postgres;

create function _add_raster_constraint_extent(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    cost 9000
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;
		attr text; srid integer;
BEGIN
		fqtn := '';
		IF length(rastschema) > 0 THEN
			fqtn := quote_ident(rastschema) || '.';
END IF;
		fqtn := fqtn || quote_ident(rasttable);

sql := 'SELECT public.ST_SRID('
			|| quote_ident(rastcolumn)
			|| ') FROM '
			|| fqtn
			|| ' WHERE '
			|| quote_ident(rastcolumn)
			|| ' IS NOT NULL LIMIT 1;';
EXECUTE sql INTO srid;

IF srid IS NULL THEN
      RETURN false;
END IF;

		cn := 'enforce_max_extent_' || rastcolumn;

sql := 'SELECT public.st_ashexewkb( public.st_setsrid( public.st_extent( public.st_envelope('
			|| quote_ident(rastcolumn)
			|| ')), ' || srid || ')) FROM '
			|| fqtn;
EXECUTE sql INTO attr;

-- NOTE: I put NOT VALID to prevent the costly step of validating the constraint
sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK ( public.st_envelope('
			|| quote_ident(rastcolumn)
			|| ') @ ''' || attr || '''::geometry) NOT VALID';
RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_raster_constraint_extent(name, name, name) owner to postgres;

create function _drop_raster_constraint_extent(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language sql
as
$$ SELECT  public._drop_raster_constraint($1, $2, 'enforce_max_extent_' || $3) $$;

alter function _drop_raster_constraint_extent(name, name, name) owner to postgres;

create function _raster_constraint_info_alignment(rastschema name, rasttable name, rastcolumn name) returns boolean
    stable
    strict
    language sql
as
$$
SELECT
    TRUE
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%st_samealignment(%';
$$;

alter function _raster_constraint_info_alignment(name, name, name) owner to postgres;

create function _add_raster_constraint_alignment(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;
		attr text;
BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_same_alignment_' || $3;

sql := 'SELECT public.st_makeemptyraster(1, 1, upperleftx, upperlefty, scalex, scaley, skewx, skewy, srid) FROM public.st_metadata((SELECT '
			|| quote_ident($3)
			|| ' FROM '
			|| fqtn
			|| ' WHERE '
			|| quote_ident($3)
			|| ' IS NOT NULL LIMIT 1))';
BEGIN
EXECUTE sql INTO attr;
EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the alignment of a sample raster: % (%)',
        SQLERRM, SQLSTATE;
RETURN FALSE;
END;

sql := 'ALTER TABLE ' || fqtn ||
			' ADD CONSTRAINT ' || quote_ident(cn) ||
			' CHECK (st_samealignment(' || quote_ident($3) || ', ''' || attr || '''::raster))';
RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_raster_constraint_alignment(name, name, name) owner to postgres;

create function _drop_raster_constraint_alignment(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language sql
as
$$ SELECT  public._drop_raster_constraint($1, $2, 'enforce_same_alignment_' || $3) $$;

alter function _drop_raster_constraint_alignment(name, name, name) owner to postgres;

create function _raster_constraint_info_spatially_unique(rastschema name, rasttable name, rastcolumn name) returns boolean
    stable
    strict
    language sql
as
$$
SELECT
    TRUE
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conindid, conkey, contype, conexclop, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
   , pg_index idx, pg_operator op
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND s.contype = 'x'
  AND 0::smallint = ANY (s.conkey)
		AND idx.indexrelid = s.conindid
		AND pg_get_indexdef(idx.indexrelid, 1, true) LIKE '(' || quote_ident($3) || '::geometry)'
		AND s.conexclop[1] = op.oid
		AND op.oprname = '=';
$$;

alter function _raster_constraint_info_spatially_unique(name, name, name) owner to postgres;

create function _add_raster_constraint_spatially_unique(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;
		attr text;
		meta record;
BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_spatially_unique_' || quote_ident($2) || '_'|| $3;

sql := 'ALTER TABLE ' || fqtn ||
			' ADD CONSTRAINT ' || quote_ident(cn) ||
			' EXCLUDE ((' || quote_ident($3) || '::geometry) WITH =)';
RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_raster_constraint_spatially_unique(name, name, name) owner to postgres;

create function _drop_raster_constraint_spatially_unique(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
cn text;
BEGIN
SELECT
    s.conname INTO cn
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conname, conrelid, conkey, conindid, contype, conexclop, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
   , pg_index idx, pg_operator op
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND s.contype = 'x'
  AND 0::smallint = ANY (s.conkey)
			AND idx.indexrelid = s.conindid
			AND pg_get_indexdef(idx.indexrelid, 1, true) LIKE '(' || quote_ident($3) || '::geometry)'
			AND s.conexclop[1] = op.oid
			AND op.oprname = '=';

RETURN  public._drop_raster_constraint($1, $2, cn);
END;
	$$;

alter function _drop_raster_constraint_spatially_unique(name, name, name) owner to postgres;

create function _raster_constraint_info_coverage_tile(rastschema name, rasttable name, rastcolumn name) returns boolean
    stable
    strict
    language sql
as
$$
SELECT
    TRUE
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%st_iscoveragetile(%';
$$;

alter function _raster_constraint_info_coverage_tile(name, name, name) owner to postgres;

create function _add_raster_constraint_coverage_tile(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;

		_scalex double precision;
		_scaley double precision;
		_skewx double precision;
		_skewy double precision;
		_tilewidth integer;
		_tileheight integer;
		_alignment boolean;

		_covextent public.geometry;
		_covrast public.raster;
BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_coverage_tile_' || $3;

		-- metadata
BEGIN
sql := 'WITH foo AS (SELECT public.ST_Metadata(' || quote_ident($3) || ') AS meta, public.ST_ConvexHull(' || quote_ident($3) || ') AS hull FROM ' || fqtn || ') SELECT max((meta).scalex), max((meta).scaley), max((meta).skewx), max((meta).skewy), max((meta).width), max((meta).height), public.ST_Union(hull) FROM foo';
EXECUTE sql INTO _scalex, _scaley, _skewx, _skewy, _tilewidth, _tileheight, _covextent;
EXCEPTION WHEN OTHERS THEN
			RAISE DEBUG 'Unable to get coverage metadata for %.%: % (%)',
        fqtn, quote_ident($3), SQLERRM, SQLSTATE;
      -- TODO: Why not return false here ?
END;

		-- rasterize extent
BEGIN
_covrast := public.ST_AsRaster(_covextent, _scalex, _scaley, '8BUI', 1, 0, NULL, NULL, _skewx, _skewy);
			IF _covrast IS NULL THEN
				RAISE NOTICE 'Unable to create coverage raster. Cannot add coverage tile constraint: % (%)',
          SQLERRM, SQLSTATE;
RETURN FALSE;
END IF;

			-- remove band
_covrast := ST_MakeEmptyRaster(_covrast);
EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to create coverage raster. Cannot add coverage tile constraint: % (%)',
        SQLERRM, SQLSTATE;
RETURN FALSE;
END;

sql := 'ALTER TABLE ' || fqtn ||
			' ADD CONSTRAINT ' || quote_ident(cn) ||
			' CHECK (st_iscoveragetile(' || quote_ident($3) || ', ''' || _covrast || '''::raster, ' || _tilewidth || ', ' || _tileheight || '))';
RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_raster_constraint_coverage_tile(name, name, name) owner to postgres;

create function _drop_raster_constraint_coverage_tile(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language sql
as
$$ SELECT  public._drop_raster_constraint($1, $2, 'enforce_coverage_tile_' || $3) $$;

alter function _drop_raster_constraint_coverage_tile(name, name, name) owner to postgres;

create function _raster_constraint_info_regular_blocking(rastschema name, rasttable name, rastcolumn name) returns boolean
    stable
    strict
    language plpgsql
as
$$
DECLARE
covtile boolean;
		spunique boolean;
BEGIN
		-- check existance of constraints
		-- coverage tile constraint
		covtile := COALESCE( public._raster_constraint_info_coverage_tile($1, $2, $3), FALSE);

		-- spatially unique constraint
		spunique := COALESCE( public._raster_constraint_info_spatially_unique($1, $2, $3), FALSE);

RETURN (covtile AND spunique);
END;
	$$;

alter function _raster_constraint_info_regular_blocking(name, name, name) owner to postgres;

create function _drop_raster_constraint_regular_blocking(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language sql
as
$$ SELECT public._drop_raster_constraint($1, $2, 'enforce_regular_blocking_' || $3) $$;

alter function _drop_raster_constraint_regular_blocking(name, name, name) owner to postgres;

create function _raster_constraint_info_num_bands(rastschema name, rasttable name, rastcolumn name) returns integer
    stable
    strict
    language sql
as
$$
SELECT
    regexp_replace(
            split_part(s.consrc, ' = ', 2),
            '[\(\)]', '', 'g'
        )::integer
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%st_numbands(%';
$$;

alter function _raster_constraint_info_num_bands(name, name, name) owner to postgres;

create function _add_raster_constraint_num_bands(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;
		attr int;
BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_num_bands_' || $3;

sql := 'SELECT public.st_numbands(' || quote_ident($3)
			|| ') FROM '
			|| fqtn
			|| ' WHERE '
			|| quote_ident($3)
			|| ' IS NOT NULL LIMIT 1;';
BEGIN
EXECUTE sql INTO attr;
EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the number of bands of a sample raster: % (%)',
        SQLERRM, SQLSTATE;
RETURN FALSE;
END;

sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (public.st_numbands(' || quote_ident($3)
			|| ') = ' || attr
			|| ')';
RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_raster_constraint_num_bands(name, name, name) owner to postgres;

create function _drop_raster_constraint_num_bands(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language sql
as
$$ SELECT  public._drop_raster_constraint($1, $2, 'enforce_num_bands_' || $3) $$;

alter function _drop_raster_constraint_num_bands(name, name, name) owner to postgres;

create function _raster_constraint_info_pixel_types(rastschema name, rasttable name, rastcolumn name) returns text[]
    stable
    strict
    language sql
as
$$
SELECT
    trim(
            both '''' from split_part(
            regexp_replace(
                    split_part(s.consrc, ' = ', 2),
                    '[\(\)]', '', 'g'
                ),
            '::', 1
        )
        )::text[]
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%_raster_constraint_pixel_types(%';
$$;

alter function _raster_constraint_info_pixel_types(name, name, name) owner to postgres;

create function _raster_constraint_pixel_types(rast raster) returns text[]
    stable
    strict
    language sql
as
$$ SELECT array_agg(pixeltype)::text[] FROM  public.ST_BandMetaData($1, ARRAY[]::int[]); $$;

alter function _raster_constraint_pixel_types(raster) owner to postgres;

create function _add_raster_constraint_pixel_types(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;
		attr text[];
max int;
BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_pixel_types_' || $3;

sql := 'SELECT public._raster_constraint_pixel_types(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' WHERE '
			|| quote_ident($3)
			|| ' IS NOT NULL LIMIT 1;';
BEGIN
EXECUTE sql INTO attr;
EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the pixel types of a sample raster: % (%)',
        SQLERRM, SQLSTATE;
RETURN FALSE;
END;
max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the pixel types of a sample raster (max < 1 or null)';
RETURN FALSE;
END IF;

sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_pixel_types(' || quote_ident($3)
			|| ') = ''{';
FOR x in 1..max LOOP
			sql := sql || '"' || attr[x] || '"';
			IF x < max THEN
				sql := sql || ',';
END IF;
END LOOP;
sql := sql || '}''::text[])';

RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_raster_constraint_pixel_types(name, name, name) owner to postgres;

create function _drop_raster_constraint_pixel_types(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language sql
as
$$ SELECT  public._drop_raster_constraint($1, $2, 'enforce_pixel_types_' || $3) $$;

alter function _drop_raster_constraint_pixel_types(name, name, name) owner to postgres;

create function _raster_constraint_info_nodata_values(rastschema name, rasttable name, rastcolumn name) returns double precision[]
    stable
    strict
    language sql
as
$$
SELECT
    trim(both '''' from
         split_part(
                 regexp_replace(
                         split_part(s.consrc, ' = ', 2),
                         '[\(\)]', '', 'g'
                     ),
                 '::', 1
             )
        )::double precision[]
FROM pg_class c, pg_namespace n, pg_attribute a
        , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
    FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%_raster_constraint_nodata_values(%';
$$;

alter function _raster_constraint_info_nodata_values(name, name, name) owner to postgres;

create function _raster_constraint_nodata_values(rast raster) returns numeric[]
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT array_agg(round(nodatavalue::numeric, 10))::numeric[] FROM public.ST_BandMetaData($1, ARRAY[]::int[]); $$;

alter function _raster_constraint_nodata_values(raster) owner to postgres;

create function _add_raster_constraint_nodata_values(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;
		attr numeric[];
max int;
BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_nodata_values_' || $3;

sql := 'SELECT public._raster_constraint_nodata_values(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' WHERE '
			|| quote_ident($3)
			|| ' IS NOT NULL LIMIT 1;';
BEGIN
EXECUTE sql INTO attr;
EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the nodata values of a sample raster: % (%)',
        SQLERRM, SQLSTATE;
RETURN FALSE;
END;
max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the nodata values of a sample raster (max < 1 or null)';
RETURN FALSE;
END IF;

sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_nodata_values(' || quote_ident($3)
			|| ')::numeric[] = ''{';
FOR x in 1..max LOOP
			IF attr[x] IS NULL THEN
				sql := sql || 'NULL';
ELSE
				sql := sql || attr[x];
END IF;
			IF x < max THEN
				sql := sql || ',';
END IF;
END LOOP;
sql := sql || '}''::numeric[])';

RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_raster_constraint_nodata_values(name, name, name) owner to postgres;

create function _drop_raster_constraint_nodata_values(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language sql
as
$$ SELECT  public._drop_raster_constraint($1, $2, 'enforce_nodata_values_' || $3) $$;

alter function _drop_raster_constraint_nodata_values(name, name, name) owner to postgres;

create function _raster_constraint_info_out_db(rastschema name, rasttable name, rastcolumn name) returns boolean[]
    stable
    strict
    language sql
as
$$
SELECT
    trim(
            both '''' from split_part(
            regexp_replace(
                    split_part(s.consrc, ' = ', 2),
                    '[\(\)]', '', 'g'
                ),
            '::', 1
        )
        )::boolean[]
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%_raster_constraint_out_db(%';
$$;

alter function _raster_constraint_info_out_db(name, name, name) owner to postgres;

create function _raster_constraint_out_db(rast raster) returns boolean[]
    immutable
    strict
    parallel safe
    language sql
as
$$ SELECT array_agg(isoutdb)::boolean[] FROM public.ST_BandMetaData($1, ARRAY[]::int[]); $$;

alter function _raster_constraint_out_db(raster) owner to postgres;

create function _add_raster_constraint_out_db(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;
		attr boolean[];
max int;
BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_out_db_' || $3;

sql := 'SELECT public._raster_constraint_out_db(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' WHERE '
			|| quote_ident($3)
			|| ' IS NOT NULL LIMIT 1;';
BEGIN
EXECUTE sql INTO attr;
EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the out-of-database bands of a sample raster: % (%)',
        SQLERRM, SQLSTATE;
RETURN FALSE;
END;
max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the out-of-database bands of a sample raster (max < 1 or null)';
RETURN FALSE;
END IF;

sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK ( public._raster_constraint_out_db(' || quote_ident($3)
			|| ') = ''{';
FOR x in 1..max LOOP
			IF attr[x] IS FALSE THEN
				sql := sql || 'FALSE';
ELSE
				sql := sql || 'TRUE';
END IF;
			IF x < max THEN
				sql := sql || ',';
END IF;
END LOOP;
sql := sql || '}''::boolean[])';

RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_raster_constraint_out_db(name, name, name) owner to postgres;

create function _drop_raster_constraint_out_db(rastschema name, rasttable name, rastcolumn name) returns boolean
    strict
    language sql
as
$$ SELECT  public._drop_raster_constraint($1, $2, 'enforce_out_db_' || $3) $$;

alter function _drop_raster_constraint_out_db(name, name, name) owner to postgres;

create function _raster_constraint_info_index(rastschema name, rasttable name, rastcolumn name) returns boolean
    stable
    strict
    language sql
as
$$
SELECT
    TRUE
FROM pg_catalog.pg_class c
         JOIN pg_catalog.pg_index i
              ON i.indexrelid = c.oid
         JOIN pg_catalog.pg_class c2
              ON i.indrelid = c2.oid
         JOIN pg_catalog.pg_namespace n
              ON n.oid = c.relnamespace
         JOIN pg_am am
              ON c.relam = am.oid
         JOIN pg_attribute att
              ON att.attrelid = c2.oid
                  AND pg_catalog.format_type(att.atttypid, att.atttypmod) = 'raster'
WHERE c.relkind IN ('i')
  AND n.nspname = $1
  AND c2.relname = $2
  AND att.attname = $3
  AND am.amname = 'gist'
  AND strpos(pg_catalog.pg_get_expr(i.indexprs, i.indrelid), att.attname) > 0;
$$;

alter function _raster_constraint_info_index(name, name, name) owner to postgres;

create function addrasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
max int;
		cnt int;
sql text;
schema name;
		x int;
		kw text;
		rtn boolean;
BEGIN
		cnt := 0;
max := array_length(constraints, 1);
		IF max < 1 THEN
			RAISE NOTICE 'No constraints indicated to be added.  Doing nothing';
RETURN TRUE;
END IF;

		-- validate schema
schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
EXECUTE sql INTO schema;

IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
RETURN FALSE;
END IF;
END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
EXECUTE sql INTO schema;

IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
RETURN FALSE;
END IF;
END IF;

<<kwloop>>
		FOR x in 1..max LOOP
			kw := trim(both from lower(constraints[x]));

BEGIN
CASE
					WHEN kw = 'srid' THEN
						RAISE NOTICE 'Adding SRID constraint';
						rtn :=  public._add_raster_constraint_srid(schema, $2, $3);
WHEN kw IN ('scale_x', 'scalex') THEN
						RAISE NOTICE 'Adding scale-X constraint';
						rtn :=  public._add_raster_constraint_scale(schema, $2, $3, 'x');
WHEN kw IN ('scale_y', 'scaley') THEN
						RAISE NOTICE 'Adding scale-Y constraint';
						rtn :=  public._add_raster_constraint_scale(schema, $2, $3, 'y');
WHEN kw = 'scale' THEN
						RAISE NOTICE 'Adding scale-X constraint';
						rtn :=  public._add_raster_constraint_scale(schema, $2, $3, 'x');
						RAISE NOTICE 'Adding scale-Y constraint';
						rtn :=  public._add_raster_constraint_scale(schema, $2, $3, 'y');
WHEN kw IN ('blocksize_x', 'blocksizex', 'width') THEN
						RAISE NOTICE 'Adding blocksize-X constraint';
						rtn :=  public._add_raster_constraint_blocksize(schema, $2, $3, 'width');
WHEN kw IN ('blocksize_y', 'blocksizey', 'height') THEN
						RAISE NOTICE 'Adding blocksize-Y constraint';
						rtn :=  public._add_raster_constraint_blocksize(schema, $2, $3, 'height');
WHEN kw = 'blocksize' THEN
						RAISE NOTICE 'Adding blocksize-X constraint';
						rtn :=  public._add_raster_constraint_blocksize(schema, $2, $3, 'width');
						RAISE NOTICE 'Adding blocksize-Y constraint';
						rtn :=  public._add_raster_constraint_blocksize(schema, $2, $3, 'height');
WHEN kw IN ('same_alignment', 'samealignment', 'alignment') THEN
						RAISE NOTICE 'Adding alignment constraint';
						rtn :=  public._add_raster_constraint_alignment(schema, $2, $3);
WHEN kw IN ('regular_blocking', 'regularblocking') THEN
						RAISE NOTICE 'Adding coverage tile constraint required for regular blocking';
						rtn :=  public._add_raster_constraint_coverage_tile(schema, $2, $3);
						IF rtn IS NOT FALSE THEN
							RAISE NOTICE 'Adding spatially unique constraint required for regular blocking';
							rtn :=  public._add_raster_constraint_spatially_unique(schema, $2, $3);
END IF;
WHEN kw IN ('num_bands', 'numbands') THEN
						RAISE NOTICE 'Adding number of bands constraint';
						rtn :=  public._add_raster_constraint_num_bands(schema, $2, $3);
WHEN kw IN ('pixel_types', 'pixeltypes') THEN
						RAISE NOTICE 'Adding pixel type constraint';
						rtn :=  public._add_raster_constraint_pixel_types(schema, $2, $3);
WHEN kw IN ('nodata_values', 'nodatavalues', 'nodata') THEN
						RAISE NOTICE 'Adding nodata value constraint';
						rtn :=  public._add_raster_constraint_nodata_values(schema, $2, $3);
WHEN kw IN ('out_db', 'outdb') THEN
						RAISE NOTICE 'Adding out-of-database constraint';
						rtn :=  public._add_raster_constraint_out_db(schema, $2, $3);
WHEN kw = 'extent' THEN
						RAISE NOTICE 'Adding maximum extent constraint';
						rtn :=  public._add_raster_constraint_extent(schema, $2, $3);
ELSE
						RAISE NOTICE 'Unknown constraint: %.  Skipping', quote_literal(constraints[x]);
CONTINUE kwloop;
END CASE;
END;

			IF rtn IS FALSE THEN
				cnt := cnt + 1;
				RAISE WARNING 'Unable to add constraint: %.  Skipping', quote_literal(constraints[x]);
END IF;

END LOOP kwloop;

		IF cnt = max THEN
			RAISE EXCEPTION 'None of the constraints specified could be added.  Is the schema name, table name or column name incorrect?';
RETURN FALSE;
END IF;

RETURN TRUE;
END;
	$$;

comment on function addrasterconstraints(name, name, name, text[]) is 'args: rastschema, rasttable, rastcolumn, VARIADIC constraints - Adds raster constraints to a loaded raster table for a specific column that constrains spatial ref, scaling, blocksize, alignment, bands, band type and a flag to denote if raster column is regularly blocked. The table must be loaded with data for the constraints to be inferred. Returns true if the constraint setting was accomplished and issues a notice otherwise.';

alter function addrasterconstraints(name, name, name, text[]) owner to postgres;

create function addrasterconstraints(rasttable name, rastcolumn name, VARIADIC constraints text[]) returns boolean
    strict
    language sql
as
$$ SELECT public.AddRasterConstraints('', $1, $2, VARIADIC $3) $$;

comment on function addrasterconstraints(name, name, text[]) is 'args: rasttable, rastcolumn, VARIADIC constraints - Adds raster constraints to a loaded raster table for a specific column that constrains spatial ref, scaling, blocksize, alignment, bands, band type and a flag to denote if raster column is regularly blocked. The table must be loaded with data for the constraints to be inferred. Returns true if the constraint setting was accomplished and issues a notice otherwise.';

alter function addrasterconstraints(name, name, text[]) owner to postgres;

create function addrasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT false, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
constraints text[];
BEGIN
		IF srid IS TRUE THEN
			constraints := constraints || 'srid'::text;
END IF;

		IF scale_x IS TRUE THEN
			constraints := constraints || 'scale_x'::text;
END IF;

		IF scale_y IS TRUE THEN
			constraints := constraints || 'scale_y'::text;
END IF;

		IF blocksize_x IS TRUE THEN
			constraints := constraints || 'blocksize_x'::text;
END IF;

		IF blocksize_y IS TRUE THEN
			constraints := constraints || 'blocksize_y'::text;
END IF;

		IF same_alignment IS TRUE THEN
			constraints := constraints || 'same_alignment'::text;
END IF;

		IF regular_blocking IS TRUE THEN
			constraints := constraints || 'regular_blocking'::text;
END IF;

		IF num_bands IS TRUE THEN
			constraints := constraints || 'num_bands'::text;
END IF;

		IF pixel_types IS TRUE THEN
			constraints := constraints || 'pixel_types'::text;
END IF;

		IF nodata_values IS TRUE THEN
			constraints := constraints || 'nodata_values'::text;
END IF;

		IF out_db IS TRUE THEN
			constraints := constraints || 'out_db'::text;
END IF;

		IF extent IS TRUE THEN
			constraints := constraints || 'extent'::text;
END IF;

RETURN public.AddRasterConstraints($1, $2, $3, VARIADIC constraints);
END;
	$$;

comment on function addrasterconstraints(name, name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) is 'args: rastschema, rasttable, rastcolumn, srid=true, scale_x=true, scale_y=true, blocksize_x=true, blocksize_y=true, same_alignment=true, regular_blocking=false, num_bands=true, pixel_types=true, nodata_values=true, out_db=true, extent=true - Adds raster constraints to a loaded raster table for a specific column that constrains spatial ref, scaling, blocksize, alignment, bands, band type and a flag to denote if raster column is regularly blocked. The table must be loaded with data for the constraints to be inferred. Returns true if the constraint setting was accomplished and issues a notice otherwise.';

alter function addrasterconstraints(name, name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) owner to postgres;

create function addrasterconstraints(rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT false, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) returns boolean
    strict
    language sql
as
$$ SELECT public.AddRasterConstraints('', $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) $$;

comment on function addrasterconstraints(name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) is 'args: rasttable, rastcolumn, srid=true, scale_x=true, scale_y=true, blocksize_x=true, blocksize_y=true, same_alignment=true, regular_blocking=false, num_bands=true, pixel_types=true, nodata_values=true, out_db=true, extent=true - Adds raster constraints to a loaded raster table for a specific column that constrains spatial ref, scaling, blocksize, alignment, bands, band type and a flag to denote if raster column is regularly blocked. The table must be loaded with data for the constraints to be inferred. Returns true if the constraint setting was accomplished and issues a notice otherwise.';

alter function addrasterconstraints(name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) owner to postgres;

create function droprasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
max int;
		x int;
schema name;
sql text;
		kw text;
		rtn boolean;
		cnt int;
BEGIN
		cnt := 0;
max := array_length(constraints, 1);
		IF max < 1 THEN
			RAISE NOTICE 'No constraints indicated to be dropped.  Doing nothing';
RETURN TRUE;
END IF;

		-- validate schema
schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
EXECUTE sql INTO schema;

IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
RETURN FALSE;
END IF;
END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
EXECUTE sql INTO schema;

IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
RETURN FALSE;
END IF;
END IF;

<<kwloop>>
		FOR x in 1..max LOOP
			kw := trim(both from lower(constraints[x]));

BEGIN
CASE
					WHEN kw = 'srid' THEN
						RAISE NOTICE 'Dropping SRID constraint';
						rtn :=  public._drop_raster_constraint_srid(schema, $2, $3);
WHEN kw IN ('scale_x', 'scalex') THEN
						RAISE NOTICE 'Dropping scale-X constraint';
						rtn :=  public._drop_raster_constraint_scale(schema, $2, $3, 'x');
WHEN kw IN ('scale_y', 'scaley') THEN
						RAISE NOTICE 'Dropping scale-Y constraint';
						rtn :=  public._drop_raster_constraint_scale(schema, $2, $3, 'y');
WHEN kw = 'scale' THEN
						RAISE NOTICE 'Dropping scale-X constraint';
						rtn :=  public._drop_raster_constraint_scale(schema, $2, $3, 'x');
						RAISE NOTICE 'Dropping scale-Y constraint';
						rtn :=  public._drop_raster_constraint_scale(schema, $2, $3, 'y');
WHEN kw IN ('blocksize_x', 'blocksizex', 'width') THEN
						RAISE NOTICE 'Dropping blocksize-X constraint';
						rtn :=  public._drop_raster_constraint_blocksize(schema, $2, $3, 'width');
WHEN kw IN ('blocksize_y', 'blocksizey', 'height') THEN
						RAISE NOTICE 'Dropping blocksize-Y constraint';
						rtn :=  public._drop_raster_constraint_blocksize(schema, $2, $3, 'height');
WHEN kw = 'blocksize' THEN
						RAISE NOTICE 'Dropping blocksize-X constraint';
						rtn :=  public._drop_raster_constraint_blocksize(schema, $2, $3, 'width');
						RAISE NOTICE 'Dropping blocksize-Y constraint';
						rtn :=  public._drop_raster_constraint_blocksize(schema, $2, $3, 'height');
WHEN kw IN ('same_alignment', 'samealignment', 'alignment') THEN
						RAISE NOTICE 'Dropping alignment constraint';
						rtn :=  public._drop_raster_constraint_alignment(schema, $2, $3);
WHEN kw IN ('regular_blocking', 'regularblocking') THEN
						rtn :=  public._drop_raster_constraint_regular_blocking(schema, $2, $3);

						RAISE NOTICE 'Dropping coverage tile constraint required for regular blocking';
						rtn :=  public._drop_raster_constraint_coverage_tile(schema, $2, $3);

						IF rtn IS NOT FALSE THEN
							RAISE NOTICE 'Dropping spatially unique constraint required for regular blocking';
							rtn :=  public._drop_raster_constraint_spatially_unique(schema, $2, $3);
END IF;
WHEN kw IN ('num_bands', 'numbands') THEN
						RAISE NOTICE 'Dropping number of bands constraint';
						rtn :=  public._drop_raster_constraint_num_bands(schema, $2, $3);
WHEN kw IN ('pixel_types', 'pixeltypes') THEN
						RAISE NOTICE 'Dropping pixel type constraint';
						rtn :=  public._drop_raster_constraint_pixel_types(schema, $2, $3);
WHEN kw IN ('nodata_values', 'nodatavalues', 'nodata') THEN
						RAISE NOTICE 'Dropping nodata value constraint';
						rtn :=  public._drop_raster_constraint_nodata_values(schema, $2, $3);
WHEN kw IN ('out_db', 'outdb') THEN
						RAISE NOTICE 'Dropping out-of-database constraint';
						rtn :=  public._drop_raster_constraint_out_db(schema, $2, $3);
WHEN kw = 'extent' THEN
						RAISE NOTICE 'Dropping maximum extent constraint';
						rtn :=  public._drop_raster_constraint_extent(schema, $2, $3);
ELSE
						RAISE NOTICE 'Unknown constraint: %.  Skipping', quote_literal(constraints[x]);
CONTINUE kwloop;
END CASE;
END;

			IF rtn IS FALSE THEN
				cnt := cnt + 1;
				RAISE WARNING 'Unable to drop constraint: %.  Skipping', quote_literal(constraints[x]);
END IF;

END LOOP kwloop;

		IF cnt = max THEN
			RAISE EXCEPTION 'None of the constraints specified could be dropped.  Is the schema name, table name or column name incorrect?';
RETURN FALSE;
END IF;

RETURN TRUE;
END;
	$$;

comment on function droprasterconstraints(name, name, name, text[]) is 'args: rastschema, rasttable, rastcolumn, constraints - Drops PostGIS raster constraints that refer to a raster table column. Useful if you need to reload data or update your raster column data.';

alter function droprasterconstraints(name, name, name, text[]) owner to postgres;

create function droprasterconstraints(rasttable name, rastcolumn name, VARIADIC constraints text[]) returns boolean
    strict
    language sql
as
$$ SELECT  public.DropRasterConstraints('', $1, $2, VARIADIC $3) $$;

alter function droprasterconstraints(name, name, text[]) owner to postgres;

create function droprasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT true, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
constraints text[];
BEGIN
		IF srid IS TRUE THEN
			constraints := constraints || 'srid'::text;
END IF;

		IF scale_x IS TRUE THEN
			constraints := constraints || 'scale_x'::text;
END IF;

		IF scale_y IS TRUE THEN
			constraints := constraints || 'scale_y'::text;
END IF;

		IF blocksize_x IS TRUE THEN
			constraints := constraints || 'blocksize_x'::text;
END IF;

		IF blocksize_y IS TRUE THEN
			constraints := constraints || 'blocksize_y'::text;
END IF;

		IF same_alignment IS TRUE THEN
			constraints := constraints || 'same_alignment'::text;
END IF;

		IF regular_blocking IS TRUE THEN
			constraints := constraints || 'regular_blocking'::text;
END IF;

		IF num_bands IS TRUE THEN
			constraints := constraints || 'num_bands'::text;
END IF;

		IF pixel_types IS TRUE THEN
			constraints := constraints || 'pixel_types'::text;
END IF;

		IF nodata_values IS TRUE THEN
			constraints := constraints || 'nodata_values'::text;
END IF;

		IF out_db IS TRUE THEN
			constraints := constraints || 'out_db'::text;
END IF;

		IF extent IS TRUE THEN
			constraints := constraints || 'extent'::text;
END IF;

RETURN DropRasterConstraints($1, $2, $3, VARIADIC constraints);
END;
	$$;

comment on function droprasterconstraints(name, name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) is 'args: rastschema, rasttable, rastcolumn, srid=true, scale_x=true, scale_y=true, blocksize_x=true, blocksize_y=true, same_alignment=true, regular_blocking=false, num_bands=true, pixel_types=true, nodata_values=true, out_db=true, extent=true - Drops PostGIS raster constraints that refer to a raster table column. Useful if you need to reload data or update your raster column data.';

alter function droprasterconstraints(name, name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) owner to postgres;

create function droprasterconstraints(rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT true, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) returns boolean
    strict
    language sql
as
$$ SELECT DropRasterConstraints('', $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) $$;

comment on function droprasterconstraints(name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) is 'args: rasttable, rastcolumn, srid, scale_x, scale_y, blocksize_x, blocksize_y, same_alignment, regular_blocking, num_bands=true, pixel_types=true, nodata_values=true, out_db=true, extent=true - Drops PostGIS raster constraints that refer to a raster table column. Useful if you need to reload data or update your raster column data.';

alter function droprasterconstraints(name, name, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) owner to postgres;

create function _overview_constraint(ov raster, factor integer, refschema name, reftable name, refcolumn name) returns boolean
    stable
    language sql
as
$$ SELECT COALESCE((SELECT TRUE FROM public.raster_columns WHERE r_table_catalog = current_database() AND r_table_schema = $3 AND r_table_name = $4 AND r_raster_column = $5), FALSE) $$;

alter function _overview_constraint(raster, integer, name, name, name) owner to postgres;

create function _overview_constraint_info(ovschema name, ovtable name, ovcolumn name, OUT refschema name, OUT reftable name, OUT refcolumn name, OUT factor integer) returns record
    stable
    strict
    language sql
as
$$
SELECT
    split_part(split_part(s.consrc, '''::name', 1), '''', 2)::name,
        split_part(split_part(s.consrc, '''::name', 2), '''', 2)::name,
        split_part(split_part(s.consrc, '''::name', 3), '''', 2)::name,
        trim(both from split_part(s.consrc, ',', 2))::integer
FROM pg_class c, pg_namespace n, pg_attribute a
   , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
      FROM pg_constraint) AS s
WHERE n.nspname = $1
  AND c.relname = $2
  AND a.attname = $3
  AND a.attrelid = c.oid
  AND s.connamespace = n.oid
  AND s.conrelid = c.oid
  AND a.attnum = ANY (s.conkey)
  AND s.consrc LIKE '%_overview_constraint(%' LIMIT 1
	$$;

alter function _overview_constraint_info(name, name, name, out name, out name, out name, out integer) owner to postgres;

create function _add_overview_constraint(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, factor integer) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
fqtn text;
		cn name;
sql text;
BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_overview_' || $3;

sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK ( public._overview_constraint(' || quote_ident($3)
			|| ',' || $7
			|| ',' || quote_literal($4)
			|| ',' || quote_literal($5)
			|| ',' || quote_literal($6)
			|| '))';

RETURN  public._add_raster_constraint(cn, sql);
END;
	$$;

alter function _add_overview_constraint(name, name, name, name, name, name, integer) owner to postgres;

create function _drop_overview_constraint(ovschema name, ovtable name, ovcolumn name) returns boolean
    strict
    language sql
as
$$ SELECT  public._drop_raster_constraint($1, $2, 'enforce_overview_' || $3) $$;

alter function _drop_overview_constraint(name, name, name) owner to postgres;

create function addoverviewconstraints(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, ovfactor integer) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
x int;
		s name;
		t name;
		oschema name;
		rschema name;
sql text;
		rtn boolean;
BEGIN
FOR x IN 1..2 LOOP
			s := '';

			IF x = 1 THEN
				s := $1;
				t := $2;
ELSE
				s := $4;
				t := $5;
END IF;

			-- validate user-provided schema
			IF length(s) > 0 THEN
				sql := 'SELECT nspname FROM pg_namespace '
					|| 'WHERE nspname = ' || quote_literal(s)
					|| 'LIMIT 1';
EXECUTE sql INTO s;

IF s IS NULL THEN
					RAISE EXCEPTION 'The value % is not a valid schema', quote_literal(s);
RETURN FALSE;
END IF;
END IF;

			-- no schema, determine what it could be using the table
			IF length(s) < 1 THEN
				sql := 'SELECT n.nspname AS schemaname '
					|| 'FROM pg_catalog.pg_class c '
					|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
					|| 'WHERE c.relkind = ' || quote_literal('r')
					|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
					|| ', ' || quote_literal('pg_toast')
					|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
					|| ' AND c.relname = ' || quote_literal(t);
EXECUTE sql INTO s;

IF s IS NULL THEN
					RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal(t);
RETURN FALSE;
END IF;
END IF;

			IF x = 1 THEN
				oschema := s;
ELSE
				rschema := s;
END IF;
END LOOP;

		-- reference raster
		rtn :=  public._add_overview_constraint(oschema, $2, $3, rschema, $5, $6, $7);
		IF rtn IS FALSE THEN
			RAISE EXCEPTION 'Unable to add the overview constraint.  Is the schema name, table name or column name incorrect?';
RETURN FALSE;
END IF;

RETURN TRUE;
END;
	$$;

comment on function addoverviewconstraints(name, name, name, name, name, name, integer) is 'args: ovschema, ovtable, ovcolumn, refschema, reftable, refcolumn, ovfactor - Tag a raster column as being an overview of another.';

alter function addoverviewconstraints(name, name, name, name, name, name, integer) owner to postgres;

create function addoverviewconstraints(ovtable name, ovcolumn name, reftable name, refcolumn name, ovfactor integer) returns boolean
    strict
    language sql
as
$$ SELECT  public.AddOverviewConstraints('', $1, $2, '', $3, $4, $5) $$;

comment on function addoverviewconstraints(name, name, name, name, integer) is 'args: ovtable, ovcolumn, reftable, refcolumn, ovfactor - Tag a raster column as being an overview of another.';

alter function addoverviewconstraints(name, name, name, name, integer) owner to postgres;

create function dropoverviewconstraints(ovschema name, ovtable name, ovcolumn name) returns boolean
    strict
    language plpgsql
as
$$
DECLARE
schema name;
sql text;
		rtn boolean;
BEGIN
		-- validate schema
schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
EXECUTE sql INTO schema;

IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
RETURN FALSE;
END IF;
END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
EXECUTE sql INTO schema;

IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
RETURN FALSE;
END IF;
END IF;

		rtn :=  public._drop_overview_constraint(schema, $2, $3);
		IF rtn IS FALSE THEN
			RAISE EXCEPTION 'Unable to drop the overview constraint .  Is the schema name, table name or column name incorrect?';
RETURN FALSE;
END IF;

RETURN TRUE;
END;
	$$;

comment on function dropoverviewconstraints(name, name, name) is 'args: ovschema, ovtable, ovcolumn - Untag a raster column from being an overview of another.';

alter function dropoverviewconstraints(name, name, name) owner to postgres;

create function dropoverviewconstraints(ovtable name, ovcolumn name) returns boolean
    strict
    language sql
as
$$ SELECT  public.DropOverviewConstraints('', $1, $2) $$;

comment on function dropoverviewconstraints(name, name) is 'args: ovtable, ovcolumn - Untag a raster column from being an overview of another.';

alter function dropoverviewconstraints(name, name) owner to postgres;

create function _updaterastersrid(schema_name name, table_name name, column_name name, new_srid integer) returns boolean
    language plpgsql
as
$$
DECLARE
fqtn text;
schema name;
sql text;
		srid integer;
		ct boolean;
BEGIN
		-- validate schema
schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
EXECUTE sql INTO schema;

IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
RETURN FALSE;
END IF;
END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
EXECUTE sql INTO schema;

IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
RETURN FALSE;
END IF;
END IF;

		-- clamp SRID
		IF new_srid < 0 THEN
			srid :=  public.ST_SRID('POINT EMPTY'::public.geometry);
			RAISE NOTICE 'SRID % converted to the officially unknown SRID %', new_srid, srid;
ELSE
			srid := new_srid;
END IF;

		-- drop coverage tile constraint
		-- done separately just in case constraint doesn't exist
		ct := public._raster_constraint_info_coverage_tile(schema, $2, $3);
		IF ct IS TRUE THEN
			PERFORM  public._drop_raster_constraint_coverage_tile(schema, $2, $3);
END IF;

		-- drop SRID, extent, alignment constraints
		PERFORM  public.DropRasterConstraints(schema, $2, $3, 'extent', 'alignment', 'srid');

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
END IF;
		fqtn := fqtn || quote_ident($2);

		-- update SRID
sql := 'UPDATE ' || fqtn ||
			' SET ' || quote_ident($3) ||
			' =  public.ST_SetSRID(' || quote_ident($3) ||
			'::public.raster, ' || srid || ')';
		RAISE NOTICE 'sql = %', sql;
EXECUTE sql;

-- add SRID constraint
PERFORM  public.AddRasterConstraints(schema, $2, $3, 'srid', 'extent', 'alignment');

		-- add coverage tile constraint if needed
		IF ct IS TRUE THEN
			PERFORM  public._add_raster_constraint_coverage_tile(schema, $2, $3);
END IF;

RETURN TRUE;
END;
	$$;

alter function _updaterastersrid(name, name, name, integer) owner to postgres;

create function updaterastersrid(schema_name name, table_name name, column_name name, new_srid integer) returns boolean
    strict
    language sql
as
$$ SELECT  public._UpdateRasterSRID($1, $2, $3, $4) $$;

comment on function updaterastersrid(name, name, name, integer) is 'args: schema_name, table_name, column_name, new_srid - Change the SRID of all rasters in the user-specified column and table.';

alter function updaterastersrid(name, name, name, integer) owner to postgres;

create function updaterastersrid(table_name name, column_name name, new_srid integer) returns boolean
    strict
    language sql
as
$$ SELECT  public._UpdateRasterSRID('', $1, $2, $3) $$;

comment on function updaterastersrid(name, name, integer) is 'args: table_name, column_name, new_srid - Change the SRID of all rasters in the user-specified column and table.';

alter function updaterastersrid(name, name, integer) owner to postgres;

create function st_retile(tab regclass, col name, ext geometry, sfx double precision, sfy double precision, tw integer, th integer, algo text DEFAULT 'NearestNeighbour'::text) returns SETOF raster
    stable
    strict
    language plpgsql
as
$$
DECLARE
rec RECORD;
  ipx FLOAT8;
  ipy FLOAT8;
  tx int;
  ty int;
  te public.GEOMETRY; -- tile extent
  ncols int;
  nlins int;
  srid int;
sql TEXT;
BEGIN

  RAISE DEBUG 'Target coverage will have sfx=%, sfy=%', sfx, sfy;

  -- 2. Loop over each target tile and build it from source tiles
  ipx := st_xmin(ext);
  ncols := ceil((st_xmax(ext)-ipx)/sfx/tw);
  IF sfy < 0 THEN
    ipy := st_ymax(ext);
    nlins := ceil((st_ymin(ext)-ipy)/sfy/th);
ELSE
    ipy := st_ymin(ext);
    nlins := ceil((st_ymax(ext)-ipy)/sfy/th);
END IF;

  srid := ST_Srid(ext);

  RAISE DEBUG 'Target coverage will have % x % tiles, each of approx size % x %', ncols, nlins, tw, th;
  RAISE DEBUG 'Target coverage will cover extent %', ext::box2d;

FOR tx IN 0..ncols-1 LOOP
    FOR ty IN 0..nlins-1 LOOP
      te := ST_MakeEnvelope(ipx + tx     *  tw  * sfx,
                             ipy + ty     *  th  * sfy,
                             ipx + (tx+1) *  tw  * sfx,
                             ipy + (ty+1) *  th  * sfy,
                             srid);
      --RAISE DEBUG 'sfx/sfy: %, %', sfx, sfy;
      --RAISE DEBUG 'tile extent %', te;
sql := 'SELECT count(*),  public.ST_Clip(  public.ST_Union(  public.ST_SnapToGrid(  public.ST_Rescale(  public.ST_Clip(' || quote_ident(col)
          || ',  public.ST_Expand($3, greatest($1,$2))),$1, $2, $6), $4, $5, $1, $2)), $3) g FROM ' || tab::text
          || ' WHERE  public.ST_Intersects(' || quote_ident(col) || ', $3)';
      --RAISE DEBUG 'SQL: %', sql;
FOR rec IN EXECUTE sql USING sfx, sfy, te, ipx, ipy, algo LOOP
        --RAISE DEBUG '% source tiles intersect target tile %,% with extent %', rec.count, tx, ty, te::box2d;
        IF rec.g IS NULL THEN
          RAISE WARNING 'No source tiles cover target tile %,% with extent %',
            tx, ty, te::box2d;
ELSE
          --RAISE DEBUG 'Tile for extent % has size % x %', te::box2d, st_width(rec.g), st_height(rec.g);
          RETURN NEXT rec.g;
END IF;
END LOOP;
END LOOP;
END LOOP;

  RETURN;
END;
$$;

comment on function st_retile(regclass, name, geometry, double precision, double precision, integer, integer, text) is 'args: tab, col, ext, sfx, sfy, tw, th, algo=''NearestNeighbor'' - Return a set of configured tiles from an arbitrarily tiled raster coverage.';

alter function st_retile(regclass, name, geometry, double precision, double precision, integer, integer, text) owner to postgres;

create function st_createoverview(tab regclass, col name, factor integer, algo text DEFAULT 'NearestNeighbour'::text) returns regclass
    strict
    language plpgsql
as
$$
DECLARE
sinfo RECORD; -- source info
sql TEXT;
  ttab TEXT;
BEGIN

  -- 0. Check arguments, we need to ensure:
  --    a. Source table has a raster column with given name
  --    b. Source table has a fixed scale (or "factor" would have no meaning)
  --    c. Source table has a known extent ? (we could actually compute it)
  --    d. Source table has a fixed tile size (or "factor" would have no meaning?)
  -- # all of the above can be checked with a query to raster_columns
sql := 'SELECT r.r_table_schema sch, r.r_table_name tab, '
      || 'r.scale_x sfx, r.scale_y sfy, r.blocksize_x tw, '
      || 'r.blocksize_y th, r.extent ext, r.srid FROM public.raster_columns r, '
      || 'pg_class c, pg_namespace n WHERE r.r_table_schema = n.nspname '
      || 'AND r.r_table_name = c.relname AND r_raster_column = $2 AND '
      || ' c.relnamespace = n.oid AND c.oid = $1'
  ;
EXECUTE sql INTO sinfo USING tab, col;
IF sinfo IS NULL THEN
      RAISE EXCEPTION '%.% raster column does not exist', tab::text, col;
END IF;
  IF sinfo.sfx IS NULL or sinfo.sfy IS NULL THEN
    RAISE EXCEPTION 'cannot create overview without scale constraint, try select AddRasterConstraints(''%'', ''%'');', tab::text, col;
END IF;
  IF sinfo.tw IS NULL or sinfo.tw IS NULL THEN
    RAISE EXCEPTION 'cannot create overview without tilesize constraint, try select AddRasterConstraints(''%'', ''%'');', tab::text, col;
END IF;
  IF sinfo.ext IS NULL THEN
    RAISE EXCEPTION 'cannot create overview without extent constraint, try select AddRasterConstraints(''%'', ''%'');', tab::text, col;
END IF;

  -- TODO: lookup in raster_overviews to see if there's any
  --       lower-resolution table to start from

  ttab := 'o_' || factor || '_' || sinfo.tab;
sql := 'CREATE TABLE ' || quote_ident(sinfo.sch)
      || '.' || quote_ident(ttab)
      || ' AS SELECT ST_Retile($1, $2, $3, $4, $5, $6, $7) '
      || quote_ident(col);
EXECUTE sql USING tab, col, sinfo.ext,
    sinfo.sfx * factor, sinfo.sfy * factor,
                    sinfo.tw, sinfo.th, algo;

-- TODO: optimize this using knowledge we have about
--       the characteristics of the target column ?
PERFORM public.AddRasterConstraints(sinfo.sch, ttab, col);

  PERFORM  public.AddOverviewConstraints(sinfo.sch, ttab, col,
                                 sinfo.sch, sinfo.tab, col, factor);

    -- return the schema as well as the table
RETURN sinfo.sch||'.'||ttab;
END;
$$;

comment on function st_createoverview(regclass, name, integer, text) is 'args: tab, col, factor, algo=''NearestNeighbor'' - Create an reduced resolution version of a given raster coverage.';

alter function st_createoverview(regclass, name, integer, text) owner to postgres;

create function st_makeemptycoverage(tilewidth integer, tileheight integer, width integer, height integer, upperleftx double precision, upperlefty double precision, scalex double precision, scaley double precision, skewx double precision, skewy double precision, srid integer DEFAULT 0) returns SETOF raster
    immutable
    parallel safe
    language plpgsql
as
$$
DECLARE
ulx double precision;  -- upper left x of raster
        uly double precision;  -- upper left y of raster
        rw int;                -- raster width (may change at edges)
        rh int;                -- raster height (may change at edges)
        x int;                 -- x index of coverage
        y int;                 -- y index of coverage
        template public.raster;       -- an empty template raster, where each cell
                               -- represents a tile in the coverage
        minY double precision;
        maxX double precision;
BEGIN
        template := public.ST_MakeEmptyRaster(
            ceil(width::float8/tilewidth)::int,
            ceil(height::float8/tileheight)::int,
            upperleftx,
            upperlefty,
            tilewidth * scalex,
            tileheight * scaley,
            tileheight * skewx,
            tilewidth * skewy,
            srid
        );

FOR y IN 1..st_height(template) LOOP
            maxX := public.ST_RasterToWorldCoordX(template, 1, y) + width * scalex;
FOR x IN 1..st_width(template) LOOP
                minY := public.ST_RasterToWorldCoordY(template, x, 1) + height * scaley;
                uly := public.ST_RasterToWorldCoordY(template, x, y);
                IF uly + (tileheight * scaley) < minY THEN
                    --raise notice 'uly, minY: %, %', uly, minY;
                    rh := ceil((minY - uly)/scaleY)::int;
ELSE
                    rh := tileheight;
END IF;

                ulx := public.ST_RasterToWorldCoordX(template, x, y);
                IF ulx + (tilewidth * scalex) > maxX THEN
                    --raise notice 'ulx, maxX: %, %', ulx, maxX;
                    rw := ceil((maxX - ulx)/scaleX)::int;
ELSE
                    rw := tilewidth;
END IF;

                RETURN NEXT public.ST_MakeEmptyRaster(rw, rh, ulx, uly, scalex, scaley, skewx, skewy, srid);
END LOOP;
END LOOP;
END;
    $$;

comment on function st_makeemptycoverage(integer, integer, integer, integer, double precision, double precision, double precision, double precision, double precision, double precision, integer) is 'args: tilewidth, tileheight, width, height, upperleftx, upperlefty, scalex, scaley, skewx, skewy, srid=unknown - Cover georeferenced area with a grid of empty raster tiles.';

alter function st_makeemptycoverage(integer, integer, integer, integer, double precision, double precision, double precision, double precision, double precision, double precision, integer) owner to postgres;

create function postgis_noop(raster) returns geometry
    stable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function postgis_noop(raster) owner to postgres;

create function pg_catalog."RI_FKey_cascade_del"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_cascade_del"() is 'referential integrity ON DELETE CASCADE';

create function pg_catalog."RI_FKey_cascade_upd"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_cascade_upd"() is 'referential integrity ON UPDATE CASCADE';

create function pg_catalog."RI_FKey_check_ins"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_check_ins"() is 'referential integrity FOREIGN KEY ... REFERENCES';

create function pg_catalog."RI_FKey_check_upd"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_check_upd"() is 'referential integrity FOREIGN KEY ... REFERENCES';

create function pg_catalog."RI_FKey_noaction_del"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_noaction_del"() is 'referential integrity ON DELETE NO ACTION';

create function pg_catalog."RI_FKey_noaction_upd"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_noaction_upd"() is 'referential integrity ON UPDATE NO ACTION';

create function pg_catalog."RI_FKey_restrict_del"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_restrict_del"() is 'referential integrity ON DELETE RESTRICT';

create function pg_catalog."RI_FKey_restrict_upd"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_restrict_upd"() is 'referential integrity ON UPDATE RESTRICT';

create function pg_catalog."RI_FKey_setdefault_del"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setdefault_del"() is 'referential integrity ON DELETE SET DEFAULT';

create function pg_catalog."RI_FKey_setdefault_upd"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setdefault_upd"() is 'referential integrity ON UPDATE SET DEFAULT';

create function pg_catalog."RI_FKey_setnull_del"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setnull_del"() is 'referential integrity ON DELETE SET NULL';

create function pg_catalog."RI_FKey_setnull_upd"() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setnull_upd"() is 'referential integrity ON UPDATE SET NULL';

create function information_schema._pg_char_max_length(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

create function information_schema._pg_char_octet_length(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

create function information_schema._pg_datetime_precision(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

create function information_schema._pg_expandarray(anyarray, OUT x anyelement, OUT n integer) returns SETOF record
    immutable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

create function information_schema._pg_index_position(oid, smallint) returns integer
    stable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

create function information_schema._pg_interval_type(typid oid, mod integer) returns text
    immutable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

create function information_schema._pg_numeric_precision(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

create function information_schema._pg_numeric_precision_radix(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

create function information_schema._pg_numeric_scale(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

create function information_schema._pg_truetypid(pg_attribute, pg_type) returns oid
    immutable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

create function information_schema._pg_truetypmod(pg_attribute, pg_type) returns integer
    immutable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

create function pg_catalog.abbrev(cidr) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abbrev(cidr) is 'abbreviated display of cidr value';

create function pg_catalog.abbrev(inet) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abbrev(inet) is 'abbreviated display of inet value';

create function pg_catalog.abs(bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(bigint) is 'absolute value';

create function pg_catalog.abs(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(double precision) is 'absolute value';

create function pg_catalog.abs(integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(integer) is 'absolute value';

create function pg_catalog.abs(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(numeric) is 'absolute value';

create function pg_catalog.abs(real) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(real) is 'absolute value';

create function pg_catalog.abs(smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(smallint) is 'absolute value';

create function pg_catalog.aclcontains(aclitem[], aclitem) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclcontains(aclitem[], aclitem) is 'contains';

create function pg_catalog.acldefault("char", oid) returns aclitem[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acldefault("char", oid) is 'show hardwired default privileges, primarily for use by the information schema';

create function pg_catalog.aclexplode(acl aclitem[], out grantor oid, out grantee oid, out privilege_type text, out is_grantable boolean) returns setof setof record
    stable
    strict
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.aclexplode(aclitem[], out oid, out oid, out text, out boolean) is 'convert ACL item array to table, primarily for use by information schema';

create function pg_catalog.aclinsert(aclitem[], aclitem) returns aclitem[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclinsert(aclitem[], aclitem) is 'add/update ACL item';

create function pg_catalog.aclitemeq(aclitem, aclitem) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemeq(aclitem, aclitem) is 'implementation of = operator';

create function pg_catalog.aclitemin(cstring) returns aclitem
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemin(cstring) is 'I/O';

create function pg_catalog.aclitemout(aclitem) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemout(aclitem) is 'I/O';

create function pg_catalog.aclremove(aclitem[], aclitem) returns aclitem[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclremove(aclitem[], aclitem) is 'remove ACL item';

create function pg_catalog.acos(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acos(double precision) is 'arccosine';

create function pg_catalog.acosd(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acosd(double precision) is 'arccosine, degrees';

create function pg_catalog.acosh(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acosh(double precision) is 'inverse hyperbolic cosine';

create function pg_catalog.age(timestamp with time zone) returns interval
    stable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(timestamp with time zone) is 'date difference from today preserving months and years';

create function pg_catalog.age(timestamp with time zone, timestamp with time zone) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(timestamp with time zone, timestamp with time zone) is 'date difference preserving months and years';

create function pg_catalog.age(timestamp without time zone) returns interval
    stable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(timestamp) is 'date difference from today preserving months and years';

create function pg_catalog.age(timestamp, timestamp) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(timestamp, timestamp) is 'date difference preserving months and years';

create function pg_catalog.age(xid) returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(xid) is 'age of a transaction ID, in transactions before current transaction';

create function pg_catalog.amvalidate(oid) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.amvalidate(oid) is 'validate an operator class';

create function pg_catalog.any_in(cstring) returns "any"
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.any_in(cstring) is 'I/O';

create function pg_catalog.any_out("any") returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.any_out("any") is 'I/O';

create function pg_catalog.anyarray_in(cstring) returns anyarray
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_in(cstring) is 'I/O';

create function pg_catalog.anyarray_out(anyarray) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_out(anyarray) is 'I/O';

create function pg_catalog.anyarray_recv(internal) returns anyarray
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_recv(internal) is 'I/O';

create function pg_catalog.anyarray_send(anyarray) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_send(anyarray) is 'I/O';

create function pg_catalog.anycompatible_in(cstring) returns anycompatible
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatible_in(cstring) is 'I/O';

create function pg_catalog.anycompatible_out(anycompatible) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatible_out(anycompatible) is 'I/O';

create function pg_catalog.anycompatiblearray_in(cstring) returns anycompatiblearray
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_in(cstring) is 'I/O';

create function pg_catalog.anycompatiblearray_out(anycompatiblearray) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_out(anycompatiblearray) is 'I/O';

create function pg_catalog.anycompatiblearray_recv(internal) returns anycompatiblearray
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_recv(internal) is 'I/O';

create function pg_catalog.anycompatiblearray_send(anycompatiblearray) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_send(anycompatiblearray) is 'I/O';

create function pg_catalog.anycompatiblenonarray_in(cstring) returns anycompatiblenonarray
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblenonarray_in(cstring) is 'I/O';

create function pg_catalog.anycompatiblenonarray_out(anycompatiblenonarray) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblenonarray_out(anycompatiblenonarray) is 'I/O';

create function pg_catalog.anycompatiblerange_in(cstring, oid, integer) returns anycompatiblerange
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblerange_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.anycompatiblerange_out(anycompatiblerange) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblerange_out(anycompatiblerange) is 'I/O';

create function pg_catalog.anyelement_in(cstring) returns anyelement
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyelement_in(cstring) is 'I/O';

create function pg_catalog.anyelement_out(anyelement) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyelement_out(anyelement) is 'I/O';

create function pg_catalog.anyenum_in(cstring) returns anyenum
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyenum_in(cstring) is 'I/O';

create function pg_catalog.anyenum_out(anyenum) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyenum_out(anyenum) is 'I/O';

create function pg_catalog.anynonarray_in(cstring) returns anynonarray
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anynonarray_in(cstring) is 'I/O';

create function pg_catalog.anynonarray_out(anynonarray) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anynonarray_out(anynonarray) is 'I/O';

create function pg_catalog.anyrange_in(cstring, oid, integer) returns anyrange
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyrange_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.anyrange_out(anyrange) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyrange_out(anyrange) is 'I/O';

create function pg_catalog.anytextcat(anynonarray, text) returns text
    stable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anytextcat(anynonarray, text) is 'implementation of || operator';

create function pg_catalog.area(box) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(box) is 'box area';

create function pg_catalog.area(circle) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(circle) is 'area of circle';

create function pg_catalog.area(path) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(path) is 'area of a closed path';

create function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for area-comparison operators';

create function pg_catalog.areasel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.areasel(internal, oid, internal, integer) is 'restriction selectivity for area-comparison operators';

create function pg_catalog.array_agg_array_finalfn(internal, anyarray) returns anyarray
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_array_finalfn(internal, anyarray) is 'aggregate final function';

create function pg_catalog.array_agg_array_transfn(internal, anyarray) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_array_transfn(internal, anyarray) is 'aggregate transition function';

create function pg_catalog.array_agg_finalfn(internal, anynonarray) returns anyarray
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_finalfn(internal, anynonarray) is 'aggregate final function';

create function pg_catalog.array_agg_transfn(internal, anynonarray) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_transfn(internal, anynonarray) is 'aggregate transition function';

create function pg_catalog.array_append(anyarray, anyelement) returns anyarray
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_append(anyarray, anyelement) is 'append element onto end of array';

create function pg_catalog.array_cat(anyarray, anyarray) returns anyarray
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_cat(anyarray, anyarray) is 'implementation of || operator';

create function pg_catalog.array_dims(anyarray) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_dims(anyarray) is 'array dimensions';

create function pg_catalog.array_eq(anyarray, anyarray) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_eq(anyarray, anyarray) is 'implementation of = operator';

create function pg_catalog.array_fill(anyelement, integer[]) returns anyarray
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_fill(anyelement, integer[]) is 'array constructor with value';

create function pg_catalog.array_fill(anyelement, integer[], integer[]) returns anyarray
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_fill(anyelement, integer[], integer[]) is 'array constructor with value';

create function pg_catalog.array_ge(anyarray, anyarray) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ge(anyarray, anyarray) is 'implementation of >= operator';

create function pg_catalog.array_gt(anyarray, anyarray) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_gt(anyarray, anyarray) is 'implementation of > operator';

create function pg_catalog.array_in(cstring, oid, integer) returns anyarray
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.array_larger(anyarray, anyarray) returns anyarray
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_larger(anyarray, anyarray) is 'larger of two';

create function pg_catalog.array_le(anyarray, anyarray) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_le(anyarray, anyarray) is 'implementation of <= operator';

create function pg_catalog.array_length(anyarray, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_length(anyarray, integer) is 'array length';

create function pg_catalog.array_lower(anyarray, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_lower(anyarray, integer) is 'array lower dimension';

create function pg_catalog.array_lt(anyarray, anyarray) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_lt(anyarray, anyarray) is 'implementation of < operator';

create function pg_catalog.array_ndims(anyarray) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ndims(anyarray) is 'number of array dimensions';

create function pg_catalog.array_ne(anyarray, anyarray) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ne(anyarray, anyarray) is 'implementation of <> operator';

create function pg_catalog.array_out(anyarray) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_out(anyarray) is 'I/O';

create function pg_catalog.array_position(anyarray, anyelement) returns integer
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_position(anyarray, anyelement) is 'returns an offset of value in array';

create function pg_catalog.array_position(anyarray, anyelement, integer) returns integer
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_position(anyarray, anyelement, integer) is 'returns an offset of value in array with start index';

create function pg_catalog.array_positions(anyarray, anyelement) returns integer[]
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_positions(anyarray, anyelement) is 'returns an array of offsets of some value in array';

create function pg_catalog.array_prepend(anyelement, anyarray) returns anyarray
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_prepend(anyelement, anyarray) is 'prepend element onto front of array';

create function pg_catalog.array_recv(internal, oid, integer) returns anyarray
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.array_remove(anyarray, anyelement) returns anyarray
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_remove(anyarray, anyelement) is 'remove any occurrences of an element from an array';

create function pg_catalog.array_replace(anyarray, anyelement, anyelement) returns anyarray
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_replace(anyarray, anyelement, anyelement) is 'replace any occurrences of an element in an array';

create function pg_catalog.array_send(anyarray) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_send(anyarray) is 'I/O';

create function pg_catalog.array_smaller(anyarray, anyarray) returns anyarray
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_smaller(anyarray, anyarray) is 'smaller of two';

create function pg_catalog.array_to_json(anyarray) returns json
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_json(anyarray) is 'map array to json';

create function pg_catalog.array_to_json(anyarray, boolean) returns json
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_json(anyarray, boolean) is 'map array to json with optional pretty printing';

create function pg_catalog.array_to_string(anyarray, text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_string(anyarray, text) is 'concatenate array elements, using delimiter, into text';

create function pg_catalog.array_to_string(anyarray, text, text) returns text
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_string(anyarray, text, text) is 'concatenate array elements, using delimiter and null string, into text';

create function pg_catalog.array_to_tsvector(text[]) returns tsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_tsvector(text[]) is 'build tsvector from array of lexemes';

create function pg_catalog.array_typanalyze(internal) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_typanalyze(internal) is 'array typanalyze';

create function pg_catalog.array_unnest_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_unnest_support(internal) is 'planner support for array_unnest';

create function pg_catalog.array_upper(anyarray, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_upper(anyarray, integer) is 'array upper dimension';

create function pg_catalog.arraycontained(anyarray, anyarray) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontained(anyarray, anyarray) is 'implementation of <@ operator';

create function pg_catalog.arraycontains(anyarray, anyarray) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontains(anyarray, anyarray) is 'implementation of @> operator';

create function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for array-containment operators';

create function pg_catalog.arraycontsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontsel(internal, oid, internal, integer) is 'restriction selectivity for array-containment operators';

create function pg_catalog.arrayoverlap(anyarray, anyarray) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arrayoverlap(anyarray, anyarray) is 'implementation of && operator';

create function pg_catalog.ascii(text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ascii(text) is 'convert first char to int4';

create function pg_catalog.asin(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asin(double precision) is 'arcsine';

create function pg_catalog.asind(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asind(double precision) is 'arcsine, degrees';

create function pg_catalog.asinh(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asinh(double precision) is 'inverse hyperbolic sine';

create function pg_catalog.atan(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan(double precision) is 'arctangent';

create function pg_catalog.atan2(double precision, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan2(double precision, double precision) is 'arctangent, two arguments';

create function pg_catalog.atan2d(double precision, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan2d(double precision, double precision) is 'arctangent, two arguments, degrees';

create function pg_catalog.atand(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atand(double precision) is 'arctangent, degrees';

create function pg_catalog.atanh(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atanh(double precision) is 'inverse hyperbolic tangent';

create function pg_catalog.bernoulli(internal) returns tsm_handler
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bernoulli(internal) is 'BERNOULLI tablesample method handler';

create function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer) is 'internal conversion function for BIG5 to EUC_TW';

create function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for BIG5 to MULE_INTERNAL';

create function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for BIG5 to UTF8';

create function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid[], text[], text[]) returns void
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid[], text[], text[]) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_missing_value(oid, text, text) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_missing_value(oid, text, text) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid) is 'for use by pg_upgrade';

create function pg_catalog.binary_upgrade_set_record_init_privs(boolean) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_record_init_privs(boolean) is 'for use by pg_upgrade';

create function pg_catalog.bit(bigint, integer) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit(bigint, integer) is 'convert int8 to bitstring';

create function pg_catalog.bit(bit, integer, boolean) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit(bit, integer, boolean) is 'adjust bit() to typmod length';

create function pg_catalog.bit(integer, integer) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit(integer, integer) is 'convert int4 to bitstring';

create function pg_catalog.bit_in(cstring, oid, integer) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.bit_length(bit) returns integer
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_length(bit) is 'length in bits';

create function pg_catalog.bit_length(bytea) returns integer
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_length(bytea) is 'length in bits';

create function pg_catalog.bit_length(text) returns integer
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_length(text) is 'length in bits';

create function pg_catalog.bit_out(bit) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_out(bit) is 'I/O';

create function pg_catalog.bit_recv(internal, oid, integer) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.bit_send(bit) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_send(bit) is 'I/O';

create function pg_catalog.bitand(bit, bit) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitand(bit, bit) is 'implementation of & operator';

create function pg_catalog.bitcat(bit varying, bit varying) returns bit varying
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitcat(bit varying, bit varying) is 'implementation of || operator';

create function pg_catalog.bitcmp(bit, bit) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitcmp(bit, bit) is 'less-equal-greater';

create function pg_catalog.biteq(bit, bit) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.biteq(bit, bit) is 'implementation of = operator';

create function pg_catalog.bitge(bit, bit) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitge(bit, bit) is 'implementation of >= operator';

create function pg_catalog.bitgt(bit, bit) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitgt(bit, bit) is 'implementation of > operator';

create function pg_catalog.bitle(bit, bit) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitle(bit, bit) is 'implementation of <= operator';

create function pg_catalog.bitlt(bit, bit) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitlt(bit, bit) is 'implementation of < operator';

create function pg_catalog.bitne(bit, bit) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitne(bit, bit) is 'implementation of <> operator';

create function pg_catalog.bitnot(bit) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitnot(bit) is 'implementation of ~ operator';

create function pg_catalog.bitor(bit, bit) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitor(bit, bit) is 'implementation of | operator';

create function pg_catalog.bitshiftleft(bit, integer) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitshiftleft(bit, integer) is 'implementation of << operator';

create function pg_catalog.bitshiftright(bit, integer) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitshiftright(bit, integer) is 'implementation of >> operator';

create function pg_catalog.bittypmodin(cstring[]) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bittypmodin(cstring[]) is 'I/O typmod';

create function pg_catalog.bittypmodout(integer) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bittypmodout(integer) is 'I/O typmod';

create function pg_catalog.bitxor(bit, bit) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitxor(bit, bit) is 'implementation of # operator';

create function pg_catalog.bool(integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool(integer) is 'convert int4 to boolean';

create function pg_catalog.bool(jsonb) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool(jsonb) is 'convert jsonb to boolean';

create function pg_catalog.bool_accum(internal, boolean) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_accum(internal, boolean) is 'aggregate transition function';

create function pg_catalog.bool_accum_inv(internal, boolean) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_accum_inv(internal, boolean) is 'aggregate transition function';

create function pg_catalog.bool_alltrue(internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_alltrue(internal) is 'aggregate final function';

create function pg_catalog.bool_anytrue(internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_anytrue(internal) is 'aggregate final function';

create function pg_catalog.booland_statefunc(boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.booland_statefunc(boolean, boolean) is 'aggregate transition function';

create function pg_catalog.booleq(boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.booleq(boolean, boolean) is 'implementation of = operator';

create function pg_catalog.boolge(boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolge(boolean, boolean) is 'implementation of >= operator';

create function pg_catalog.boolgt(boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolgt(boolean, boolean) is 'implementation of > operator';

create function pg_catalog.boolin(cstring) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolin(cstring) is 'I/O';

create function pg_catalog.boolle(boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolle(boolean, boolean) is 'implementation of <= operator';

create function pg_catalog.boollt(boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boollt(boolean, boolean) is 'implementation of < operator';

create function pg_catalog.boolne(boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolne(boolean, boolean) is 'implementation of <> operator';

create function pg_catalog.boolor_statefunc(boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolor_statefunc(boolean, boolean) is 'aggregate transition function';

create function pg_catalog.boolout(boolean) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolout(boolean) is 'I/O';

create function pg_catalog.boolrecv(internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolrecv(internal) is 'I/O';

create function pg_catalog.boolsend(boolean) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolsend(boolean) is 'I/O';

create function pg_catalog.bound_box(box, box) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bound_box(box, box) is 'bounding box of two boxes';

create function pg_catalog.box(circle) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(circle) is 'convert circle to box';

create function pg_catalog.box(point) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(point) is 'convert point to empty box';

create function pg_catalog.box(point, point) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(point, point) is 'convert points to box';

create function pg_catalog.box(polygon) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(polygon) is 'convert polygon to bounding box';

create function pg_catalog.box_above(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_above(box, box) is 'implementation of |>> operator';

create function pg_catalog.box_above_eq(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_above_eq(box, box) is 'implementation of >^ operator';

create function pg_catalog.box_add(box, point) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_add(box, point) is 'implementation of + operator';

create function pg_catalog.box_below(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_below(box, box) is 'implementation of <<| operator';

create function pg_catalog.box_below_eq(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_below_eq(box, box) is 'implementation of <^ operator';

create function pg_catalog.box_center(box) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_center(box) is 'implementation of @@ operator';

create function pg_catalog.box_contain(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contain(box, box) is 'implementation of @> operator';

create function pg_catalog.box_contain_pt(box, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contain_pt(box, point) is 'implementation of @> operator';

create function pg_catalog.box_contained(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contained(box, box) is 'implementation of <@ operator';

create function pg_catalog.box_distance(box, box) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_distance(box, box) is 'implementation of <-> operator';

create function pg_catalog.box_div(box, point) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_div(box, point) is 'implementation of / operator';

create function pg_catalog.box_eq(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_eq(box, box) is 'implementation of = operator';

create function pg_catalog.box_ge(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_ge(box, box) is 'implementation of >= operator';

create function pg_catalog.box_gt(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_gt(box, box) is 'implementation of > operator';

create function pg_catalog.box_in(cstring) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_in(cstring) is 'I/O';

create function pg_catalog.box_intersect(box, box) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_intersect(box, box) is 'implementation of # operator';

create function pg_catalog.box_le(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_le(box, box) is 'implementation of <= operator';

create function pg_catalog.box_left(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_left(box, box) is 'implementation of << operator';

create function pg_catalog.box_lt(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_lt(box, box) is 'implementation of < operator';

create function pg_catalog.box_mul(box, point) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_mul(box, point) is 'implementation of * operator';

create function pg_catalog.box_out(box) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_out(box) is 'I/O';

create function pg_catalog.box_overabove(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overabove(box, box) is 'implementation of |&> operator';

create function pg_catalog.box_overbelow(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overbelow(box, box) is 'implementation of &<| operator';

create function pg_catalog.box_overlap(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overlap(box, box) is 'implementation of && operator';

create function pg_catalog.box_overleft(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overleft(box, box) is 'implementation of &< operator';

create function pg_catalog.box_overright(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overright(box, box) is 'implementation of &> operator';

create function pg_catalog.box_recv(internal) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_recv(internal) is 'I/O';

create function pg_catalog.box_right(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_right(box, box) is 'implementation of >> operator';

create function pg_catalog.box_same(box, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_same(box, box) is 'implementation of ~= operator';

create function pg_catalog.box_send(box) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_send(box) is 'I/O';

create function pg_catalog.box_sub(box, point) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_sub(box, point) is 'implementation of - operator';

create function pg_catalog.bpchar("char") returns char
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar("char") is 'convert char to char(n)';

create function pg_catalog.bpchar(char, integer, boolean) returns char
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar(char, integer, boolean) is 'adjust char() to typmod length';

create function pg_catalog.bpchar(name) returns char
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar(name) is 'convert name to char(n)';

create function pg_catalog.bpchar_larger(char, char) returns char
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_larger(char, char) is 'larger of two';

create function pg_catalog.bpchar_pattern_ge(char, char) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_ge(char, char) is 'implementation of ~>=~ operator';

create function pg_catalog.bpchar_pattern_gt(char, char) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_gt(char, char) is 'implementation of ~>~ operator';

create function pg_catalog.bpchar_pattern_le(char, char) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_le(char, char) is 'implementation of ~<=~ operator';

create function pg_catalog.bpchar_pattern_lt(char, char) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_lt(char, char) is 'implementation of ~<~ operator';

create function pg_catalog.bpchar_smaller(char, char) returns char
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_smaller(char, char) is 'smaller of two';

create function pg_catalog.bpchar_sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_sortsupport(internal) is 'sort support';

create function pg_catalog.bpcharcmp(char, char) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharcmp(char, char) is 'less-equal-greater';

create function pg_catalog.bpchareq(char, char) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchareq(char, char) is 'implementation of = operator';

create function pg_catalog.bpcharge(char, char) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharge(char, char) is 'implementation of >= operator';

create function pg_catalog.bpchargt(char, char) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchargt(char, char) is 'implementation of > operator';

create function pg_catalog.bpchariclike(char, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchariclike(char, text) is 'implementation of ~~* operator';

create function pg_catalog.bpcharicnlike(char, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicnlike(char, text) is 'implementation of !~~* operator';

create function pg_catalog.bpcharicregexeq(char, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicregexeq(char, text) is 'implementation of ~* operator';

create function pg_catalog.bpcharicregexne(char, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicregexne(char, text) is 'implementation of !~* operator';

create function pg_catalog.bpcharin(cstring, oid, integer) returns char
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharin(cstring, oid, integer) is 'I/O';

create function pg_catalog.bpcharle(char, char) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharle(char, char) is 'implementation of <= operator';

create function pg_catalog.bpcharlike(char, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharlike(char, text) is 'implementation of ~~ operator';

create function pg_catalog.bpcharlt(char, char) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharlt(char, char) is 'implementation of < operator';

create function pg_catalog.bpcharne(char, char) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharne(char, char) is 'implementation of <> operator';

create function pg_catalog.bpcharnlike(char, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharnlike(char, text) is 'implementation of !~~ operator';

create function pg_catalog.bpcharout(char) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharout(char) is 'I/O';

create function pg_catalog.bpcharrecv(internal, oid, integer) returns char
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharrecv(internal, oid, integer) is 'I/O';

create function pg_catalog.bpcharregexeq(char, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharregexeq(char, text) is 'implementation of ~ operator';

create function pg_catalog.bpcharregexne(char, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharregexne(char, text) is 'implementation of !~ operator';

create function pg_catalog.bpcharsend(char) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharsend(char) is 'I/O';

create function pg_catalog.bpchartypmodin(cstring[]) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchartypmodin(cstring[]) is 'I/O typmod';

create function pg_catalog.bpchartypmodout(integer) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchartypmodout(integer) is 'I/O typmod';

create function pg_catalog.brin_desummarize_range(regclass, bigint) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_desummarize_range(regclass, bigint) is 'brin: desummarize page range';

create function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal) is 'BRIN inclusion support';

create function pg_catalog.brin_inclusion_consistent(internal, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_consistent(internal, internal, internal) is 'BRIN inclusion support';

create function pg_catalog.brin_inclusion_opcinfo(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_opcinfo(internal) is 'BRIN inclusion support';

create function pg_catalog.brin_inclusion_union(internal, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_union(internal, internal, internal) is 'BRIN inclusion support';

create function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal) is 'BRIN minmax support';

create function pg_catalog.brin_minmax_consistent(internal, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_consistent(internal, internal, internal) is 'BRIN minmax support';

create function pg_catalog.brin_minmax_opcinfo(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_opcinfo(internal) is 'BRIN minmax support';

create function pg_catalog.brin_minmax_union(internal, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_union(internal, internal, internal) is 'BRIN minmax support';

create function pg_catalog.brin_summarize_new_values(regclass) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_summarize_new_values(regclass) is 'brin: standalone scan new table pages';

create function pg_catalog.brin_summarize_range(regclass, bigint) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_summarize_range(regclass, bigint) is 'brin: standalone scan new table pages';

create function pg_catalog.brinhandler(internal) returns index_am_handler
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brinhandler(internal) is 'brin index access method handler';

create function pg_catalog.broadcast(inet) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.broadcast(inet) is 'broadcast address of network';

create function pg_catalog.btarraycmp(anyarray, anyarray) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btarraycmp(anyarray, anyarray) is 'less-equal-greater';

create function pg_catalog.btboolcmp(boolean, boolean) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btboolcmp(boolean, boolean) is 'less-equal-greater';

create function pg_catalog.btbpchar_pattern_cmp(char, char) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btbpchar_pattern_cmp(char, char) is 'less-equal-greater';

create function pg_catalog.btbpchar_pattern_sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btbpchar_pattern_sortsupport(internal) is 'sort support';

create function pg_catalog.btcharcmp("char", "char") returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btcharcmp("char", "char") is 'less-equal-greater';

create function pg_catalog.btequalimage(oid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btequalimage(oid) is 'equal image';

create function pg_catalog.btfloat48cmp(real, double precision) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat48cmp(real, double precision) is 'less-equal-greater';

create function pg_catalog.btfloat4cmp(real, real) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat4cmp(real, real) is 'less-equal-greater';

create function pg_catalog.btfloat4sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat4sortsupport(internal) is 'sort support';

create function pg_catalog.btfloat84cmp(double precision, real) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat84cmp(double precision, real) is 'less-equal-greater';

create function pg_catalog.btfloat8cmp(double precision, double precision) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat8cmp(double precision, double precision) is 'less-equal-greater';

create function pg_catalog.btfloat8sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat8sortsupport(internal) is 'sort support';

create function pg_catalog.bthandler(internal) returns index_am_handler
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bthandler(internal) is 'btree index access method handler';

create function pg_catalog.btint24cmp(smallint, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint24cmp(smallint, integer) is 'less-equal-greater';

create function pg_catalog.btint28cmp(smallint, bigint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint28cmp(smallint, bigint) is 'less-equal-greater';

create function pg_catalog.btint2cmp(smallint, smallint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint2cmp(smallint, smallint) is 'less-equal-greater';

create function pg_catalog.btint2sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint2sortsupport(internal) is 'sort support';

create function pg_catalog.btint42cmp(integer, smallint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint42cmp(integer, smallint) is 'less-equal-greater';

create function pg_catalog.btint48cmp(integer, bigint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint48cmp(integer, bigint) is 'less-equal-greater';

create function pg_catalog.btint4cmp(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint4cmp(integer, integer) is 'less-equal-greater';

create function pg_catalog.btint4sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint4sortsupport(internal) is 'sort support';

create function pg_catalog.btint82cmp(bigint, smallint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint82cmp(bigint, smallint) is 'less-equal-greater';

create function pg_catalog.btint84cmp(bigint, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint84cmp(bigint, integer) is 'less-equal-greater';

create function pg_catalog.btint8cmp(bigint, bigint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint8cmp(bigint, bigint) is 'less-equal-greater';

create function pg_catalog.btint8sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint8sortsupport(internal) is 'sort support';

create function pg_catalog.btnamecmp(name, name) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnamecmp(name, name) is 'less-equal-greater';

create function pg_catalog.btnamesortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnamesortsupport(internal) is 'sort support';

create function pg_catalog.btnametextcmp(name, text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnametextcmp(name, text) is 'less-equal-greater';

create function pg_catalog.btoidcmp(oid, oid) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidcmp(oid, oid) is 'less-equal-greater';

create function pg_catalog.btoidsortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidsortsupport(internal) is 'sort support';

create function pg_catalog.btoidvectorcmp(oidvector, oidvector) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidvectorcmp(oidvector, oidvector) is 'less-equal-greater';

create function pg_catalog.btrecordcmp(record, record) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrecordcmp(record, record) is 'less-equal-greater';

create function pg_catalog.btrecordimagecmp(record, record) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrecordimagecmp(record, record) is 'less-equal-greater based on byte images';

create function pg_catalog.btrim(bytea, bytea) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim(bytea, bytea) is 'trim both ends of string';

create function pg_catalog.btrim(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim(text) is 'trim spaces from both ends of string';

create function pg_catalog.btrim(text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim(text, text) is 'trim selected characters from both ends of string';

create function pg_catalog.bttext_pattern_cmp(text, text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttext_pattern_cmp(text, text) is 'less-equal-greater';

create function pg_catalog.bttext_pattern_sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttext_pattern_sortsupport(internal) is 'sort support';

create function pg_catalog.bttextcmp(text, text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextcmp(text, text) is 'less-equal-greater';

create function pg_catalog.bttextnamecmp(text, name) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextnamecmp(text, name) is 'less-equal-greater';

create function pg_catalog.bttextsortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextsortsupport(internal) is 'sort support';

create function pg_catalog.bttidcmp(tid, tid) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttidcmp(tid, tid) is 'less-equal-greater';

create function pg_catalog.btvarstrequalimage(oid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btvarstrequalimage(oid) is 'equal image';

create function pg_catalog.bytea_sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_sortsupport(internal) is 'sort support';

create function pg_catalog.bytea_string_agg_finalfn(internal) returns bytea
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_string_agg_finalfn(internal) is 'aggregate final function';

create function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea) is 'aggregate transition function';

create function pg_catalog.byteacat(bytea, bytea) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteacat(bytea, bytea) is 'implementation of || operator';

create function pg_catalog.byteacmp(bytea, bytea) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteacmp(bytea, bytea) is 'less-equal-greater';

create function pg_catalog.byteaeq(bytea, bytea) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteaeq(bytea, bytea) is 'implementation of = operator';

create function pg_catalog.byteage(bytea, bytea) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteage(bytea, bytea) is 'implementation of >= operator';

create function pg_catalog.byteagt(bytea, bytea) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteagt(bytea, bytea) is 'implementation of > operator';

create function pg_catalog.byteain(cstring) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteain(cstring) is 'I/O';

create function pg_catalog.byteale(bytea, bytea) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteale(bytea, bytea) is 'implementation of <= operator';

create function pg_catalog.bytealike(bytea, bytea) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytealike(bytea, bytea) is 'implementation of ~~ operator';

create function pg_catalog.bytealt(bytea, bytea) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytealt(bytea, bytea) is 'implementation of < operator';

create function pg_catalog.byteane(bytea, bytea) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteane(bytea, bytea) is 'implementation of <> operator';

create function pg_catalog.byteanlike(bytea, bytea) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteanlike(bytea, bytea) is 'implementation of !~~ operator';

create function pg_catalog.byteaout(bytea) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteaout(bytea) is 'I/O';

create function pg_catalog.bytearecv(internal) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytearecv(internal) is 'I/O';

create function pg_catalog.byteasend(bytea) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteasend(bytea) is 'I/O';

create function pg_catalog.cardinality(anyarray) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cardinality(anyarray) is 'array cardinality';

create function pg_catalog.cash_cmp(money, money) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_cmp(money, money) is 'less-equal-greater';

create function pg_catalog.cash_div_cash(money, money) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_cash(money, money) is 'implementation of / operator';

create function pg_catalog.cash_div_flt4(money, real) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_flt4(money, real) is 'implementation of / operator';

create function pg_catalog.cash_div_flt8(money, double precision) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_flt8(money, double precision) is 'implementation of / operator';

create function pg_catalog.cash_div_int2(money, smallint) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int2(money, smallint) is 'implementation of / operator';

create function pg_catalog.cash_div_int4(money, integer) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int4(money, integer) is 'implementation of / operator';

create function pg_catalog.cash_div_int8(money, bigint) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int8(money, bigint) is 'implementation of / operator';

create function pg_catalog.cash_eq(money, money) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_eq(money, money) is 'implementation of = operator';

create function pg_catalog.cash_ge(money, money) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_ge(money, money) is 'implementation of >= operator';

create function pg_catalog.cash_gt(money, money) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_gt(money, money) is 'implementation of > operator';

create function pg_catalog.cash_in(cstring) returns money
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_in(cstring) is 'I/O';

create function pg_catalog.cash_le(money, money) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_le(money, money) is 'implementation of <= operator';

create function pg_catalog.cash_lt(money, money) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_lt(money, money) is 'implementation of < operator';

create function pg_catalog.cash_mi(money, money) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mi(money, money) is 'implementation of - operator';

create function pg_catalog.cash_mul_flt4(money, real) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_flt4(money, real) is 'implementation of * operator';

create function pg_catalog.cash_mul_flt8(money, double precision) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_flt8(money, double precision) is 'implementation of * operator';

create function pg_catalog.cash_mul_int2(money, smallint) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int2(money, smallint) is 'implementation of * operator';

create function pg_catalog.cash_mul_int4(money, integer) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int4(money, integer) is 'implementation of * operator';

create function pg_catalog.cash_mul_int8(money, bigint) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int8(money, bigint) is 'implementation of * operator';

create function pg_catalog.cash_ne(money, money) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_ne(money, money) is 'implementation of <> operator';

create function pg_catalog.cash_out(money) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_out(money) is 'I/O';

create function pg_catalog.cash_pl(money, money) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_pl(money, money) is 'implementation of + operator';

create function pg_catalog.cash_recv(internal) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_recv(internal) is 'I/O';

create function pg_catalog.cash_send(money) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_send(money) is 'I/O';

create function pg_catalog.cash_words(money) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_words(money) is 'output money amount as words';

create function pg_catalog.cashlarger(money, money) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cashlarger(money, money) is 'larger of two';

create function pg_catalog.cashsmaller(money, money) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cashsmaller(money, money) is 'smaller of two';

create function pg_catalog.cbrt(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cbrt(double precision) is 'cube root';

create function pg_catalog.ceil(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceil(double precision) is 'nearest integer >= value';

create function pg_catalog.ceil(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceil(numeric) is 'nearest integer >= value';

create function pg_catalog.ceiling(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceiling(double precision) is 'nearest integer >= value';

create function pg_catalog.ceiling(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceiling(numeric) is 'nearest integer >= value';

create function pg_catalog.center(box) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.center(box) is 'center of';

create function pg_catalog.center(circle) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.center(circle) is 'center of';

create function pg_catalog.char(integer) returns "char"
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char(integer) is 'convert int4 to char';

create function pg_catalog.char(text) returns "char"
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char(text) is 'convert text to char';

create function pg_catalog.char_length(char) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char_length(char) is 'character length';

create function pg_catalog.char_length(text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char_length(text) is 'character length';

create function pg_catalog.character_length(char) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.character_length(char) is 'character length';

create function pg_catalog.character_length(text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.character_length(text) is 'character length';

create function pg_catalog.chareq("char", "char") returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chareq("char", "char") is 'implementation of = operator';

create function pg_catalog.charge("char", "char") returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charge("char", "char") is 'implementation of >= operator';

create function pg_catalog.chargt("char", "char") returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chargt("char", "char") is 'implementation of > operator';

create function pg_catalog.charin(cstring) returns "char"
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charin(cstring) is 'I/O';

create function pg_catalog.charle("char", "char") returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charle("char", "char") is 'implementation of <= operator';

create function pg_catalog.charlt("char", "char") returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charlt("char", "char") is 'implementation of < operator';

create function pg_catalog.charne("char", "char") returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charne("char", "char") is 'implementation of <> operator';

create function pg_catalog.charout("char") returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charout("char") is 'I/O';

create function pg_catalog.charrecv(internal) returns "char"
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charrecv(internal) is 'I/O';

create function pg_catalog.charsend("char") returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charsend("char") is 'I/O';

create function pg_catalog.chr(integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chr(integer) is 'convert int4 to char';

create function pg_catalog.cideq(cid, cid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cideq(cid, cid) is 'implementation of = operator';

create function pg_catalog.cidin(cstring) returns cid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidin(cstring) is 'I/O';

create function pg_catalog.cidout(cid) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidout(cid) is 'I/O';

create function pg_catalog.cidr(inet) returns cidr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr(inet) is 'convert inet to cidr';

create function pg_catalog.cidr_in(cstring) returns cidr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_in(cstring) is 'I/O';

create function pg_catalog.cidr_out(cidr) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_out(cidr) is 'I/O';

create function pg_catalog.cidr_recv(internal) returns cidr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_recv(internal) is 'I/O';

create function pg_catalog.cidr_send(cidr) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_send(cidr) is 'I/O';

create function pg_catalog.cidrecv(internal) returns cid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidrecv(internal) is 'I/O';

create function pg_catalog.cidsend(cid) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidsend(cid) is 'I/O';

create function pg_catalog.circle(box) returns circle
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(box) is 'convert box to circle';

create function pg_catalog.circle(point, double precision) returns circle
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(point, double precision) is 'convert point and radius to circle';

create function pg_catalog.circle(polygon) returns circle
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(polygon) is 'convert polygon to circle';

create function pg_catalog.circle_above(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_above(circle, circle) is 'implementation of |>> operator';

create function pg_catalog.circle_add_pt(circle, point) returns circle
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_add_pt(circle, point) is 'implementation of + operator';

create function pg_catalog.circle_below(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_below(circle, circle) is 'implementation of <<| operator';

create function pg_catalog.circle_center(circle) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_center(circle) is 'implementation of @@ operator';

create function pg_catalog.circle_contain(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contain(circle, circle) is 'implementation of @> operator';

create function pg_catalog.circle_contain_pt(circle, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contain_pt(circle, point) is 'implementation of @> operator';

create function pg_catalog.circle_contained(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contained(circle, circle) is 'implementation of <@ operator';

create function pg_catalog.circle_distance(circle, circle) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_distance(circle, circle) is 'implementation of <-> operator';

create function pg_catalog.circle_div_pt(circle, point) returns circle
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_div_pt(circle, point) is 'implementation of / operator';

create function pg_catalog.circle_eq(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_eq(circle, circle) is 'implementation of = operator';

create function pg_catalog.circle_ge(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_ge(circle, circle) is 'implementation of >= operator';

create function pg_catalog.circle_gt(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_gt(circle, circle) is 'implementation of > operator';

create function pg_catalog.circle_in(cstring) returns circle
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_in(cstring) is 'I/O';

create function pg_catalog.circle_le(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_le(circle, circle) is 'implementation of <= operator';

create function pg_catalog.circle_left(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_left(circle, circle) is 'implementation of << operator';

create function pg_catalog.circle_lt(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_lt(circle, circle) is 'implementation of < operator';

create function pg_catalog.circle_mul_pt(circle, point) returns circle
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_mul_pt(circle, point) is 'implementation of * operator';

create function pg_catalog.circle_ne(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_ne(circle, circle) is 'implementation of <> operator';

create function pg_catalog.circle_out(circle) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_out(circle) is 'I/O';

create function pg_catalog.circle_overabove(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overabove(circle, circle) is 'implementation of |&> operator';

create function pg_catalog.circle_overbelow(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overbelow(circle, circle) is 'implementation of &<| operator';

create function pg_catalog.circle_overlap(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overlap(circle, circle) is 'implementation of && operator';

create function pg_catalog.circle_overleft(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overleft(circle, circle) is 'implementation of &< operator';

create function pg_catalog.circle_overright(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overright(circle, circle) is 'implementation of &> operator';

create function pg_catalog.circle_recv(internal) returns circle
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_recv(internal) is 'I/O';

create function pg_catalog.circle_right(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_right(circle, circle) is 'implementation of >> operator';

create function pg_catalog.circle_same(circle, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_same(circle, circle) is 'implementation of ~= operator';

create function pg_catalog.circle_send(circle) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_send(circle) is 'I/O';

create function pg_catalog.circle_sub_pt(circle, point) returns circle
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_sub_pt(circle, point) is 'implementation of - operator';

create function pg_catalog.clock_timestamp() returns timestamp with time zone
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.clock_timestamp() is 'current clock time';

create function pg_catalog.close_lb(line, box) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_lb(line, box) is 'implementation of ## operator';

create function pg_catalog.close_ls(line, lseg) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_ls(line, lseg) is 'implementation of ## operator';

create function pg_catalog.close_lseg(lseg, lseg) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_lseg(lseg, lseg) is 'implementation of ## operator';

create function pg_catalog.close_pb(point, box) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_pb(point, box) is 'implementation of ## operator';

create function pg_catalog.close_pl(point, line) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_pl(point, line) is 'implementation of ## operator';

create function pg_catalog.close_ps(point, lseg) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_ps(point, lseg) is 'implementation of ## operator';

create function pg_catalog.close_sb(lseg, box) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_sb(lseg, box) is 'implementation of ## operator';

create function pg_catalog.close_sl(lseg, line) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_sl(lseg, line) is 'implementation of ## operator';

create function pg_catalog.col_description(oid, integer) returns text
    stable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.col_description(oid, integer) is 'get description for table column';

create function pg_catalog.concat("any") returns text
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.concat("any") is 'concatenate values';

create function pg_catalog.concat_ws(text, "any") returns text
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.concat_ws(text, "any") is 'concatenate values with separators';

create function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for containment comparison operators';

create function pg_catalog.contsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.contsel(internal, oid, internal, integer) is 'restriction selectivity for containment comparison operators';

create function pg_catalog.convert(bytea, name, name) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert(bytea, name, name) is 'convert string with specified encoding names';

create function pg_catalog.convert_from(bytea, name) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert_from(bytea, name) is 'convert string with specified source encoding name';

create function pg_catalog.convert_to(text, name) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert_to(text, name) is 'convert string with specified destination encoding name';

create function pg_catalog.cos(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cos(double precision) is 'cosine';

create function pg_catalog.cosd(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cosd(double precision) is 'cosine, degrees';

create function pg_catalog.cosh(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cosh(double precision) is 'hyperbolic cosine';

create function pg_catalog.cot(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cot(double precision) is 'cotangent';

create function pg_catalog.cotd(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cotd(double precision) is 'cotangent, degrees';

create function pg_catalog.cstring_in(cstring) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_in(cstring) is 'I/O';

create function pg_catalog.cstring_out(cstring) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_out(cstring) is 'I/O';

create function pg_catalog.cstring_recv(internal) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_recv(internal) is 'I/O';

create function pg_catalog.cstring_send(cstring) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_send(cstring) is 'I/O';

create function pg_catalog.cume_dist() returns double precision
    immutable
    window
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cume_dist() is 'fractional row number within partition';

create function pg_catalog.cume_dist_final(internal, "any") returns double precision
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cume_dist_final(internal, "any") is 'aggregate final function';

create function pg_catalog.current_database() returns name
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_database() is 'name of the current database';

create function pg_catalog.current_query() returns text
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_query() is 'get the currently executing query';

create function pg_catalog."current_schema"() returns name
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."current_schema"() is 'current schema name';

create function pg_catalog.current_schemas(boolean) returns name[]
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_schemas(boolean) is 'current schema search list';

create function pg_catalog.current_setting(text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_setting(text) is 'SHOW X as a function';

create function pg_catalog.current_setting(text, boolean) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_setting(text, boolean) is 'SHOW X as a function, optionally no error for missing variable';

create function pg_catalog."current_user"() returns name
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."current_user"() is 'current user name';

create function pg_catalog.currtid(oid, tid) returns tid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.currtid(oid, tid) is 'latest tid of a tuple';

create function pg_catalog.currtid2(text, tid) returns tid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.currtid2(text, tid) is 'latest tid of a tuple';

create function pg_catalog.currval(regclass) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.currval(regclass) is 'sequence current value';

create function pg_catalog.cursor_to_xml(cursor refcursor, count integer, nulls boolean, tableforest boolean, targetns text) returns xml
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cursor_to_xml(refcursor, integer, boolean, boolean, text) is 'map rows from cursor to XML';

create function pg_catalog.cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text) returns xml
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cursor_to_xmlschema(refcursor, boolean, boolean, text) is 'map cursor structure to XML Schema';

create function pg_catalog.database_to_xml(nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xml(boolean, boolean, text) is 'map database contents to XML';

create function pg_catalog.database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xml_and_xmlschema(boolean, boolean, text) is 'map database contents and structure to XML and XML Schema';

create function pg_catalog.database_to_xmlschema(nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xmlschema(boolean, boolean, text) is 'map database structure to XML Schema';

create function pg_catalog.date(timestamp with time zone) returns date
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date(timestamp with time zone) is 'convert timestamp with time zone to date';

create function pg_catalog.date(timestamp) returns date
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date(timestamp) is 'convert timestamp to date';

create function pg_catalog.date_cmp(date, date) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp(date, date) is 'less-equal-greater';

create function pg_catalog.date_cmp_timestamp(date, timestamp) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp_timestamp(date, timestamp) is 'less-equal-greater';

create function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone) returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone) is 'less-equal-greater';

create function pg_catalog.date_eq(date, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq(date, date) is 'implementation of = operator';

create function pg_catalog.date_eq_timestamp(date, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq_timestamp(date, timestamp) is 'implementation of = operator';

create function pg_catalog.date_eq_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq_timestamptz(date, timestamp with time zone) is 'implementation of = operator';

create function pg_catalog.date_ge(date, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge(date, date) is 'implementation of >= operator';

create function pg_catalog.date_ge_timestamp(date, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge_timestamp(date, timestamp) is 'implementation of >= operator';

create function pg_catalog.date_ge_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge_timestamptz(date, timestamp with time zone) is 'implementation of >= operator';

create function pg_catalog.date_gt(date, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt(date, date) is 'implementation of > operator';

create function pg_catalog.date_gt_timestamp(date, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt_timestamp(date, timestamp) is 'implementation of > operator';

create function pg_catalog.date_gt_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt_timestamptz(date, timestamp with time zone) is 'implementation of > operator';

create function pg_catalog.date_in(cstring) returns date
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_in(cstring) is 'I/O';

create function pg_catalog.date_larger(date, date) returns date
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_larger(date, date) is 'larger of two';

create function pg_catalog.date_le(date, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le(date, date) is 'implementation of <= operator';

create function pg_catalog.date_le_timestamp(date, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le_timestamp(date, timestamp) is 'implementation of <= operator';

create function pg_catalog.date_le_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le_timestamptz(date, timestamp with time zone) is 'implementation of <= operator';

create function pg_catalog.date_lt(date, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt(date, date) is 'implementation of < operator';

create function pg_catalog.date_lt_timestamp(date, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt_timestamp(date, timestamp) is 'implementation of < operator';

create function pg_catalog.date_lt_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt_timestamptz(date, timestamp with time zone) is 'implementation of < operator';

create function pg_catalog.date_mi(date, date) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mi(date, date) is 'implementation of - operator';

create function pg_catalog.date_mi_interval(date, interval) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mi_interval(date, interval) is 'implementation of - operator';

create function pg_catalog.date_mii(date, integer) returns date
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mii(date, integer) is 'implementation of - operator';

create function pg_catalog.date_ne(date, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne(date, date) is 'implementation of <> operator';

create function pg_catalog.date_ne_timestamp(date, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne_timestamp(date, timestamp) is 'implementation of <> operator';

create function pg_catalog.date_ne_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne_timestamptz(date, timestamp with time zone) is 'implementation of <> operator';

create function pg_catalog.date_out(date) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_out(date) is 'I/O';

create function pg_catalog.date_part(text, date) returns double precision
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(text, date) is 'extract field from date';

create function pg_catalog.date_part(text, interval) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(text, interval) is 'extract field from interval';

create function pg_catalog.date_part(text, time with time zone) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(text, time with time zone) is 'extract field from time with time zone';

create function pg_catalog.date_part(text, time) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(text, time) is 'extract field from time';

create function pg_catalog.date_part(text, timestamp with time zone) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(text, timestamp with time zone) is 'extract field from timestamp with time zone';

create function pg_catalog.date_part(text, timestamp) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(text, timestamp) is 'extract field from timestamp';

create function pg_catalog.date_pl_interval(date, interval) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_pl_interval(date, interval) is 'implementation of + operator';

create function pg_catalog.date_pli(date, integer) returns date
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_pli(date, integer) is 'implementation of + operator';

create function pg_catalog.date_recv(internal) returns date
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_recv(internal) is 'I/O';

create function pg_catalog.date_send(date) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_send(date) is 'I/O';

create function pg_catalog.date_smaller(date, date) returns date
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_smaller(date, date) is 'smaller of two';

create function pg_catalog.date_sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_sortsupport(internal) is 'sort support';

create function pg_catalog.date_trunc(text, interval) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(text, interval) is 'truncate interval to specified units';

create function pg_catalog.date_trunc(text, timestamp with time zone) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(text, timestamp with time zone) is 'truncate timestamp with time zone to specified units';

create function pg_catalog.date_trunc(text, timestamp with time zone, text) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(text, timestamp with time zone, text) is 'truncate timestamp with time zone to specified units in specified time zone';

create function pg_catalog.date_trunc(text, timestamp) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(text, timestamp) is 'truncate timestamp to specified units';

create function pg_catalog.daterange(date, date) returns daterange
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange(date, date) is 'daterange constructor';

create function pg_catalog.daterange(date, date, text) returns daterange
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange(date, date, text) is 'daterange constructor';

create function pg_catalog.daterange_canonical(daterange) returns daterange
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange_canonical(daterange) is 'convert a date range to canonical form';

create function pg_catalog.daterange_subdiff(date, date) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange_subdiff(date, date) is 'float8 difference of two date values';

create function pg_catalog.datetime_pl(date, time) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datetime_pl(date, time) is 'implementation of + operator';

create function pg_catalog.datetimetz_pl(date, time with time zone) returns timestamp with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datetimetz_pl(date, time with time zone) is 'implementation of + operator';

create function pg_catalog.dcbrt(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dcbrt(double precision) is 'implementation of ||/ operator';

create function pg_catalog.decode(text, text) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.decode(text, text) is 'convert ascii-encoded text string into bytea value';

create function pg_catalog.degrees(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.degrees(double precision) is 'radians to degrees';

create function pg_catalog.dense_rank() returns bigint
    immutable
    window
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dense_rank() is 'integer rank without gaps';

create function pg_catalog.dense_rank_final(internal, "any") returns bigint
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dense_rank_final(internal, "any") is 'aggregate final function';

create function pg_catalog.dexp(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dexp(double precision) is 'natural exponential (e^x)';

create function pg_catalog.diagonal(box) returns lseg
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.diagonal(box) is 'box diagonal';

create function pg_catalog.diameter(circle) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.diameter(circle) is 'diameter of circle';

create function pg_catalog.dispell_init(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dispell_init(internal) is '(internal)';

create function pg_catalog.dispell_lexize(internal, internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dispell_lexize(internal, internal, internal, internal) is '(internal)';

create function pg_catalog.dist_bl(box, line) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_bl(box, line) is 'implementation of <-> operator';

create function pg_catalog.dist_bp(box, point) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_bp(box, point) is 'implementation of <-> operator';

create function pg_catalog.dist_bs(box, lseg) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_bs(box, lseg) is 'implementation of <-> operator';

create function pg_catalog.dist_cpoint(circle, point) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_cpoint(circle, point) is 'implementation of <-> operator';

create function pg_catalog.dist_cpoly(circle, polygon) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_cpoly(circle, polygon) is 'implementation of <-> operator';

create function pg_catalog.dist_lb(line, box) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_lb(line, box) is 'implementation of <-> operator';

create function pg_catalog.dist_lp(line, point) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_lp(line, point) is 'implementation of <-> operator';

create function pg_catalog.dist_ls(line, lseg) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ls(line, lseg) is 'implementation of <-> operator';

create function pg_catalog.dist_pathp(path, point) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pathp(path, point) is 'implementation of <-> operator';

create function pg_catalog.dist_pb(point, box) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pb(point, box) is 'implementation of <-> operator';

create function pg_catalog.dist_pc(point, circle) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pc(point, circle) is 'implementation of <-> operator';

create function pg_catalog.dist_pl(point, line) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pl(point, line) is 'implementation of <-> operator';

create function pg_catalog.dist_polyc(polygon, circle) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_polyc(polygon, circle) is 'implementation of <-> operator';

create function pg_catalog.dist_polyp(polygon, point) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_polyp(polygon, point) is 'implementation of <-> operator';

create function pg_catalog.dist_ppath(point, path) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ppath(point, path) is 'implementation of <-> operator';

create function pg_catalog.dist_ppoly(point, polygon) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ppoly(point, polygon) is 'implementation of <-> operator';

create function pg_catalog.dist_ps(point, lseg) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ps(point, lseg) is 'implementation of <-> operator';

create function pg_catalog.dist_sb(lseg, box) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_sb(lseg, box) is 'implementation of <-> operator';

create function pg_catalog.dist_sl(lseg, line) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_sl(lseg, line) is 'implementation of <-> operator';

create function pg_catalog.dist_sp(lseg, point) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_sp(lseg, point) is 'implementation of <-> operator';

create function pg_catalog.div(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.div(numeric, numeric) is 'trunc(x/y)';

create function pg_catalog.dlog1(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dlog1(double precision) is 'natural logarithm';

create function pg_catalog.dlog10(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dlog10(double precision) is 'base 10 logarithm';

create function pg_catalog.domain_in(cstring, oid, integer) returns "any"
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.domain_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.domain_recv(internal, oid, integer) returns "any"
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.domain_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.dpow(double precision, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dpow(double precision, double precision) is 'implementation of ^ operator';

create function pg_catalog.dround(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dround(double precision) is 'round to nearest integer';

create function pg_catalog.dsimple_init(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsimple_init(internal) is '(internal)';

create function pg_catalog.dsimple_lexize(internal, internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsimple_lexize(internal, internal, internal, internal) is '(internal)';

create function pg_catalog.dsnowball_init(internal) returns internal
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

create function pg_catalog.dsnowball_lexize(internal, internal, internal, internal) returns internal
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

create function pg_catalog.dsqrt(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsqrt(double precision) is 'implementation of |/ operator';

create function pg_catalog.dsynonym_init(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsynonym_init(internal) is '(internal)';

create function pg_catalog.dsynonym_lexize(internal, internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsynonym_lexize(internal, internal, internal, internal) is '(internal)';

create function pg_catalog.dtrunc(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dtrunc(double precision) is 'truncate to integer';

create function pg_catalog.elem_contained_by_range(anyelement, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.elem_contained_by_range(anyelement, anyrange) is 'implementation of <@ operator';

create function pg_catalog.encode(bytea, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.encode(bytea, text) is 'convert bytea value into some ascii-only text string';

create function pg_catalog.enum_cmp(anyenum, anyenum) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_cmp(anyenum, anyenum) is 'less-equal-greater';

create function pg_catalog.enum_eq(anyenum, anyenum) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_eq(anyenum, anyenum) is 'implementation of = operator';

create function pg_catalog.enum_first(anyenum) returns anyenum
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_first(anyenum) is 'first value of the input enum type';

create function pg_catalog.enum_ge(anyenum, anyenum) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_ge(anyenum, anyenum) is 'implementation of >= operator';

create function pg_catalog.enum_gt(anyenum, anyenum) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_gt(anyenum, anyenum) is 'implementation of > operator';

create function pg_catalog.enum_in(cstring, oid) returns anyenum
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_in(cstring, oid) is 'I/O';

create function pg_catalog.enum_larger(anyenum, anyenum) returns anyenum
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_larger(anyenum, anyenum) is 'larger of two';

create function pg_catalog.enum_last(anyenum) returns anyenum
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_last(anyenum) is 'last value of the input enum type';

create function pg_catalog.enum_le(anyenum, anyenum) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_le(anyenum, anyenum) is 'implementation of <= operator';

create function pg_catalog.enum_lt(anyenum, anyenum) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_lt(anyenum, anyenum) is 'implementation of < operator';

create function pg_catalog.enum_ne(anyenum, anyenum) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_ne(anyenum, anyenum) is 'implementation of <> operator';

create function pg_catalog.enum_out(anyenum) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_out(anyenum) is 'I/O';

create function pg_catalog.enum_range(anyenum) returns anyarray
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_range(anyenum) is 'range of the given enum type, as an ordered array';

create function pg_catalog.enum_range(anyenum, anyenum) returns anyarray
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_range(anyenum, anyenum) is 'range between the two given enum values, as an ordered array';

create function pg_catalog.enum_recv(internal, oid) returns anyenum
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_recv(internal, oid) is 'I/O';

create function pg_catalog.enum_send(anyenum) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_send(anyenum) is 'I/O';

create function pg_catalog.enum_smaller(anyenum, anyenum) returns anyenum
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_smaller(anyenum, anyenum) is 'smaller of two';

create function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of = and related operators';

create function pg_catalog.eqsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.eqsel(internal, oid, internal, integer) is 'restriction selectivity of = and related operators';

create function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_CN to MULE_INTERNAL';

create function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_CN to UTF8';

create function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_JIS_2004 to SHIFT_JIS_2004';

create function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_JIS_2004 to UTF8';

create function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_JP to MULE_INTERNAL';

create function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_JP to SJIS';

create function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_JP to UTF8';

create function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_KR to MULE_INTERNAL';

create function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_KR to UTF8';

create function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_TW to BIG5';

create function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_TW to MULE_INTERNAL';

create function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_TW to UTF8';

create function pg_catalog.event_trigger_in(cstring) returns event_trigger
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.event_trigger_in(cstring) is 'I/O';

create function pg_catalog.event_trigger_out(event_trigger) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.event_trigger_out(event_trigger) is 'I/O';

create function pg_catalog.exp(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.exp(double precision) is 'natural exponential (e^x)';

create function pg_catalog.exp(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.exp(numeric) is 'natural exponential (e^x)';

create function pg_catalog.factorial(bigint) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.factorial(bigint) is 'factorial';

create function pg_catalog.family(inet) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.family(inet) is 'address family (4 for IPv4, 6 for IPv6)';

create function pg_catalog.fdw_handler_in(cstring) returns fdw_handler
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fdw_handler_in(cstring) is 'I/O';

create function pg_catalog.fdw_handler_out(fdw_handler) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fdw_handler_out(fdw_handler) is 'I/O';

create function pg_catalog.first_value(anyelement) returns anyelement
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.first_value(anyelement) is 'fetch the first row value';

create function pg_catalog.float4(bigint) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(bigint) is 'convert int8 to float4';

create function pg_catalog.float4(double precision) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(double precision) is 'convert float8 to float4';

create function pg_catalog.float4(integer) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(integer) is 'convert int4 to float4';

create function pg_catalog.float4(jsonb) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(jsonb) is 'convert jsonb to float4';

create function pg_catalog.float4(numeric) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(numeric) is 'convert numeric to float4';

create function pg_catalog.float4(smallint) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(smallint) is 'convert int2 to float4';

create function pg_catalog.float48div(real, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48div(real, double precision) is 'implementation of / operator';

create function pg_catalog.float48eq(real, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48eq(real, double precision) is 'implementation of = operator';

create function pg_catalog.float48ge(real, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48ge(real, double precision) is 'implementation of >= operator';

create function pg_catalog.float48gt(real, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48gt(real, double precision) is 'implementation of > operator';

create function pg_catalog.float48le(real, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48le(real, double precision) is 'implementation of <= operator';

create function pg_catalog.float48lt(real, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48lt(real, double precision) is 'implementation of < operator';

create function pg_catalog.float48mi(real, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48mi(real, double precision) is 'implementation of - operator';

create function pg_catalog.float48mul(real, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48mul(real, double precision) is 'implementation of * operator';

create function pg_catalog.float48ne(real, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48ne(real, double precision) is 'implementation of <> operator';

create function pg_catalog.float48pl(real, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48pl(real, double precision) is 'implementation of + operator';

create function pg_catalog.float4_accum(double precision[], real) returns double precision[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4_accum(double precision[], real) is 'aggregate transition function';

create function pg_catalog.float4abs(real) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4abs(real) is 'implementation of @ operator';

create function pg_catalog.float4div(real, real) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4div(real, real) is 'implementation of / operator';

create function pg_catalog.float4eq(real, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4eq(real, real) is 'implementation of = operator';

create function pg_catalog.float4ge(real, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4ge(real, real) is 'implementation of >= operator';

create function pg_catalog.float4gt(real, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4gt(real, real) is 'implementation of > operator';

create function pg_catalog.float4in(cstring) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4in(cstring) is 'I/O';

create function pg_catalog.float4larger(real, real) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4larger(real, real) is 'larger of two';

create function pg_catalog.float4le(real, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4le(real, real) is 'implementation of <= operator';

create function pg_catalog.float4lt(real, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4lt(real, real) is 'implementation of < operator';

create function pg_catalog.float4mi(real, real) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4mi(real, real) is 'implementation of - operator';

create function pg_catalog.float4mul(real, real) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4mul(real, real) is 'implementation of * operator';

create function pg_catalog.float4ne(real, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4ne(real, real) is 'implementation of <> operator';

create function pg_catalog.float4out(real) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4out(real) is 'I/O';

create function pg_catalog.float4pl(real, real) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4pl(real, real) is 'implementation of + operator';

create function pg_catalog.float4recv(internal) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4recv(internal) is 'I/O';

create function pg_catalog.float4send(real) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4send(real) is 'I/O';

create function pg_catalog.float4smaller(real, real) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4smaller(real, real) is 'smaller of two';

create function pg_catalog.float4um(real) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4um(real) is 'implementation of - operator';

create function pg_catalog.float4up(real) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4up(real) is 'implementation of + operator';

create function pg_catalog.float8(bigint) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(bigint) is 'convert int8 to float8';

create function pg_catalog.float8(integer) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(integer) is 'convert int4 to float8';

create function pg_catalog.float8(jsonb) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(jsonb) is 'convert jsonb to float8';

create function pg_catalog.float8(numeric) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(numeric) is 'convert numeric to float8';

create function pg_catalog.float8(real) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(real) is 'convert float4 to float8';

create function pg_catalog.float8(smallint) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(smallint) is 'convert int2 to float8';

create function pg_catalog.float84div(double precision, real) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84div(double precision, real) is 'implementation of / operator';

create function pg_catalog.float84eq(double precision, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84eq(double precision, real) is 'implementation of = operator';

create function pg_catalog.float84ge(double precision, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84ge(double precision, real) is 'implementation of >= operator';

create function pg_catalog.float84gt(double precision, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84gt(double precision, real) is 'implementation of > operator';

create function pg_catalog.float84le(double precision, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84le(double precision, real) is 'implementation of <= operator';

create function pg_catalog.float84lt(double precision, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84lt(double precision, real) is 'implementation of < operator';

create function pg_catalog.float84mi(double precision, real) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84mi(double precision, real) is 'implementation of - operator';

create function pg_catalog.float84mul(double precision, real) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84mul(double precision, real) is 'implementation of * operator';

create function pg_catalog.float84ne(double precision, real) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84ne(double precision, real) is 'implementation of <> operator';

create function pg_catalog.float84pl(double precision, real) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84pl(double precision, real) is 'implementation of + operator';

create function pg_catalog.float8_accum(double precision[], double precision) returns double precision[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_accum(double precision[], double precision) is 'aggregate transition function';

create function pg_catalog.float8_avg(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_avg(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_combine(double precision[], double precision[]) returns double precision[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_combine(double precision[], double precision[]) is 'aggregate combine function';

create function pg_catalog.float8_corr(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_corr(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_covar_pop(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_covar_pop(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_covar_samp(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_covar_samp(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_regr_accum(double precision[], double precision, double precision) returns double precision[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_accum(double precision[], double precision, double precision) is 'aggregate transition function';

create function pg_catalog.float8_regr_avgx(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_avgx(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_regr_avgy(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_avgy(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_regr_combine(double precision[], double precision[]) returns double precision[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_combine(double precision[], double precision[]) is 'aggregate combine function';

create function pg_catalog.float8_regr_intercept(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_intercept(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_regr_r2(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_r2(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_regr_slope(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_slope(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_regr_sxx(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_sxx(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_regr_sxy(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_sxy(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_regr_syy(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_syy(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_stddev_pop(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_stddev_pop(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_stddev_samp(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_stddev_samp(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_var_pop(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_var_pop(double precision[]) is 'aggregate final function';

create function pg_catalog.float8_var_samp(double precision[]) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_var_samp(double precision[]) is 'aggregate final function';

create function pg_catalog.float8abs(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8abs(double precision) is 'implementation of @ operator';

create function pg_catalog.float8div(double precision, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8div(double precision, double precision) is 'implementation of / operator';

create function pg_catalog.float8eq(double precision, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8eq(double precision, double precision) is 'implementation of = operator';

create function pg_catalog.float8ge(double precision, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8ge(double precision, double precision) is 'implementation of >= operator';

create function pg_catalog.float8gt(double precision, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8gt(double precision, double precision) is 'implementation of > operator';

create function pg_catalog.float8in(cstring) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8in(cstring) is 'I/O';

create function pg_catalog.float8larger(double precision, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8larger(double precision, double precision) is 'larger of two';

create function pg_catalog.float8le(double precision, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8le(double precision, double precision) is 'implementation of <= operator';

create function pg_catalog.float8lt(double precision, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8lt(double precision, double precision) is 'implementation of < operator';

create function pg_catalog.float8mi(double precision, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8mi(double precision, double precision) is 'implementation of - operator';

create function pg_catalog.float8mul(double precision, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8mul(double precision, double precision) is 'implementation of * operator';

create function pg_catalog.float8ne(double precision, double precision) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8ne(double precision, double precision) is 'implementation of <> operator';

create function pg_catalog.float8out(double precision) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8out(double precision) is 'I/O';

create function pg_catalog.float8pl(double precision, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8pl(double precision, double precision) is 'implementation of + operator';

create function pg_catalog.float8recv(internal) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8recv(internal) is 'I/O';

create function pg_catalog.float8send(double precision) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8send(double precision) is 'I/O';

create function pg_catalog.float8smaller(double precision, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8smaller(double precision, double precision) is 'smaller of two';

create function pg_catalog.float8um(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8um(double precision) is 'implementation of - operator';

create function pg_catalog.float8up(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8up(double precision) is 'implementation of + operator';

create function pg_catalog.floor(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.floor(double precision) is 'nearest integer <= value';

create function pg_catalog.floor(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.floor(numeric) is 'nearest integer <= value';

create function pg_catalog.flt4_mul_cash(real, money) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.flt4_mul_cash(real, money) is 'implementation of * operator';

create function pg_catalog.flt8_mul_cash(double precision, money) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.flt8_mul_cash(double precision, money) is 'implementation of * operator';

create function pg_catalog.fmgr_c_validator(oid) returns void
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_c_validator(oid) is '(internal)';

create function pg_catalog.fmgr_internal_validator(oid) returns void
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_internal_validator(oid) is '(internal)';

create function pg_catalog.fmgr_sql_validator(oid) returns void
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_sql_validator(oid) is '(internal)';

create function pg_catalog.format(text) returns text
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format(text) is 'format text message';

create function pg_catalog.format(text, "any") returns text
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format(text, "any") is 'format text message';

create function pg_catalog.format_type(oid, integer) returns text
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format_type(oid, integer) is 'format a type oid and atttypmod to canonical SQL';

create function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for GB18030 to UTF8';

create function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for GBK to UTF8';

create function pg_catalog.gcd(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gcd(bigint, bigint) is 'greatest common divisor';

create function pg_catalog.gcd(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gcd(integer, integer) is 'greatest common divisor';

create function pg_catalog.gcd(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gcd(numeric, numeric) is 'greatest common divisor';

create function pg_catalog.gen_random_uuid() returns uuid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gen_random_uuid() is 'generate random UUID';

create function pg_catalog.generate_series(bigint, bigint) returns setof setof bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(bigint, bigint) is 'non-persistent series generator';

create function pg_catalog.generate_series(bigint, bigint, bigint) returns setof setof bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(bigint, bigint, bigint) is 'non-persistent series generator';

create function pg_catalog.generate_series(integer, integer) returns setof setof integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(integer, integer) is 'non-persistent series generator';

create function pg_catalog.generate_series(integer, integer, integer) returns setof setof integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(integer, integer, integer) is 'non-persistent series generator';

create function pg_catalog.generate_series(numeric, numeric) returns setof setof numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(numeric, numeric) is 'non-persistent series generator';

create function pg_catalog.generate_series(numeric, numeric, numeric) returns setof setof numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(numeric, numeric, numeric) is 'non-persistent series generator';

create function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval) returns setof setof timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval) is 'non-persistent series generator';

create function pg_catalog.generate_series(timestamp, timestamp, interval) returns setof setof timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(timestamp, timestamp, interval) is 'non-persistent series generator';

create function pg_catalog.generate_series_int4_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series_int4_support(internal) is 'planner support for generate_series';

create function pg_catalog.generate_series_int8_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series_int8_support(internal) is 'planner support for generate_series';

create function pg_catalog.generate_subscripts(anyarray, integer) returns setof setof integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_subscripts(anyarray, integer) is 'array subscripts generator';

create function pg_catalog.generate_subscripts(anyarray, integer, boolean) returns setof setof integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_subscripts(anyarray, integer, boolean) is 'array subscripts generator';

create function pg_catalog.get_bit(bit, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_bit(bit, integer) is 'get bit';

create function pg_catalog.get_bit(bytea, bigint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_bit(bytea, bigint) is 'get bit';

create function pg_catalog.get_byte(bytea, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_byte(bytea, integer) is 'get byte';

create function pg_catalog.get_current_ts_config() returns regconfig
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_current_ts_config() is 'get current tsearch configuration';

create function pg_catalog.getdatabaseencoding() returns name
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.getdatabaseencoding() is 'encoding name of current database';

create function pg_catalog.getpgusername() returns name
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.getpgusername() is 'deprecated, use current_user instead';

create function pg_catalog.gin_clean_pending_list(regclass) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_clean_pending_list(regclass) is 'clean up GIN pending list';

create function pg_catalog.gin_cmp_prefix(text, text, smallint, internal) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_cmp_prefix(text, text, smallint, internal) is 'GIN tsvector support';

create function pg_catalog.gin_cmp_tslexeme(text, text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_cmp_tslexeme(text, text) is 'GIN tsvector support';

create function pg_catalog.gin_compare_jsonb(text, text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_compare_jsonb(text, text) is 'GIN support';

create function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal, internal) is 'GIN support';

create function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal, internal) is 'GIN support';

create function pg_catalog.gin_extract_jsonb(jsonb, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb(jsonb, internal, internal) is 'GIN support';

create function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal) is 'GIN support';

create function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal) is 'GIN support';

create function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal) is 'GIN support';

create function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal) is 'GIN tsvector support (obsolete)';

create function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal) is 'GIN tsvector support (obsolete)';

create function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal) is 'GIN tsvector support';

create function pg_catalog.gin_extract_tsvector(tsvector, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsvector(tsvector, internal) is 'GIN tsvector support (obsolete)';

create function pg_catalog.gin_extract_tsvector(tsvector, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsvector(tsvector, internal, internal) is 'GIN tsvector support';

create function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal) returns "char"
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal) is 'GIN support';

create function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal) returns "char"
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal) is 'GIN support';

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal) is 'GIN tsvector support (obsolete)';

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal, internal) is 'GIN tsvector support (obsolete)';

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal, internal) is 'GIN tsvector support';

create function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal) returns "char"
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal) is 'GIN tsvector support';

create function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal, internal) is 'GIN array support';

create function pg_catalog.ginarrayextract(anyarray, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayextract(anyarray, internal) is 'GIN array support (obsolete)';

create function pg_catalog.ginarrayextract(anyarray, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayextract(anyarray, internal, internal) is 'GIN array support';

create function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal) returns "char"
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal) is 'GIN array support';

create function pg_catalog.ginhandler(internal) returns index_am_handler
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginhandler(internal) is 'gin index access method handler';

create function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal) is 'GIN array support';

create function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal) is 'GiST support';

create function pg_catalog.gist_box_distance(internal, box, smallint, oid, internal) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_distance(internal, box, smallint, oid, internal) is 'GiST support';

create function pg_catalog.gist_box_penalty(internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_penalty(internal, internal, internal) is 'GiST support';

create function pg_catalog.gist_box_picksplit(internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_picksplit(internal, internal) is 'GiST support';

create function pg_catalog.gist_box_same(box, box, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_same(box, box, internal) is 'GiST support';

create function pg_catalog.gist_box_union(internal, internal) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_union(internal, internal) is 'GiST support';

create function pg_catalog.gist_circle_compress(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_compress(internal) is 'GiST support';

create function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal) is 'GiST support';

create function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal) is 'GiST support';

create function pg_catalog.gist_point_compress(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_compress(internal) is 'GiST support';

create function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal) is 'GiST support';

create function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal) is 'GiST support';

create function pg_catalog.gist_point_fetch(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_fetch(internal) is 'GiST support';

create function pg_catalog.gist_poly_compress(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_compress(internal) is 'GiST support';

create function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal) is 'GiST support';

create function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal) is 'GiST support';

create function pg_catalog.gisthandler(internal) returns index_am_handler
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gisthandler(internal) is 'gist index access method handler';

create function pg_catalog.gtsquery_compress(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_compress(internal) is 'GiST tsquery support';

create function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal) is 'GiST tsquery support (obsolete)';

create function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal) is 'GiST tsquery support';

create function pg_catalog.gtsquery_penalty(internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_penalty(internal, internal, internal) is 'GiST tsquery support';

create function pg_catalog.gtsquery_picksplit(internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_picksplit(internal, internal) is 'GiST tsquery support';

create function pg_catalog.gtsquery_same(bigint, bigint, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_same(bigint, bigint, internal) is 'GiST tsquery support';

create function pg_catalog.gtsquery_union(internal, internal) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_union(internal, internal) is 'GiST tsquery support';

create function pg_catalog.gtsvector_compress(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_compress(internal) is 'GiST tsvector support';

create function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal) is 'GiST tsvector support (obsolete)';

create function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal) is 'GiST tsvector support';

create function pg_catalog.gtsvector_decompress(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_decompress(internal) is 'GiST tsvector support';

create function pg_catalog.gtsvector_options(internal) returns void
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_options(internal) is 'GiST tsvector support';

create function pg_catalog.gtsvector_penalty(internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_penalty(internal, internal, internal) is 'GiST tsvector support';

create function pg_catalog.gtsvector_picksplit(internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_picksplit(internal, internal) is 'GiST tsvector support';

create function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal) is 'GiST tsvector support';

create function pg_catalog.gtsvector_union(internal, internal) returns gtsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_union(internal, internal) is 'GiST tsvector support';

create function pg_catalog.gtsvectorin(cstring) returns gtsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvectorin(cstring) is 'I/O';

create function pg_catalog.gtsvectorout(gtsvector) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvectorout(gtsvector) is 'I/O';

create function pg_catalog.has_any_column_privilege(name, oid, text) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(name, oid, text) is 'user privilege on any column by username, rel oid';

create function pg_catalog.has_any_column_privilege(name, text, text) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(name, text, text) is 'user privilege on any column by username, rel name';

create function pg_catalog.has_any_column_privilege(oid, oid, text) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(oid, oid, text) is 'user privilege on any column by user oid, rel oid';

create function pg_catalog.has_any_column_privilege(oid, text) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(oid, text) is 'current user privilege on any column by rel oid';

create function pg_catalog.has_any_column_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(oid, text, text) is 'user privilege on any column by user oid, rel name';

create function pg_catalog.has_any_column_privilege(text, text) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(text, text) is 'current user privilege on any column by rel name';

create function pg_catalog.has_column_privilege(name, oid, smallint, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, oid, smallint, text) is 'user privilege on column by username, rel oid, col attnum';

create function pg_catalog.has_column_privilege(name, oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, oid, text, text) is 'user privilege on column by username, rel oid, col name';

create function pg_catalog.has_column_privilege(name, text, smallint, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, text, smallint, text) is 'user privilege on column by username, rel name, col attnum';

create function pg_catalog.has_column_privilege(name, text, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, text, text, text) is 'user privilege on column by username, rel name, col name';

create function pg_catalog.has_column_privilege(oid, oid, smallint, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, oid, smallint, text) is 'user privilege on column by user oid, rel oid, col attnum';

create function pg_catalog.has_column_privilege(oid, oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, oid, text, text) is 'user privilege on column by user oid, rel oid, col name';

create function pg_catalog.has_column_privilege(oid, smallint, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, smallint, text) is 'current user privilege on column by rel oid, col attnum';

create function pg_catalog.has_column_privilege(oid, text, smallint, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, text, smallint, text) is 'user privilege on column by user oid, rel name, col attnum';

create function pg_catalog.has_column_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, text, text) is 'current user privilege on column by rel oid, col name';

create function pg_catalog.has_column_privilege(oid, text, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, text, text, text) is 'user privilege on column by user oid, rel name, col name';

create function pg_catalog.has_column_privilege(text, smallint, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(text, smallint, text) is 'current user privilege on column by rel name, col attnum';

create function pg_catalog.has_column_privilege(text, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(text, text, text) is 'current user privilege on column by rel name, col name';

create function pg_catalog.has_database_privilege(name, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(name, oid, text) is 'user privilege on database by username, database oid';

create function pg_catalog.has_database_privilege(name, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(name, text, text) is 'user privilege on database by username, database name';

create function pg_catalog.has_database_privilege(oid, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(oid, oid, text) is 'user privilege on database by user oid, database oid';

create function pg_catalog.has_database_privilege(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(oid, text) is 'current user privilege on database by database oid';

create function pg_catalog.has_database_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(oid, text, text) is 'user privilege on database by user oid, database name';

create function pg_catalog.has_database_privilege(text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(text, text) is 'current user privilege on database by database name';

create function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text) is 'user privilege on foreign data wrapper by username, foreign data wrapper oid';

create function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text) is 'user privilege on foreign data wrapper by username, foreign data wrapper name';

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text) is 'user privilege on foreign data wrapper by user oid, foreign data wrapper oid';

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, text) is 'current user privilege on foreign data wrapper by foreign data wrapper oid';

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text) is 'user privilege on foreign data wrapper by user oid, foreign data wrapper name';

create function pg_catalog.has_foreign_data_wrapper_privilege(text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(text, text) is 'current user privilege on foreign data wrapper by foreign data wrapper name';

create function pg_catalog.has_function_privilege(name, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(name, oid, text) is 'user privilege on function by username, function oid';

create function pg_catalog.has_function_privilege(name, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(name, text, text) is 'user privilege on function by username, function name';

create function pg_catalog.has_function_privilege(oid, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(oid, oid, text) is 'user privilege on function by user oid, function oid';

create function pg_catalog.has_function_privilege(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(oid, text) is 'current user privilege on function by function oid';

create function pg_catalog.has_function_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(oid, text, text) is 'user privilege on function by user oid, function name';

create function pg_catalog.has_function_privilege(text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(text, text) is 'current user privilege on function by function name';

create function pg_catalog.has_language_privilege(name, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(name, oid, text) is 'user privilege on language by username, language oid';

create function pg_catalog.has_language_privilege(name, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(name, text, text) is 'user privilege on language by username, language name';

create function pg_catalog.has_language_privilege(oid, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(oid, oid, text) is 'user privilege on language by user oid, language oid';

create function pg_catalog.has_language_privilege(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(oid, text) is 'current user privilege on language by language oid';

create function pg_catalog.has_language_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(oid, text, text) is 'user privilege on language by user oid, language name';

create function pg_catalog.has_language_privilege(text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(text, text) is 'current user privilege on language by language name';

create function pg_catalog.has_schema_privilege(name, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(name, oid, text) is 'user privilege on schema by username, schema oid';

create function pg_catalog.has_schema_privilege(name, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(name, text, text) is 'user privilege on schema by username, schema name';

create function pg_catalog.has_schema_privilege(oid, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(oid, oid, text) is 'user privilege on schema by user oid, schema oid';

create function pg_catalog.has_schema_privilege(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(oid, text) is 'current user privilege on schema by schema oid';

create function pg_catalog.has_schema_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(oid, text, text) is 'user privilege on schema by user oid, schema name';

create function pg_catalog.has_schema_privilege(text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(text, text) is 'current user privilege on schema by schema name';

create function pg_catalog.has_sequence_privilege(name, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(name, oid, text) is 'user privilege on sequence by username, seq oid';

create function pg_catalog.has_sequence_privilege(name, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(name, text, text) is 'user privilege on sequence by username, seq name';

create function pg_catalog.has_sequence_privilege(oid, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(oid, oid, text) is 'user privilege on sequence by user oid, seq oid';

create function pg_catalog.has_sequence_privilege(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(oid, text) is 'current user privilege on sequence by seq oid';

create function pg_catalog.has_sequence_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(oid, text, text) is 'user privilege on sequence by user oid, seq name';

create function pg_catalog.has_sequence_privilege(text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(text, text) is 'current user privilege on sequence by seq name';

create function pg_catalog.has_server_privilege(name, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(name, oid, text) is 'user privilege on server by username, server oid';

create function pg_catalog.has_server_privilege(name, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(name, text, text) is 'user privilege on server by username, server name';

create function pg_catalog.has_server_privilege(oid, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(oid, oid, text) is 'user privilege on server by user oid, server oid';

create function pg_catalog.has_server_privilege(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(oid, text) is 'current user privilege on server by server oid';

create function pg_catalog.has_server_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(oid, text, text) is 'user privilege on server by user oid, server name';

create function pg_catalog.has_server_privilege(text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(text, text) is 'current user privilege on server by server name';

create function pg_catalog.has_table_privilege(name, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(name, oid, text) is 'user privilege on relation by username, rel oid';

create function pg_catalog.has_table_privilege(name, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(name, text, text) is 'user privilege on relation by username, rel name';

create function pg_catalog.has_table_privilege(oid, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(oid, oid, text) is 'user privilege on relation by user oid, rel oid';

create function pg_catalog.has_table_privilege(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(oid, text) is 'current user privilege on relation by rel oid';

create function pg_catalog.has_table_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(oid, text, text) is 'user privilege on relation by user oid, rel name';

create function pg_catalog.has_table_privilege(text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(text, text) is 'current user privilege on relation by rel name';

create function pg_catalog.has_tablespace_privilege(name, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(name, oid, text) is 'user privilege on tablespace by username, tablespace oid';

create function pg_catalog.has_tablespace_privilege(name, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(name, text, text) is 'user privilege on tablespace by username, tablespace name';

create function pg_catalog.has_tablespace_privilege(oid, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(oid, oid, text) is 'user privilege on tablespace by user oid, tablespace oid';

create function pg_catalog.has_tablespace_privilege(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(oid, text) is 'current user privilege on tablespace by tablespace oid';

create function pg_catalog.has_tablespace_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(oid, text, text) is 'user privilege on tablespace by user oid, tablespace name';

create function pg_catalog.has_tablespace_privilege(text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(text, text) is 'current user privilege on tablespace by tablespace name';

create function pg_catalog.has_type_privilege(name, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(name, oid, text) is 'user privilege on type by username, type oid';

create function pg_catalog.has_type_privilege(name, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(name, text, text) is 'user privilege on type by username, type name';

create function pg_catalog.has_type_privilege(oid, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(oid, oid, text) is 'user privilege on type by user oid, type oid';

create function pg_catalog.has_type_privilege(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(oid, text) is 'current user privilege on type by type oid';

create function pg_catalog.has_type_privilege(oid, text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(oid, text, text) is 'user privilege on type by user oid, type name';

create function pg_catalog.has_type_privilege(text, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(text, text) is 'current user privilege on type by type name';

create function pg_catalog.hash_aclitem(aclitem) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_aclitem(aclitem) is 'hash';

create function pg_catalog.hash_aclitem_extended(aclitem, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_aclitem_extended(aclitem, bigint) is 'hash';

create function pg_catalog.hash_array(anyarray) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_array(anyarray) is 'hash';

create function pg_catalog.hash_array_extended(anyarray, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_array_extended(anyarray, bigint) is 'hash';

create function pg_catalog.hash_numeric(numeric) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_numeric(numeric) is 'hash';

create function pg_catalog.hash_numeric_extended(numeric, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_numeric_extended(numeric, bigint) is 'hash';

create function pg_catalog.hash_range(anyrange) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_range(anyrange) is 'hash a range';

create function pg_catalog.hash_range_extended(anyrange, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_range_extended(anyrange, bigint) is 'hash a range';

create function pg_catalog.hashbpchar(char) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashbpchar(char) is 'hash';

create function pg_catalog.hashbpcharextended(char, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashbpcharextended(char, bigint) is 'hash';

create function pg_catalog.hashchar("char") returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashchar("char") is 'hash';

create function pg_catalog.hashcharextended("char", bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashcharextended("char", bigint) is 'hash';

create function pg_catalog.hashenum(anyenum) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashenum(anyenum) is 'hash';

create function pg_catalog.hashenumextended(anyenum, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashenumextended(anyenum, bigint) is 'hash';

create function pg_catalog.hashfloat4(real) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat4(real) is 'hash';

create function pg_catalog.hashfloat4extended(real, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat4extended(real, bigint) is 'hash';

create function pg_catalog.hashfloat8(double precision) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat8(double precision) is 'hash';

create function pg_catalog.hashfloat8extended(double precision, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat8extended(double precision, bigint) is 'hash';

create function pg_catalog.hashhandler(internal) returns index_am_handler
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashhandler(internal) is 'hash index access method handler';

create function pg_catalog.hashinet(inet) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashinet(inet) is 'hash';

create function pg_catalog.hashinetextended(inet, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashinetextended(inet, bigint) is 'hash';

create function pg_catalog.hashint2(smallint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint2(smallint) is 'hash';

create function pg_catalog.hashint2extended(smallint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint2extended(smallint, bigint) is 'hash';

create function pg_catalog.hashint4(integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint4(integer) is 'hash';

create function pg_catalog.hashint4extended(integer, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint4extended(integer, bigint) is 'hash';

create function pg_catalog.hashint8(bigint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint8(bigint) is 'hash';

create function pg_catalog.hashint8extended(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint8extended(bigint, bigint) is 'hash';

create function pg_catalog.hashmacaddr(macaddr) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr(macaddr) is 'hash';

create function pg_catalog.hashmacaddr8(macaddr8) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr8(macaddr8) is 'hash';

create function pg_catalog.hashmacaddr8extended(macaddr8, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr8extended(macaddr8, bigint) is 'hash';

create function pg_catalog.hashmacaddrextended(macaddr, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddrextended(macaddr, bigint) is 'hash';

create function pg_catalog.hashname(name) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashname(name) is 'hash';

create function pg_catalog.hashnameextended(name, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashnameextended(name, bigint) is 'hash';

create function pg_catalog.hashoid(oid) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoid(oid) is 'hash';

create function pg_catalog.hashoidextended(oid, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidextended(oid, bigint) is 'hash';

create function pg_catalog.hashoidvector(oidvector) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidvector(oidvector) is 'hash';

create function pg_catalog.hashoidvectorextended(oidvector, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidvectorextended(oidvector, bigint) is 'hash';

create function pg_catalog.hashtext(text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtext(text) is 'hash';

create function pg_catalog.hashtextextended(text, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtextextended(text, bigint) is 'hash';

create function pg_catalog.hashtid(tid) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtid(tid) is 'hash';

create function pg_catalog.hashtidextended(tid, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtidextended(tid, bigint) is 'hash';

create function pg_catalog.hashvarlena(internal) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashvarlena(internal) is 'hash';

create function pg_catalog.hashvarlenaextended(internal, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashvarlenaextended(internal, bigint) is 'hash';

create function pg_catalog.heap_tableam_handler(internal) returns table_am_handler
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.heap_tableam_handler(internal) is 'row-oriented heap table access method handler';

create function pg_catalog.height(box) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.height(box) is 'box height';

create function pg_catalog.host(inet) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.host(inet) is 'show address octets only';

create function pg_catalog.hostmask(inet) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hostmask(inet) is 'hostmask of address';

create function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of ILIKE';

create function pg_catalog.iclikesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iclikesel(internal, oid, internal, integer) is 'restriction selectivity of ILIKE';

create function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of NOT ILIKE';

create function pg_catalog.icnlikesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icnlikesel(internal, oid, internal, integer) is 'restriction selectivity of NOT ILIKE';

create function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of case-insensitive regex match';

create function pg_catalog.icregexeqsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexeqsel(internal, oid, internal, integer) is 'restriction selectivity of case-insensitive regex match';

create function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of case-insensitive regex non-match';

create function pg_catalog.icregexnesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexnesel(internal, oid, internal, integer) is 'restriction selectivity of case-insensitive regex non-match';

create function pg_catalog.in_range(bigint, bigint, bigint, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(bigint, bigint, bigint, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(date, date, interval, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(date, date, interval, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(double precision, double precision, double precision, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(double precision, double precision, double precision, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(integer, integer, bigint, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(integer, integer, bigint, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(integer, integer, integer, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(integer, integer, integer, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(integer, integer, smallint, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(integer, integer, smallint, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(interval, interval, interval, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(interval, interval, interval, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(numeric, numeric, numeric, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(numeric, numeric, numeric, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(real, real, double precision, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(real, real, double precision, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(smallint, smallint, bigint, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(smallint, smallint, bigint, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(smallint, smallint, integer, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(smallint, smallint, integer, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(smallint, smallint, smallint, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(smallint, smallint, smallint, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(time with time zone, time with time zone, interval, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(time with time zone, time with time zone, interval, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(time, time, interval, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(time, time, interval, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(timestamp with time zone, timestamp with time zone, interval, boolean, boolean) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(timestamp with time zone, timestamp with time zone, interval, boolean, boolean) is 'window RANGE support';

create function pg_catalog.in_range(timestamp, timestamp, interval, boolean, boolean) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(timestamp, timestamp, interval, boolean, boolean) is 'window RANGE support';

create function pg_catalog.index_am_handler_in(cstring) returns index_am_handler
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.index_am_handler_in(cstring) is 'I/O';

create function pg_catalog.index_am_handler_out(index_am_handler) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.index_am_handler_out(index_am_handler) is 'I/O';

create function pg_catalog.inet_client_addr() returns inet
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_client_addr() is 'inet address of the client';

create function pg_catalog.inet_client_port() returns integer
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_client_port() is 'client''s port number for this connection';

create function pg_catalog.inet_gist_compress(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_compress(internal) is 'GiST support';

create function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal) is 'GiST support';

create function pg_catalog.inet_gist_fetch(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_fetch(internal) is 'GiST support';

create function pg_catalog.inet_gist_penalty(internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_penalty(internal, internal, internal) is 'GiST support';

create function pg_catalog.inet_gist_picksplit(internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_picksplit(internal, internal) is 'GiST support';

create function pg_catalog.inet_gist_same(inet, inet, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_same(inet, inet, internal) is 'GiST support';

create function pg_catalog.inet_gist_union(internal, internal) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_union(internal, internal) is 'GiST support';

create function pg_catalog.inet_in(cstring) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_in(cstring) is 'I/O';

create function pg_catalog.inet_merge(inet, inet) returns cidr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_merge(inet, inet) is 'the smallest network which includes both of the given networks';

create function pg_catalog.inet_out(inet) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_out(inet) is 'I/O';

create function pg_catalog.inet_recv(internal) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_recv(internal) is 'I/O';

create function pg_catalog.inet_same_family(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_same_family(inet, inet) is 'are the addresses from the same family?';

create function pg_catalog.inet_send(inet) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_send(inet) is 'I/O';

create function pg_catalog.inet_server_addr() returns inet
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_server_addr() is 'inet address of the server';

create function pg_catalog.inet_server_port() returns integer
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_server_port() is 'server''s port number for this connection';

create function pg_catalog.inet_spg_choose(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_choose(internal, internal) is 'SP-GiST support';

create function pg_catalog.inet_spg_config(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_config(internal, internal) is 'SP-GiST support';

create function pg_catalog.inet_spg_inner_consistent(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_inner_consistent(internal, internal) is 'SP-GiST support';

create function pg_catalog.inet_spg_leaf_consistent(internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_leaf_consistent(internal, internal) is 'SP-GiST support';

create function pg_catalog.inet_spg_picksplit(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_picksplit(internal, internal) is 'SP-GiST support';

create function pg_catalog.inetand(inet, inet) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetand(inet, inet) is 'implementation of & operator';

create function pg_catalog.inetmi(inet, inet) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetmi(inet, inet) is 'implementation of - operator';

create function pg_catalog.inetmi_int8(inet, bigint) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetmi_int8(inet, bigint) is 'implementation of - operator';

create function pg_catalog.inetnot(inet) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetnot(inet) is 'implementation of ~ operator';

create function pg_catalog.inetor(inet, inet) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetor(inet, inet) is 'implementation of | operator';

create function pg_catalog.inetpl(inet, bigint) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetpl(inet, bigint) is 'implementation of + operator';

create function pg_catalog.initcap(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.initcap(text) is 'capitalize each word';

create function pg_catalog.int2(bigint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(bigint) is 'convert int8 to int2';

create function pg_catalog.int2(double precision) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(double precision) is 'convert float8 to int2';

create function pg_catalog.int2(integer) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(integer) is 'convert int4 to int2';

create function pg_catalog.int2(jsonb) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(jsonb) is 'convert jsonb to int2';

create function pg_catalog.int2(numeric) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(numeric) is 'convert numeric to int2';

create function pg_catalog.int2(real) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(real) is 'convert float4 to int2';

create function pg_catalog.int24div(smallint, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24div(smallint, integer) is 'implementation of / operator';

create function pg_catalog.int24eq(smallint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24eq(smallint, integer) is 'implementation of = operator';

create function pg_catalog.int24ge(smallint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24ge(smallint, integer) is 'implementation of >= operator';

create function pg_catalog.int24gt(smallint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24gt(smallint, integer) is 'implementation of > operator';

create function pg_catalog.int24le(smallint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24le(smallint, integer) is 'implementation of <= operator';

create function pg_catalog.int24lt(smallint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24lt(smallint, integer) is 'implementation of < operator';

create function pg_catalog.int24mi(smallint, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24mi(smallint, integer) is 'implementation of - operator';

create function pg_catalog.int24mul(smallint, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24mul(smallint, integer) is 'implementation of * operator';

create function pg_catalog.int24ne(smallint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24ne(smallint, integer) is 'implementation of <> operator';

create function pg_catalog.int24pl(smallint, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24pl(smallint, integer) is 'implementation of + operator';

create function pg_catalog.int28div(smallint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28div(smallint, bigint) is 'implementation of / operator';

create function pg_catalog.int28eq(smallint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28eq(smallint, bigint) is 'implementation of = operator';

create function pg_catalog.int28ge(smallint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28ge(smallint, bigint) is 'implementation of >= operator';

create function pg_catalog.int28gt(smallint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28gt(smallint, bigint) is 'implementation of > operator';

create function pg_catalog.int28le(smallint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28le(smallint, bigint) is 'implementation of <= operator';

create function pg_catalog.int28lt(smallint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28lt(smallint, bigint) is 'implementation of < operator';

create function pg_catalog.int28mi(smallint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28mi(smallint, bigint) is 'implementation of - operator';

create function pg_catalog.int28mul(smallint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28mul(smallint, bigint) is 'implementation of * operator';

create function pg_catalog.int28ne(smallint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28ne(smallint, bigint) is 'implementation of <> operator';

create function pg_catalog.int28pl(smallint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28pl(smallint, bigint) is 'implementation of + operator';

create function pg_catalog.int2_accum(internal, smallint) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_accum(internal, smallint) is 'aggregate transition function';

create function pg_catalog.int2_accum_inv(internal, smallint) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_accum_inv(internal, smallint) is 'aggregate transition function';

create function pg_catalog.int2_avg_accum(bigint[], smallint) returns bigint[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_avg_accum(bigint[], smallint) is 'aggregate transition function';

create function pg_catalog.int2_avg_accum_inv(bigint[], smallint) returns bigint[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_avg_accum_inv(bigint[], smallint) is 'aggregate transition function';

create function pg_catalog.int2_mul_cash(smallint, money) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_mul_cash(smallint, money) is 'implementation of * operator';

create function pg_catalog.int2_sum(bigint, smallint) returns bigint
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_sum(bigint, smallint) is 'aggregate transition function';

create function pg_catalog.int2abs(smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2abs(smallint) is 'implementation of @ operator';

create function pg_catalog.int2and(smallint, smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2and(smallint, smallint) is 'implementation of & operator';

create function pg_catalog.int2div(smallint, smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2div(smallint, smallint) is 'implementation of / operator';

create function pg_catalog.int2eq(smallint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2eq(smallint, smallint) is 'implementation of = operator';

create function pg_catalog.int2ge(smallint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2ge(smallint, smallint) is 'implementation of >= operator';

create function pg_catalog.int2gt(smallint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2gt(smallint, smallint) is 'implementation of > operator';

create function pg_catalog.int2in(cstring) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2in(cstring) is 'I/O';

create function pg_catalog.int2int4_sum(bigint[]) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2int4_sum(bigint[]) is 'aggregate final function';

create function pg_catalog.int2larger(smallint, smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2larger(smallint, smallint) is 'larger of two';

create function pg_catalog.int2le(smallint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2le(smallint, smallint) is 'implementation of <= operator';

create function pg_catalog.int2lt(smallint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2lt(smallint, smallint) is 'implementation of < operator';

create function pg_catalog.int2mi(smallint, smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mi(smallint, smallint) is 'implementation of - operator';

create function pg_catalog.int2mod(smallint, smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mod(smallint, smallint) is 'implementation of % operator';

create function pg_catalog.int2mul(smallint, smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mul(smallint, smallint) is 'implementation of * operator';

create function pg_catalog.int2ne(smallint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2ne(smallint, smallint) is 'implementation of <> operator';

create function pg_catalog.int2not(smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2not(smallint) is 'implementation of ~ operator';

create function pg_catalog.int2or(smallint, smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2or(smallint, smallint) is 'implementation of | operator';

create function pg_catalog.int2out(smallint) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2out(smallint) is 'I/O';

create function pg_catalog.int2pl(smallint, smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2pl(smallint, smallint) is 'implementation of + operator';

create function pg_catalog.int2recv(internal) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2recv(internal) is 'I/O';

create function pg_catalog.int2send(smallint) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2send(smallint) is 'I/O';

create function pg_catalog.int2shl(smallint, integer) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2shl(smallint, integer) is 'implementation of << operator';

create function pg_catalog.int2shr(smallint, integer) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2shr(smallint, integer) is 'implementation of >> operator';

create function pg_catalog.int2smaller(smallint, smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2smaller(smallint, smallint) is 'smaller of two';

create function pg_catalog.int2um(smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2um(smallint) is 'implementation of - operator';

create function pg_catalog.int2up(smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2up(smallint) is 'implementation of + operator';

create function pg_catalog.int2vectorin(cstring) returns int2vector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorin(cstring) is 'I/O';

create function pg_catalog.int2vectorout(int2vector) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorout(int2vector) is 'I/O';

create function pg_catalog.int2vectorrecv(internal) returns int2vector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorrecv(internal) is 'I/O';

create function pg_catalog.int2vectorsend(int2vector) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorsend(int2vector) is 'I/O';

create function pg_catalog.int2xor(smallint, smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2xor(smallint, smallint) is 'implementation of # operator';

create function pg_catalog.int4("char") returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4("char") is 'convert char to int4';

create function pg_catalog.int4(bigint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(bigint) is 'convert int8 to int4';

create function pg_catalog.int4(bit) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(bit) is 'convert bitstring to int4';

create function pg_catalog.int4(boolean) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(boolean) is 'convert boolean to int4';

create function pg_catalog.int4(double precision) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(double precision) is 'convert float8 to int4';

create function pg_catalog.int4(jsonb) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(jsonb) is 'convert jsonb to int4';

create function pg_catalog.int4(numeric) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(numeric) is 'convert numeric to int4';

create function pg_catalog.int4(real) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(real) is 'convert float4 to int4';

create function pg_catalog.int4(smallint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(smallint) is 'convert int2 to int4';

create function pg_catalog.int42div(integer, smallint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42div(integer, smallint) is 'implementation of / operator';

create function pg_catalog.int42eq(integer, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42eq(integer, smallint) is 'implementation of = operator';

create function pg_catalog.int42ge(integer, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42ge(integer, smallint) is 'implementation of >= operator';

create function pg_catalog.int42gt(integer, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42gt(integer, smallint) is 'implementation of > operator';

create function pg_catalog.int42le(integer, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42le(integer, smallint) is 'implementation of <= operator';

create function pg_catalog.int42lt(integer, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42lt(integer, smallint) is 'implementation of < operator';

create function pg_catalog.int42mi(integer, smallint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42mi(integer, smallint) is 'implementation of - operator';

create function pg_catalog.int42mul(integer, smallint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42mul(integer, smallint) is 'implementation of * operator';

create function pg_catalog.int42ne(integer, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42ne(integer, smallint) is 'implementation of <> operator';

create function pg_catalog.int42pl(integer, smallint) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42pl(integer, smallint) is 'implementation of + operator';

create function pg_catalog.int48div(integer, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48div(integer, bigint) is 'implementation of / operator';

create function pg_catalog.int48eq(integer, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48eq(integer, bigint) is 'implementation of = operator';

create function pg_catalog.int48ge(integer, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48ge(integer, bigint) is 'implementation of >= operator';

create function pg_catalog.int48gt(integer, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48gt(integer, bigint) is 'implementation of > operator';

create function pg_catalog.int48le(integer, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48le(integer, bigint) is 'implementation of <= operator';

create function pg_catalog.int48lt(integer, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48lt(integer, bigint) is 'implementation of < operator';

create function pg_catalog.int48mi(integer, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48mi(integer, bigint) is 'implementation of - operator';

create function pg_catalog.int48mul(integer, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48mul(integer, bigint) is 'implementation of * operator';

create function pg_catalog.int48ne(integer, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48ne(integer, bigint) is 'implementation of <> operator';

create function pg_catalog.int48pl(integer, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48pl(integer, bigint) is 'implementation of + operator';

create function pg_catalog.int4_accum(internal, integer) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_accum(internal, integer) is 'aggregate transition function';

create function pg_catalog.int4_accum_inv(internal, integer) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_accum_inv(internal, integer) is 'aggregate transition function';

create function pg_catalog.int4_avg_accum(bigint[], integer) returns bigint[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_accum(bigint[], integer) is 'aggregate transition function';

create function pg_catalog.int4_avg_accum_inv(bigint[], integer) returns bigint[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_accum_inv(bigint[], integer) is 'aggregate transition function';

create function pg_catalog.int4_avg_combine(bigint[], bigint[]) returns bigint[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_combine(bigint[], bigint[]) is 'aggregate combine function';

create function pg_catalog.int4_mul_cash(integer, money) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_mul_cash(integer, money) is 'implementation of * operator';

create function pg_catalog.int4_sum(bigint, integer) returns bigint
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_sum(bigint, integer) is 'aggregate transition function';

create function pg_catalog.int4abs(integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4abs(integer) is 'implementation of @ operator';

create function pg_catalog.int4and(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4and(integer, integer) is 'implementation of & operator';

create function pg_catalog.int4div(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4div(integer, integer) is 'implementation of / operator';

create function pg_catalog.int4eq(integer, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4eq(integer, integer) is 'implementation of = operator';

create function pg_catalog.int4ge(integer, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4ge(integer, integer) is 'implementation of >= operator';

create function pg_catalog.int4gt(integer, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4gt(integer, integer) is 'implementation of > operator';

create function pg_catalog.int4in(cstring) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4in(cstring) is 'I/O';

create function pg_catalog.int4inc(integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4inc(integer) is 'increment';

create function pg_catalog.int4larger(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4larger(integer, integer) is 'larger of two';

create function pg_catalog.int4le(integer, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4le(integer, integer) is 'implementation of <= operator';

create function pg_catalog.int4lt(integer, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4lt(integer, integer) is 'implementation of < operator';

create function pg_catalog.int4mi(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mi(integer, integer) is 'implementation of - operator';

create function pg_catalog.int4mod(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mod(integer, integer) is 'implementation of % operator';

create function pg_catalog.int4mul(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mul(integer, integer) is 'implementation of * operator';

create function pg_catalog.int4ne(integer, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4ne(integer, integer) is 'implementation of <> operator';

create function pg_catalog.int4not(integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4not(integer) is 'implementation of ~ operator';

create function pg_catalog.int4or(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4or(integer, integer) is 'implementation of | operator';

create function pg_catalog.int4out(integer) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4out(integer) is 'I/O';

create function pg_catalog.int4pl(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4pl(integer, integer) is 'implementation of + operator';

create function pg_catalog.int4range(integer, integer) returns int4range
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range(integer, integer) is 'int4range constructor';

create function pg_catalog.int4range(integer, integer, text) returns int4range
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range(integer, integer, text) is 'int4range constructor';

create function pg_catalog.int4range_canonical(int4range) returns int4range
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range_canonical(int4range) is 'convert an int4 range to canonical form';

create function pg_catalog.int4range_subdiff(integer, integer) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range_subdiff(integer, integer) is 'float8 difference of two int4 values';

create function pg_catalog.int4recv(internal) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4recv(internal) is 'I/O';

create function pg_catalog.int4send(integer) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4send(integer) is 'I/O';

create function pg_catalog.int4shl(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4shl(integer, integer) is 'implementation of << operator';

create function pg_catalog.int4shr(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4shr(integer, integer) is 'implementation of >> operator';

create function pg_catalog.int4smaller(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4smaller(integer, integer) is 'smaller of two';

create function pg_catalog.int4um(integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4um(integer) is 'implementation of - operator';

create function pg_catalog.int4up(integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4up(integer) is 'implementation of + operator';

create function pg_catalog.int4xor(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4xor(integer, integer) is 'implementation of # operator';

create function pg_catalog.int8(bit) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(bit) is 'convert bitstring to int8';

create function pg_catalog.int8(double precision) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(double precision) is 'convert float8 to int8';

create function pg_catalog.int8(integer) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(integer) is 'convert int4 to int8';

create function pg_catalog.int8(jsonb) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(jsonb) is 'convert jsonb to int8';

create function pg_catalog.int8(numeric) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(numeric) is 'convert numeric to int8';

create function pg_catalog.int8(oid) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(oid) is 'convert oid to int8';

create function pg_catalog.int8(real) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(real) is 'convert float4 to int8';

create function pg_catalog.int8(smallint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(smallint) is 'convert int2 to int8';

create function pg_catalog.int82div(bigint, smallint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82div(bigint, smallint) is 'implementation of / operator';

create function pg_catalog.int82eq(bigint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82eq(bigint, smallint) is 'implementation of = operator';

create function pg_catalog.int82ge(bigint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82ge(bigint, smallint) is 'implementation of >= operator';

create function pg_catalog.int82gt(bigint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82gt(bigint, smallint) is 'implementation of > operator';

create function pg_catalog.int82le(bigint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82le(bigint, smallint) is 'implementation of <= operator';

create function pg_catalog.int82lt(bigint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82lt(bigint, smallint) is 'implementation of < operator';

create function pg_catalog.int82mi(bigint, smallint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82mi(bigint, smallint) is 'implementation of - operator';

create function pg_catalog.int82mul(bigint, smallint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82mul(bigint, smallint) is 'implementation of * operator';

create function pg_catalog.int82ne(bigint, smallint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82ne(bigint, smallint) is 'implementation of <> operator';

create function pg_catalog.int82pl(bigint, smallint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82pl(bigint, smallint) is 'implementation of + operator';

create function pg_catalog.int84div(bigint, integer) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84div(bigint, integer) is 'implementation of / operator';

create function pg_catalog.int84eq(bigint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84eq(bigint, integer) is 'implementation of = operator';

create function pg_catalog.int84ge(bigint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84ge(bigint, integer) is 'implementation of >= operator';

create function pg_catalog.int84gt(bigint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84gt(bigint, integer) is 'implementation of > operator';

create function pg_catalog.int84le(bigint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84le(bigint, integer) is 'implementation of <= operator';

create function pg_catalog.int84lt(bigint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84lt(bigint, integer) is 'implementation of < operator';

create function pg_catalog.int84mi(bigint, integer) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84mi(bigint, integer) is 'implementation of - operator';

create function pg_catalog.int84mul(bigint, integer) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84mul(bigint, integer) is 'implementation of * operator';

create function pg_catalog.int84ne(bigint, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84ne(bigint, integer) is 'implementation of <> operator';

create function pg_catalog.int84pl(bigint, integer) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84pl(bigint, integer) is 'implementation of + operator';

create function pg_catalog.int8_accum(internal, bigint) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_accum(internal, bigint) is 'aggregate transition function';

create function pg_catalog.int8_accum_inv(internal, bigint) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_accum_inv(internal, bigint) is 'aggregate transition function';

create function pg_catalog.int8_avg(bigint[]) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg(bigint[]) is 'aggregate final function';

create function pg_catalog.int8_avg_accum(internal, bigint) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_accum(internal, bigint) is 'aggregate transition function';

create function pg_catalog.int8_avg_accum_inv(internal, bigint) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_accum_inv(internal, bigint) is 'aggregate transition function';

create function pg_catalog.int8_avg_combine(internal, internal) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_combine(internal, internal) is 'aggregate combine function';

create function pg_catalog.int8_avg_deserialize(bytea, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_deserialize(bytea, internal) is 'aggregate deserial function';

create function pg_catalog.int8_avg_serialize(internal) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_serialize(internal) is 'aggregate serial function';

create function pg_catalog.int8_mul_cash(bigint, money) returns money
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_mul_cash(bigint, money) is 'implementation of * operator';

create function pg_catalog.int8_sum(numeric, bigint) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_sum(numeric, bigint) is 'aggregate transition function';

create function pg_catalog.int8abs(bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8abs(bigint) is 'implementation of @ operator';

create function pg_catalog.int8and(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8and(bigint, bigint) is 'implementation of & operator';

create function pg_catalog.int8dec(bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8dec(bigint) is 'decrement';

create function pg_catalog.int8dec_any(bigint, "any") returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8dec_any(bigint, "any") is 'decrement, ignores second argument';

create function pg_catalog.int8div(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8div(bigint, bigint) is 'implementation of / operator';

create function pg_catalog.int8eq(bigint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8eq(bigint, bigint) is 'implementation of = operator';

create function pg_catalog.int8ge(bigint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8ge(bigint, bigint) is 'implementation of >= operator';

create function pg_catalog.int8gt(bigint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8gt(bigint, bigint) is 'implementation of > operator';

create function pg_catalog.int8in(cstring) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8in(cstring) is 'I/O';

create function pg_catalog.int8inc(bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc(bigint) is 'increment';

create function pg_catalog.int8inc_any(bigint, "any") returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc_any(bigint, "any") is 'increment, ignores second argument';

create function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision) is 'aggregate transition function';

create function pg_catalog.int8larger(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8larger(bigint, bigint) is 'larger of two';

create function pg_catalog.int8le(bigint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8le(bigint, bigint) is 'implementation of <= operator';

create function pg_catalog.int8lt(bigint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8lt(bigint, bigint) is 'implementation of < operator';

create function pg_catalog.int8mi(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mi(bigint, bigint) is 'implementation of - operator';

create function pg_catalog.int8mod(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mod(bigint, bigint) is 'implementation of % operator';

create function pg_catalog.int8mul(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mul(bigint, bigint) is 'implementation of * operator';

create function pg_catalog.int8ne(bigint, bigint) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8ne(bigint, bigint) is 'implementation of <> operator';

create function pg_catalog.int8not(bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8not(bigint) is 'implementation of ~ operator';

create function pg_catalog.int8or(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8or(bigint, bigint) is 'implementation of | operator';

create function pg_catalog.int8out(bigint) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8out(bigint) is 'I/O';

create function pg_catalog.int8pl(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8pl(bigint, bigint) is 'implementation of + operator';

create function pg_catalog.int8pl_inet(bigint, inet) returns inet
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8pl_inet(bigint, inet) is 'implementation of + operator';

create function pg_catalog.int8range(bigint, bigint) returns int8range
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range(bigint, bigint) is 'int8range constructor';

create function pg_catalog.int8range(bigint, bigint, text) returns int8range
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range(bigint, bigint, text) is 'int8range constructor';

create function pg_catalog.int8range_canonical(int8range) returns int8range
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range_canonical(int8range) is 'convert an int8 range to canonical form';

create function pg_catalog.int8range_subdiff(bigint, bigint) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range_subdiff(bigint, bigint) is 'float8 difference of two int8 values';

create function pg_catalog.int8recv(internal) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8recv(internal) is 'I/O';

create function pg_catalog.int8send(bigint) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8send(bigint) is 'I/O';

create function pg_catalog.int8shl(bigint, integer) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8shl(bigint, integer) is 'implementation of << operator';

create function pg_catalog.int8shr(bigint, integer) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8shr(bigint, integer) is 'implementation of >> operator';

create function pg_catalog.int8smaller(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8smaller(bigint, bigint) is 'smaller of two';

create function pg_catalog.int8um(bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8um(bigint) is 'implementation of - operator';

create function pg_catalog.int8up(bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8up(bigint) is 'implementation of + operator';

create function pg_catalog.int8xor(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8xor(bigint, bigint) is 'implementation of # operator';

create function pg_catalog.integer_pl_date(integer, date) returns date
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.integer_pl_date(integer, date) is 'implementation of + operator';

create function pg_catalog.inter_lb(line, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_lb(line, box) is 'implementation of ?# operator';

create function pg_catalog.inter_sb(lseg, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_sb(lseg, box) is 'implementation of ?# operator';

create function pg_catalog.inter_sl(lseg, line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_sl(lseg, line) is 'implementation of ?# operator';

create function pg_catalog.internal_in(cstring) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.internal_in(cstring) is 'I/O';

create function pg_catalog.internal_out(internal) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.internal_out(internal) is 'I/O';

create function pg_catalog.interval(interval, integer) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval(interval, integer) is 'adjust interval precision';

create function pg_catalog.interval(time) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval(time) is 'convert time to interval';

create function pg_catalog.interval_accum(interval[], interval) returns interval[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_accum(interval[], interval) is 'aggregate transition function';

create function pg_catalog.interval_accum_inv(interval[], interval) returns interval[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_accum_inv(interval[], interval) is 'aggregate transition function';

create function pg_catalog.interval_avg(interval[]) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_avg(interval[]) is 'aggregate final function';

create function pg_catalog.interval_cmp(interval, interval) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_cmp(interval, interval) is 'less-equal-greater';

create function pg_catalog.interval_combine(interval[], interval[]) returns interval[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_combine(interval[], interval[]) is 'aggregate combine function';

create function pg_catalog.interval_div(interval, double precision) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_div(interval, double precision) is 'implementation of / operator';

create function pg_catalog.interval_eq(interval, interval) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_eq(interval, interval) is 'implementation of = operator';

create function pg_catalog.interval_ge(interval, interval) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_ge(interval, interval) is 'implementation of >= operator';

create function pg_catalog.interval_gt(interval, interval) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_gt(interval, interval) is 'implementation of > operator';

create function pg_catalog.interval_hash(interval) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_hash(interval) is 'hash';

create function pg_catalog.interval_hash_extended(interval, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_hash_extended(interval, bigint) is 'hash';

create function pg_catalog.interval_in(cstring, oid, integer) returns interval
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.interval_larger(interval, interval) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_larger(interval, interval) is 'larger of two';

create function pg_catalog.interval_le(interval, interval) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_le(interval, interval) is 'implementation of <= operator';

create function pg_catalog.interval_lt(interval, interval) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_lt(interval, interval) is 'implementation of < operator';

create function pg_catalog.interval_mi(interval, interval) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_mi(interval, interval) is 'implementation of - operator';

create function pg_catalog.interval_mul(interval, double precision) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_mul(interval, double precision) is 'implementation of * operator';

create function pg_catalog.interval_ne(interval, interval) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_ne(interval, interval) is 'implementation of <> operator';

create function pg_catalog.interval_out(interval) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_out(interval) is 'I/O';

create function pg_catalog.interval_pl(interval, interval) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl(interval, interval) is 'implementation of + operator';

create function pg_catalog.interval_pl_date(interval, date) returns timestamp without time zone
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_date(interval, date) is 'implementation of + operator';

create function pg_catalog.interval_pl_time(interval, time without time zone) returns time without time zone
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_time(interval, time) is 'implementation of + operator';

create function pg_catalog.interval_pl_timestamp(interval, timestamp without time zone) returns timestamp without time zone
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_timestamp(interval, timestamp) is 'implementation of + operator';

create function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) returns timestamp with time zone
    stable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) is 'implementation of + operator';

create function pg_catalog.interval_pl_timetz(interval, time with time zone) returns time with time zone
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl_timetz(interval, time with time zone) is 'implementation of + operator';

create function pg_catalog.interval_recv(internal, oid, integer) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.interval_send(interval) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_send(interval) is 'I/O';

create function pg_catalog.interval_smaller(interval, interval) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_smaller(interval, interval) is 'smaller of two';

create function pg_catalog.interval_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_support(internal) is 'planner support for interval length coercion';

create function pg_catalog.interval_um(interval) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_um(interval) is 'implementation of - operator';

create function pg_catalog.intervaltypmodin(cstring[]) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.intervaltypmodin(cstring[]) is 'I/O typmod';

create function pg_catalog.intervaltypmodout(integer) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.intervaltypmodout(integer) is 'I/O typmod';

create function pg_catalog.is_normalized(text, text default 'NFC'::text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.is_normalized(text, text) is 'check Unicode normalization';

create function pg_catalog.isclosed(path) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isclosed(path) is 'path closed?';

create function pg_catalog.isempty(anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isempty(anyrange) is 'is the range empty?';

create function pg_catalog.isfinite(date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(date) is 'finite date?';

create function pg_catalog.isfinite(interval) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(interval) is 'finite interval?';

create function pg_catalog.isfinite(timestamp with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(timestamp with time zone) is 'finite timestamp?';

create function pg_catalog.isfinite(timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(timestamp) is 'finite timestamp?';

create function pg_catalog.ishorizontal(line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal(line) is 'horizontal';

create function pg_catalog.ishorizontal(lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal(lseg) is 'horizontal';

create function pg_catalog.ishorizontal(point, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal(point, point) is 'horizontally aligned';

create function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN1 to UTF8';

create function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for ISO-8859 2-16 to UTF8';

create function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer) is 'internal conversion function for ISO-8859-5 to KOI8R';

create function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for ISO-8859-5 to MULE_INTERNAL';

create function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer) is 'internal conversion function for ISO-8859-5 to WIN1251';

create function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer) is 'internal conversion function for ISO-8859-5 to WIN866';

create function pg_catalog.isopen(path) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isopen(path) is 'path open?';

create function pg_catalog.isparallel(line, line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isparallel(line, line) is 'parallel';

create function pg_catalog.isparallel(lseg, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isparallel(lseg, lseg) is 'parallel';

create function pg_catalog.isperp(line, line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isperp(line, line) is 'perpendicular';

create function pg_catalog.isperp(lseg, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isperp(lseg, lseg) is 'perpendicular';

create function pg_catalog.isvertical(line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical(line) is 'vertical';

create function pg_catalog.isvertical(lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical(lseg) is 'vertical';

create function pg_catalog.isvertical(point, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical(point, point) is 'vertically aligned';

create function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for JOHAB to UTF8';

create function pg_catalog.json_agg_finalfn(internal) returns json
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_agg_finalfn(internal) is 'json aggregate final function';

create function pg_catalog.json_agg_transfn(internal, anyelement) returns internal
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_agg_transfn(internal, anyelement) is 'json aggregate transition function';

create function pg_catalog.json_array_element(from_json json, element_index integer) returns json
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_element(json, integer) is 'implementation of -> operator';

create function pg_catalog.json_array_element_text(from_json json, element_index integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_element_text(json, integer) is 'implementation of ->> operator';

create function pg_catalog.json_array_elements(from_json json, out value json) returns setof setof json
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_array_elements(json, out json) is 'key value pairs of a json object';

create function pg_catalog.json_array_elements_text(from_json json, out value text) returns setof setof text
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_array_elements_text(json, out text) is 'elements of json array';

create function pg_catalog.json_array_length(json) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_length(json) is 'length of json array';

create function pg_catalog.json_build_array("any") returns json
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_array("any") is 'build a json array from any inputs';

create function pg_catalog.json_build_array() returns json
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_array() is 'build an empty json array';

create function pg_catalog.json_build_object("any") returns json
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_object("any") is 'build a json object from pairwise key/value inputs';

create function pg_catalog.json_build_object() returns json
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_object() is 'build an empty json object';

create function pg_catalog.json_each(from_json json, out key text, out value json) returns setof setof record
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_each(json, out text, out json) is 'key value pairs of a json object';

create function pg_catalog.json_each_text(from_json json, out key text, out value text) returns setof setof record
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_each_text(json, out text, out text) is 'key value pairs of a json object';

create function pg_catalog.json_extract_path(from_json json, path_elems text[]) returns json
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_extract_path(json, text[]) is 'get value from json with path elements';

create function pg_catalog.json_extract_path_text(from_json json, path_elems text[]) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_extract_path_text(json, text[]) is 'get value from json as text with path elements';

create function pg_catalog.json_in(cstring) returns json
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_in(cstring) is 'I/O';

create function pg_catalog.json_object(text[]) returns json
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object(text[]) is 'map text array of key value pairs to json object';

create function pg_catalog.json_object(text[], text[]) returns json
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object(text[], text[]) is 'map text arrays of keys and values to json object';

create function pg_catalog.json_object_agg_finalfn(internal) returns json
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_agg_finalfn(internal) is 'json object aggregate final function';

create function pg_catalog.json_object_agg_transfn(internal, "any", "any") returns internal
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_agg_transfn(internal, "any", "any") is 'json object aggregate transition function';

create function pg_catalog.json_object_field(from_json json, field_name text) returns json
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_field(json, text) is 'implementation of -> operator';

create function pg_catalog.json_object_field_text(from_json json, field_name text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_field_text(json, text) is 'implementation of ->> operator';

create function pg_catalog.json_object_keys(json) returns setof setof text
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_object_keys(json) is 'get json object keys';

create function pg_catalog.json_out(json) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_out(json) is 'I/O';

create function pg_catalog.json_populate_record(base anyelement, from_json json, use_json_as_text boolean default false) returns anyelement
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_populate_record(anyelement, json, boolean) is 'get record fields from a json object';

create function pg_catalog.json_populate_recordset(base anyelement, from_json json, use_json_as_text boolean default false) returns setof setof anyelement
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_populate_recordset(anyelement, json, boolean) is 'get set of records with fields from a json array of objects';

create function pg_catalog.json_recv(internal) returns json
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_recv(internal) is 'I/O';

create function pg_catalog.json_send(json) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_send(json) is 'I/O';

create function pg_catalog.json_strip_nulls(json) returns json
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_strip_nulls(json) is 'remove object fields with null values from json';

create function pg_catalog.json_to_record(json) returns record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_record(json) is 'get record fields from a json object';

create function pg_catalog.json_to_recordset(json) returns setof setof record
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_to_recordset(json) is 'get set of records with fields from a json array of objects';

create function pg_catalog.json_to_tsvector(json, jsonb) returns tsvector
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_tsvector(json, jsonb) is 'transform specified values from json to tsvector';

create function pg_catalog.json_to_tsvector(regconfig, json, jsonb) returns tsvector
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_tsvector(regconfig, json, jsonb) is 'transform specified values from json to tsvector';

create function pg_catalog.json_typeof(json) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_typeof(json) is 'get the type of a json value';

create function pg_catalog.jsonb_agg_finalfn(internal) returns jsonb
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_agg_finalfn(internal) is 'jsonb aggregate final function';

create function pg_catalog.jsonb_agg_transfn(internal, anyelement) returns internal
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_agg_transfn(internal, anyelement) is 'jsonb aggregate transition function';

create function pg_catalog.jsonb_array_element(from_json jsonb, element_index integer) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_element(jsonb, integer) is 'implementation of -> operator';

create function pg_catalog.jsonb_array_element_text(from_json jsonb, element_index integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_element_text(jsonb, integer) is 'implementation of ->> operator';

create function pg_catalog.jsonb_array_elements(from_json jsonb, out value jsonb) returns setof setof jsonb
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_array_elements(jsonb, out jsonb) is 'elements of a jsonb array';

create function pg_catalog.jsonb_array_elements_text(from_json jsonb, out value text) returns setof setof text
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_array_elements_text(jsonb, out text) is 'elements of jsonb array';

create function pg_catalog.jsonb_array_length(jsonb) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_length(jsonb) is 'length of jsonb array';

create function pg_catalog.jsonb_build_array("any") returns jsonb
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_array("any") is 'build a jsonb array from any inputs';

create function pg_catalog.jsonb_build_array() returns jsonb
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_array() is 'build an empty jsonb array';

create function pg_catalog.jsonb_build_object("any") returns jsonb
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_object("any") is 'build a jsonb object from pairwise key/value inputs';

create function pg_catalog.jsonb_build_object() returns jsonb
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_object() is 'build an empty jsonb object';

create function pg_catalog.jsonb_cmp(jsonb, jsonb) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_cmp(jsonb, jsonb) is 'less-equal-greater';

create function pg_catalog.jsonb_concat(jsonb, jsonb) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_concat(jsonb, jsonb) is 'implementation of || operator';

create function pg_catalog.jsonb_contained(jsonb, jsonb) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_contained(jsonb, jsonb) is 'implementation of <@ operator';

create function pg_catalog.jsonb_contains(jsonb, jsonb) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_contains(jsonb, jsonb) is 'implementation of @> operator';

create function pg_catalog.jsonb_delete(jsonb, integer) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete(jsonb, integer) is 'implementation of - operator';

create function pg_catalog.jsonb_delete(jsonb, text) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete(jsonb, text) is 'implementation of - operator';

create function pg_catalog.jsonb_delete(from_json jsonb, path_elems text[]) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete(jsonb, text[]) is 'implementation of - operator';

create function pg_catalog.jsonb_delete_path(jsonb, text[]) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete_path(jsonb, text[]) is 'implementation of #- operator';

create function pg_catalog.jsonb_each(from_json jsonb, out key text, out value jsonb) returns setof setof record
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_each(jsonb, out text, out jsonb) is 'key value pairs of a jsonb object';

create function pg_catalog.jsonb_each_text(from_json jsonb, out key text, out value text) returns setof setof record
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_each_text(jsonb, out text, out text) is 'key value pairs of a jsonb object';

create function pg_catalog.jsonb_eq(jsonb, jsonb) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_eq(jsonb, jsonb) is 'implementation of = operator';

create function pg_catalog.jsonb_exists(jsonb, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists(jsonb, text) is 'implementation of ? operator';

create function pg_catalog.jsonb_exists_all(jsonb, text[]) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists_all(jsonb, text[]) is 'implementation of ?& operator';

create function pg_catalog.jsonb_exists_any(jsonb, text[]) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists_any(jsonb, text[]) is 'implementation of ?| operator';

create function pg_catalog.jsonb_extract_path(from_json jsonb, path_elems text[]) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_extract_path(jsonb, text[]) is 'get value from jsonb with path elements';

create function pg_catalog.jsonb_extract_path_text(from_json jsonb, path_elems text[]) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_extract_path_text(jsonb, text[]) is 'get value from jsonb as text with path elements';

create function pg_catalog.jsonb_ge(jsonb, jsonb) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_ge(jsonb, jsonb) is 'implementation of >= operator';

create function pg_catalog.jsonb_gt(jsonb, jsonb) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_gt(jsonb, jsonb) is 'implementation of > operator';

create function pg_catalog.jsonb_hash(jsonb) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_hash(jsonb) is 'hash';

create function pg_catalog.jsonb_hash_extended(jsonb, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_hash_extended(jsonb, bigint) is 'hash';

create function pg_catalog.jsonb_in(cstring) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_in(cstring) is 'I/O';

create function pg_catalog.jsonb_insert(jsonb_in jsonb, path text[], replacement jsonb, insert_after boolean default false) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_insert(jsonb, text[], jsonb, boolean) is 'Insert value into a jsonb';

create function pg_catalog.jsonb_le(jsonb, jsonb) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_le(jsonb, jsonb) is 'implementation of <= operator';

create function pg_catalog.jsonb_lt(jsonb, jsonb) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_lt(jsonb, jsonb) is 'implementation of < operator';

create function pg_catalog.jsonb_ne(jsonb, jsonb) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_ne(jsonb, jsonb) is 'implementation of <> operator';

create function pg_catalog.jsonb_object(text[]) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object(text[]) is 'map text array of key value pairs to jsonb object';

create function pg_catalog.jsonb_object(text[], text[]) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object(text[], text[]) is 'map text array of key value pairs to jsonb object';

create function pg_catalog.jsonb_object_agg_finalfn(internal) returns jsonb
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_agg_finalfn(internal) is 'jsonb object aggregate final function';

create function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any") returns internal
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any") is 'jsonb object aggregate transition function';

create function pg_catalog.jsonb_object_field(from_json jsonb, field_name text) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_field(jsonb, text) is 'implementation of -> operator';

create function pg_catalog.jsonb_object_field_text(from_json jsonb, field_name text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_field_text(jsonb, text) is 'implementation of ->> operator';

create function pg_catalog.jsonb_object_keys(jsonb) returns setof setof text
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_object_keys(jsonb) is 'get jsonb object keys';

create function pg_catalog.jsonb_out(jsonb) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_out(jsonb) is 'I/O';

create function pg_catalog.jsonb_path_exists(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_exists(jsonb, jsonpath, jsonb, boolean) is 'jsonpath exists test';

create function pg_catalog.jsonb_path_exists_opr(jsonb, jsonpath) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_exists_opr(jsonb, jsonpath) is 'implementation of @? operator';

create function pg_catalog.jsonb_path_exists_tz(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_exists_tz(jsonb, jsonpath, jsonb, boolean) is 'jsonpath exists test with timezone';

create function pg_catalog.jsonb_path_match(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_match(jsonb, jsonpath, jsonb, boolean) is 'jsonpath match';

create function pg_catalog.jsonb_path_match_opr(jsonb, jsonpath) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_match_opr(jsonb, jsonpath) is 'implementation of @@ operator';

create function pg_catalog.jsonb_path_match_tz(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_match_tz(jsonb, jsonpath, jsonb, boolean) is 'jsonpath match with timezone';

create function pg_catalog.jsonb_path_query(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns setof setof jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_path_query(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query';

create function pg_catalog.jsonb_path_query_array(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_array(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query wrapped into array';

create function pg_catalog.jsonb_path_query_array_tz(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns jsonb
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_array_tz(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query wrapped into array with timezone';

create function pg_catalog.jsonb_path_query_first(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_first(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query first item';

create function pg_catalog.jsonb_path_query_first_tz(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns jsonb
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_first_tz(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query first item with timezone';

create function pg_catalog.jsonb_path_query_tz(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns setof setof jsonb
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_path_query_tz(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query with timezone';

create function pg_catalog.jsonb_populate_record(anyelement, jsonb) returns anyelement
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_populate_record(anyelement, jsonb) is 'get record fields from a jsonb object';

create function pg_catalog.jsonb_populate_recordset(anyelement, jsonb) returns setof setof anyelement
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_populate_recordset(anyelement, jsonb) is 'get set of records with fields from a jsonb array of objects';

create function pg_catalog.jsonb_pretty(jsonb) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_pretty(jsonb) is 'Indented text from jsonb';

create function pg_catalog.jsonb_recv(internal) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_recv(internal) is 'I/O';

create function pg_catalog.jsonb_send(jsonb) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_send(jsonb) is 'I/O';

create function pg_catalog.jsonb_set(jsonb_in jsonb, path text[], replacement jsonb, create_if_missing boolean default true) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_set(jsonb, text[], jsonb, boolean) is 'Set part of a jsonb';

create function pg_catalog.jsonb_set_lax(jsonb_in jsonb, path text[], replacement jsonb, create_if_missing boolean default true, null_value_treatment text default 'use_json_null'::text) returns jsonb
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_set_lax(jsonb, text[], jsonb, boolean, text) is 'Set part of a jsonb, handle NULL value';

create function pg_catalog.jsonb_strip_nulls(jsonb) returns jsonb
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_strip_nulls(jsonb) is 'remove object fields with null values from jsonb';

create function pg_catalog.jsonb_to_record(jsonb) returns record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_record(jsonb) is 'get record fields from a jsonb object';

create function pg_catalog.jsonb_to_recordset(jsonb) returns setof setof record
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_to_recordset(jsonb) is 'get set of records with fields from a jsonb array of objects';

create function pg_catalog.jsonb_to_tsvector(jsonb, jsonb) returns tsvector
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_tsvector(jsonb, jsonb) is 'transform specified values from jsonb to tsvector';

create function pg_catalog.jsonb_to_tsvector(regconfig, jsonb, jsonb) returns tsvector
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_tsvector(regconfig, jsonb, jsonb) is 'transform specified values from jsonb to tsvector';

create function pg_catalog.jsonb_typeof(jsonb) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_typeof(jsonb) is 'get the type of a jsonb value';

create function pg_catalog.jsonpath_in(cstring) returns jsonpath
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_in(cstring) is 'I/O';

create function pg_catalog.jsonpath_out(jsonpath) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_out(jsonpath) is 'I/O';

create function pg_catalog.jsonpath_recv(internal) returns jsonpath
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_recv(internal) is 'I/O';

create function pg_catalog.jsonpath_send(jsonpath) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_send(jsonpath) is 'I/O';

create function pg_catalog.justify_days(interval) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_days(interval) is 'promote groups of 30 days to numbers of months';

create function pg_catalog.justify_hours(interval) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_hours(interval) is 'promote groups of 24 hours to numbers of days';

create function pg_catalog.justify_interval(interval) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_interval(interval) is 'promote groups of 24 hours to numbers of days and promote groups of 30 days to numbers of months';

create function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8R to ISO-8859-5';

create function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8R to MULE_INTERNAL';

create function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8R to UTF8';

create function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8R to WIN1251';

create function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8R to WIN866';

create function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8U to UTF8';

create function pg_catalog.lag(anyelement) returns anyelement
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag(anyelement) is 'fetch the preceding row value';

create function pg_catalog.lag(anyelement, integer) returns anyelement
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag(anyelement, integer) is 'fetch the Nth preceding row value';

create function pg_catalog.lag(anyelement, integer, anyelement) returns anyelement
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag(anyelement, integer, anyelement) is 'fetch the Nth preceding row value with default';

create function pg_catalog.language_handler_in(cstring) returns language_handler
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.language_handler_in(cstring) is 'I/O';

create function pg_catalog.language_handler_out(language_handler) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.language_handler_out(language_handler) is 'I/O';

create function pg_catalog.last_value(anyelement) returns anyelement
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.last_value(anyelement) is 'fetch the last row value';

create function pg_catalog.lastval() returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lastval() is 'current value from last used sequence';

create function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN1 to MULE_INTERNAL';

create function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN2 to MULE_INTERNAL';

create function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN2 to WIN1250';

create function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN3 to MULE_INTERNAL';

create function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN4 to MULE_INTERNAL';

create function pg_catalog.lcm(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lcm(bigint, bigint) is 'least common multiple';

create function pg_catalog.lcm(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lcm(integer, integer) is 'least common multiple';

create function pg_catalog.lcm(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lcm(numeric, numeric) is 'least common multiple';

create function pg_catalog.lead(anyelement) returns anyelement
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead(anyelement) is 'fetch the following row value';

create function pg_catalog.lead(anyelement, integer) returns anyelement
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead(anyelement, integer) is 'fetch the Nth following row value';

create function pg_catalog.lead(anyelement, integer, anyelement) returns anyelement
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead(anyelement, integer, anyelement) is 'fetch the Nth following row value with default';

create function pg_catalog."left"(text, integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."left"(text, integer) is 'extract the first n characters';

create function pg_catalog.length(bit) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(bit) is 'bitstring length';

create function pg_catalog.length(bytea) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(bytea) is 'octet length';

create function pg_catalog.length(bytea, name) returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(bytea, name) is 'length of string in specified encoding';

create function pg_catalog.length(char) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(char) is 'character length';

create function pg_catalog.length(lseg) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(lseg) is 'distance between endpoints';

create function pg_catalog.length(path) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(path) is 'sum of path segments';

create function pg_catalog.length(text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(text) is 'length';

create function pg_catalog.length(tsvector) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(tsvector) is 'number of lexemes';

create function pg_catalog."like"(bytea, bytea) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"(bytea, bytea) is 'matches LIKE expression';

create function pg_catalog."like"(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"(name, text) is 'matches LIKE expression';

create function pg_catalog."like"(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"(text, text) is 'matches LIKE expression';

create function pg_catalog.like_escape(bytea, bytea) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.like_escape(bytea, bytea) is 'convert LIKE pattern to use backslash escapes';

create function pg_catalog.like_escape(text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.like_escape(text, text) is 'convert LIKE pattern to use backslash escapes';

create function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of LIKE';

create function pg_catalog.likesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.likesel(internal, oid, internal, integer) is 'restriction selectivity of LIKE';

create function pg_catalog.line(point, point) returns line
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line(point, point) is 'construct line from points';

create function pg_catalog.line_distance(line, line) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_distance(line, line) is 'implementation of <-> operator';

create function pg_catalog.line_eq(line, line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_eq(line, line) is 'implementation of = operator';

create function pg_catalog.line_horizontal(line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_horizontal(line) is 'implementation of ?- operator';

create function pg_catalog.line_in(cstring) returns line
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_in(cstring) is 'I/O';

create function pg_catalog.line_interpt(line, line) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_interpt(line, line) is 'implementation of # operator';

create function pg_catalog.line_intersect(line, line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_intersect(line, line) is 'implementation of ?# operator';

create function pg_catalog.line_out(line) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_out(line) is 'I/O';

create function pg_catalog.line_parallel(line, line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_parallel(line, line) is 'implementation of ?|| operator';

create function pg_catalog.line_perp(line, line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_perp(line, line) is 'implementation of ?-| operator';

create function pg_catalog.line_recv(internal) returns line
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_recv(internal) is 'I/O';

create function pg_catalog.line_send(line) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_send(line) is 'I/O';

create function pg_catalog.line_vertical(line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_vertical(line) is 'implementation of ?| operator';

create function pg_catalog.ln(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ln(double precision) is 'natural logarithm';

create function pg_catalog.ln(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ln(numeric) is 'natural logarithm';

create function pg_catalog.lo_close(integer) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_close(integer) is 'large object close';

create function pg_catalog.lo_creat(integer) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_creat(integer) is 'large object create';

create function pg_catalog.lo_create(oid) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_create(oid) is 'large object create';

create function pg_catalog.lo_export(oid, text) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_export(oid, text) is 'large object export';

create function pg_catalog.lo_from_bytea(oid, bytea) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_from_bytea(oid, bytea) is 'create new large object with given content';

create function pg_catalog.lo_get(oid) returns bytea
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_get(oid) is 'read entire large object';

create function pg_catalog.lo_get(oid, bigint, integer) returns bytea
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_get(oid, bigint, integer) is 'read large object from offset for length';

create function pg_catalog.lo_import(text) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_import(text) is 'large object import';

create function pg_catalog.lo_import(text, oid) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_import(text, oid) is 'large object import';

create function pg_catalog.lo_lseek(integer, integer, integer) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_lseek(integer, integer, integer) is 'large object seek';

create function pg_catalog.lo_lseek64(integer, bigint, integer) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_lseek64(integer, bigint, integer) is 'large object seek (64 bit)';

create function pg_catalog.lo_open(oid, integer) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_open(oid, integer) is 'large object open';

create function pg_catalog.lo_put(oid, bigint, bytea) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_put(oid, bigint, bytea) is 'write data at offset';

create function pg_catalog.lo_tell(integer) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_tell(integer) is 'large object position';

create function pg_catalog.lo_tell64(integer) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_tell64(integer) is 'large object position (64 bit)';

create function pg_catalog.lo_truncate(integer, integer) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_truncate(integer, integer) is 'truncate large object';

create function pg_catalog.lo_truncate64(integer, bigint) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_truncate64(integer, bigint) is 'truncate large object (64 bit)';

create function pg_catalog.lo_unlink(oid) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_unlink(oid) is 'large object unlink (delete)';

create function pg_catalog.log(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log(double precision) is 'base 10 logarithm';

create function pg_catalog.log(numeric) returns numeric
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log(numeric) is 'base 10 logarithm';

create function pg_catalog.log(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log(numeric, numeric) is 'logarithm base m of n';

create function pg_catalog.log10(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log10(double precision) is 'base 10 logarithm';

create function pg_catalog.log10(numeric) returns numeric
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log10(numeric) is 'base 10 logarithm';

create function pg_catalog.loread(integer, integer) returns bytea
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.loread(integer, integer) is 'large object read';

create function pg_catalog.lower(anyrange) returns anyelement
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower(anyrange) is 'lower bound of range';

create function pg_catalog.lower(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower(text) is 'lowercase';

create function pg_catalog.lower_inc(anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inc(anyrange) is 'is the range''s lower bound inclusive?';

create function pg_catalog.lower_inf(anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inf(anyrange) is 'is the range''s lower bound infinite?';

create function pg_catalog.lowrite(integer, bytea) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lowrite(integer, bytea) is 'large object write';

create function pg_catalog.lpad(text, integer) returns text
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lpad(text, integer) is 'left-pad string to length';

create function pg_catalog.lpad(text, integer, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lpad(text, integer, text) is 'left-pad string to length';

create function pg_catalog.lseg(box) returns lseg
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg(box) is 'diagonal of';

create function pg_catalog.lseg(point, point) returns lseg
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg(point, point) is 'convert points to line segment';

create function pg_catalog.lseg_center(lseg) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_center(lseg) is 'implementation of @@ operator';

create function pg_catalog.lseg_distance(lseg, lseg) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_distance(lseg, lseg) is 'implementation of <-> operator';

create function pg_catalog.lseg_eq(lseg, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_eq(lseg, lseg) is 'implementation of = operator';

create function pg_catalog.lseg_ge(lseg, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_ge(lseg, lseg) is 'implementation of >= operator';

create function pg_catalog.lseg_gt(lseg, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_gt(lseg, lseg) is 'implementation of > operator';

create function pg_catalog.lseg_horizontal(lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_horizontal(lseg) is 'implementation of ?- operator';

create function pg_catalog.lseg_in(cstring) returns lseg
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_in(cstring) is 'I/O';

create function pg_catalog.lseg_interpt(lseg, lseg) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_interpt(lseg, lseg) is 'implementation of # operator';

create function pg_catalog.lseg_intersect(lseg, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_intersect(lseg, lseg) is 'implementation of ?# operator';

create function pg_catalog.lseg_le(lseg, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_le(lseg, lseg) is 'implementation of <= operator';

create function pg_catalog.lseg_length(lseg) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_length(lseg) is 'implementation of @-@ operator';

create function pg_catalog.lseg_lt(lseg, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_lt(lseg, lseg) is 'implementation of < operator';

create function pg_catalog.lseg_ne(lseg, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_ne(lseg, lseg) is 'implementation of <> operator';

create function pg_catalog.lseg_out(lseg) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_out(lseg) is 'I/O';

create function pg_catalog.lseg_parallel(lseg, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_parallel(lseg, lseg) is 'implementation of ?|| operator';

create function pg_catalog.lseg_perp(lseg, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_perp(lseg, lseg) is 'implementation of ?-| operator';

create function pg_catalog.lseg_recv(internal) returns lseg
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_recv(internal) is 'I/O';

create function pg_catalog.lseg_send(lseg) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_send(lseg) is 'I/O';

create function pg_catalog.lseg_vertical(lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_vertical(lseg) is 'implementation of ?| operator';

create function pg_catalog.ltrim(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ltrim(text) is 'trim spaces from left end of string';

create function pg_catalog.ltrim(text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ltrim(text, text) is 'trim selected characters from left end of string';

create function pg_catalog.macaddr(macaddr8) returns macaddr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr(macaddr8) is 'convert macaddr8 to macaddr';

create function pg_catalog.macaddr8(macaddr) returns macaddr8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8(macaddr) is 'convert macaddr to macaddr8';

create function pg_catalog.macaddr8_and(macaddr8, macaddr8) returns macaddr8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_and(macaddr8, macaddr8) is 'implementation of & operator';

create function pg_catalog.macaddr8_cmp(macaddr8, macaddr8) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_cmp(macaddr8, macaddr8) is 'less-equal-greater';

create function pg_catalog.macaddr8_eq(macaddr8, macaddr8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_eq(macaddr8, macaddr8) is 'implementation of = operator';

create function pg_catalog.macaddr8_ge(macaddr8, macaddr8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_ge(macaddr8, macaddr8) is 'implementation of >= operator';

create function pg_catalog.macaddr8_gt(macaddr8, macaddr8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_gt(macaddr8, macaddr8) is 'implementation of > operator';

create function pg_catalog.macaddr8_in(cstring) returns macaddr8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_in(cstring) is 'I/O';

create function pg_catalog.macaddr8_le(macaddr8, macaddr8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_le(macaddr8, macaddr8) is 'implementation of <= operator';

create function pg_catalog.macaddr8_lt(macaddr8, macaddr8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_lt(macaddr8, macaddr8) is 'implementation of < operator';

create function pg_catalog.macaddr8_ne(macaddr8, macaddr8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_ne(macaddr8, macaddr8) is 'implementation of <> operator';

create function pg_catalog.macaddr8_not(macaddr8) returns macaddr8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_not(macaddr8) is 'implementation of ~ operator';

create function pg_catalog.macaddr8_or(macaddr8, macaddr8) returns macaddr8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_or(macaddr8, macaddr8) is 'implementation of | operator';

create function pg_catalog.macaddr8_out(macaddr8) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_out(macaddr8) is 'I/O';

create function pg_catalog.macaddr8_recv(internal) returns macaddr8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_recv(internal) is 'I/O';

create function pg_catalog.macaddr8_send(macaddr8) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_send(macaddr8) is 'I/O';

create function pg_catalog.macaddr8_set7bit(macaddr8) returns macaddr8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_set7bit(macaddr8) is 'set 7th bit in macaddr8';

create function pg_catalog.macaddr_and(macaddr, macaddr) returns macaddr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_and(macaddr, macaddr) is 'implementation of & operator';

create function pg_catalog.macaddr_cmp(macaddr, macaddr) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_cmp(macaddr, macaddr) is 'less-equal-greater';

create function pg_catalog.macaddr_eq(macaddr, macaddr) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_eq(macaddr, macaddr) is 'implementation of = operator';

create function pg_catalog.macaddr_ge(macaddr, macaddr) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_ge(macaddr, macaddr) is 'implementation of >= operator';

create function pg_catalog.macaddr_gt(macaddr, macaddr) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_gt(macaddr, macaddr) is 'implementation of > operator';

create function pg_catalog.macaddr_in(cstring) returns macaddr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_in(cstring) is 'I/O';

create function pg_catalog.macaddr_le(macaddr, macaddr) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_le(macaddr, macaddr) is 'implementation of <= operator';

create function pg_catalog.macaddr_lt(macaddr, macaddr) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_lt(macaddr, macaddr) is 'implementation of < operator';

create function pg_catalog.macaddr_ne(macaddr, macaddr) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_ne(macaddr, macaddr) is 'implementation of <> operator';

create function pg_catalog.macaddr_not(macaddr) returns macaddr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_not(macaddr) is 'implementation of ~ operator';

create function pg_catalog.macaddr_or(macaddr, macaddr) returns macaddr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_or(macaddr, macaddr) is 'implementation of | operator';

create function pg_catalog.macaddr_out(macaddr) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_out(macaddr) is 'I/O';

create function pg_catalog.macaddr_recv(internal) returns macaddr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_recv(internal) is 'I/O';

create function pg_catalog.macaddr_send(macaddr) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_send(macaddr) is 'I/O';

create function pg_catalog.macaddr_sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_sortsupport(internal) is 'sort support';

create function pg_catalog.make_date(year integer, month integer, day integer) returns date
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_date(integer, integer, integer) is 'construct date';

create function pg_catalog.make_interval(years integer default 0, months integer default 0, weeks integer default 0, days integer default 0, hours integer default 0, mins integer default 0, secs double precision default 0.0) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_interval(integer, integer, integer, integer, integer, integer, double precision) is 'construct interval';

create function pg_catalog.make_time(hour integer, min integer, sec double precision) returns time
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_time(integer, integer, double precision) is 'construct time';

create function pg_catalog.make_timestamp(year integer, month integer, mday integer, hour integer, min integer, sec double precision) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamp(integer, integer, integer, integer, integer, double precision) is 'construct timestamp';

create function pg_catalog.make_timestamptz(year integer, month integer, mday integer, hour integer, min integer, sec double precision) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision) is 'construct timestamp with time zone';

create function pg_catalog.make_timestamptz(year integer, month integer, mday integer, hour integer, min integer, sec double precision, timezone text) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision, text) is 'construct timestamp with time zone';

create function pg_catalog.makeaclitem(oid, oid, text, boolean) returns aclitem
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.makeaclitem(oid, oid, text, boolean) is 'make ACL item';

create function pg_catalog.masklen(inet) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.masklen(inet) is 'netmask length';

create function pg_catalog.matchingjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.matchingjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for generic matching operators';

create function pg_catalog.matchingsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.matchingsel(internal, oid, internal, integer) is 'restriction selectivity for generic matching operators';

create function pg_catalog.md5(bytea) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.md5(bytea) is 'MD5 hash';

create function pg_catalog.md5(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.md5(text) is 'MD5 hash';

create function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to BIG5';

create function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to EUC_CN';

create function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to EUC_JP';

create function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to EUC_KR';

create function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to EUC_TW';

create function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to ISO-8859-5';

create function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to KOI8R';

create function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to LATIN1';

create function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to LATIN2';

create function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to LATIN3';

create function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to LATIN4';

create function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to SJIS';

create function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to WIN1250';

create function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to WIN1251';

create function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to WIN866';

create function pg_catalog.min_scale(numeric) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.min_scale(numeric) is 'minimum scale needed to represent the value';

create function pg_catalog.mod(bigint, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(bigint, bigint) is 'modulus';

create function pg_catalog.mod(integer, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(integer, integer) is 'modulus';

create function pg_catalog.mod(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(numeric, numeric) is 'modulus';

create function pg_catalog.mod(smallint, smallint) returns smallint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(smallint, smallint) is 'modulus';

create function pg_catalog.mode_final(internal, anyelement) returns anyelement
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mode_final(internal, anyelement) is 'aggregate final function';

create function pg_catalog.money(bigint) returns money
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(bigint) is 'convert int8 to money';

create function pg_catalog.money(integer) returns money
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(integer) is 'convert int4 to money';

create function pg_catalog.money(numeric) returns money
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(numeric) is 'convert numeric to money';

create function pg_catalog.mul_d_interval(double precision, interval) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mul_d_interval(double precision, interval) is 'implementation of * operator';

create function pg_catalog.mxid_age(xid) returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mxid_age(xid) is 'age of a multi-transaction ID, in multi-transactions before current multi-transaction';

create function pg_catalog.name(char) returns name
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name(char) is 'convert char(n) to name';

create function pg_catalog.name(text) returns name
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name(text) is 'convert text to name';

create function pg_catalog.name(varchar) returns name
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name(varchar) is 'convert varchar to name';

create function pg_catalog.nameconcatoid(name, oid) returns name
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameconcatoid(name, oid) is 'concatenate name and oid';

create function pg_catalog.nameeq(name, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameeq(name, name) is 'implementation of = operator';

create function pg_catalog.nameeqtext(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameeqtext(name, text) is 'implementation of = operator';

create function pg_catalog.namege(name, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namege(name, name) is 'implementation of >= operator';

create function pg_catalog.namegetext(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegetext(name, text) is 'implementation of >= operator';

create function pg_catalog.namegt(name, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegt(name, name) is 'implementation of > operator';

create function pg_catalog.namegttext(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegttext(name, text) is 'implementation of > operator';

create function pg_catalog.nameiclike(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameiclike(name, text) is 'implementation of ~~* operator';

create function pg_catalog.nameicnlike(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicnlike(name, text) is 'implementation of !~~* operator';

create function pg_catalog.nameicregexeq(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicregexeq(name, text) is 'implementation of ~* operator';

create function pg_catalog.nameicregexne(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicregexne(name, text) is 'implementation of !~* operator';

create function pg_catalog.namein(cstring) returns name
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namein(cstring) is 'I/O';

create function pg_catalog.namele(name, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namele(name, name) is 'implementation of <= operator';

create function pg_catalog.nameletext(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameletext(name, text) is 'implementation of <= operator';

create function pg_catalog.namelike(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelike(name, text) is 'implementation of ~~ operator';

create function pg_catalog.namelt(name, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelt(name, name) is 'implementation of < operator';

create function pg_catalog.namelttext(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelttext(name, text) is 'implementation of < operator';

create function pg_catalog.namene(name, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namene(name, name) is 'implementation of <> operator';

create function pg_catalog.namenetext(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namenetext(name, text) is 'implementation of <> operator';

create function pg_catalog.namenlike(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namenlike(name, text) is 'implementation of !~~ operator';

create function pg_catalog.nameout(name) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameout(name) is 'I/O';

create function pg_catalog.namerecv(internal) returns name
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namerecv(internal) is 'I/O';

create function pg_catalog.nameregexeq(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameregexeq(name, text) is 'implementation of ~ operator';

create function pg_catalog.nameregexne(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameregexne(name, text) is 'implementation of !~ operator';

create function pg_catalog.namesend(name) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namesend(name) is 'I/O';

create function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of <> and related operators';

create function pg_catalog.neqsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.neqsel(internal, oid, internal, integer) is 'restriction selectivity of <> and related operators';

create function pg_catalog.netmask(inet) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.netmask(inet) is 'netmask of address';

create function pg_catalog.network(inet) returns cidr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network(inet) is 'network part of address';

create function pg_catalog.network_cmp(inet, inet) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_cmp(inet, inet) is 'less-equal-greater';

create function pg_catalog.network_eq(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_eq(inet, inet) is 'implementation of = operator';

create function pg_catalog.network_ge(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_ge(inet, inet) is 'implementation of >= operator';

create function pg_catalog.network_gt(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_gt(inet, inet) is 'implementation of > operator';

create function pg_catalog.network_larger(inet, inet) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_larger(inet, inet) is 'larger of two';

create function pg_catalog.network_le(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_le(inet, inet) is 'implementation of <= operator';

create function pg_catalog.network_lt(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_lt(inet, inet) is 'implementation of < operator';

create function pg_catalog.network_ne(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_ne(inet, inet) is 'implementation of <> operator';

create function pg_catalog.network_overlap(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_overlap(inet, inet) is 'implementation of && operator';

create function pg_catalog.network_smaller(inet, inet) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_smaller(inet, inet) is 'smaller of two';

create function pg_catalog.network_sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_sortsupport(internal) is 'sort support';

create function pg_catalog.network_sub(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_sub(inet, inet) is 'implementation of << operator';

create function pg_catalog.network_subeq(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_subeq(inet, inet) is 'implementation of <<= operator';

create function pg_catalog.network_subset_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_subset_support(internal) is 'planner support for network_sub/superset';

create function pg_catalog.network_sup(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_sup(inet, inet) is 'implementation of >> operator';

create function pg_catalog.network_supeq(inet, inet) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_supeq(inet, inet) is 'implementation of >>= operator';

create function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for network operators';

create function pg_catalog.networksel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.networksel(internal, oid, internal, integer) is 'restriction selectivity for network operators';

create function pg_catalog.nextval(regclass) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nextval(regclass) is 'sequence next value';

create function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of NOT LIKE';

create function pg_catalog.nlikesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nlikesel(internal, oid, internal, integer) is 'restriction selectivity of NOT LIKE';

create function pg_catalog.normalize(text, text default 'NFC'::text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.normalize(text, text) is 'Unicode normalization';

create function pg_catalog.notlike(bytea, bytea) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike(bytea, bytea) is 'does not match LIKE expression';

create function pg_catalog.notlike(name, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike(name, text) is 'does not match LIKE expression';

create function pg_catalog.notlike(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike(text, text) is 'does not match LIKE expression';

create function pg_catalog.now() returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.now() is 'current transaction time';

create function pg_catalog.npoints(path) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.npoints(path) is 'number of points';

create function pg_catalog.npoints(polygon) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.npoints(polygon) is 'number of points';

create function pg_catalog.nth_value(anyelement, integer) returns anyelement
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nth_value(anyelement, integer) is 'fetch the Nth row value';

create function pg_catalog.ntile(integer) returns integer
    immutable
    window
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ntile(integer) is 'split rows into N groups';

create function pg_catalog.num_nonnulls("any") returns integer
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.num_nonnulls("any") is 'count the number of non-NULL arguments';

create function pg_catalog.num_nulls("any") returns integer
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.num_nulls("any") is 'count the number of NULL arguments';

create function pg_catalog.numeric(bigint) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(bigint) is 'convert int8 to numeric';

create function pg_catalog.numeric(double precision) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(double precision) is 'convert float8 to numeric';

create function pg_catalog.numeric(integer) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(integer) is 'convert int4 to numeric';

create function pg_catalog.numeric(jsonb) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(jsonb) is 'convert jsonb to numeric';

create function pg_catalog.numeric(money) returns numeric
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(money) is 'convert money to numeric';

create function pg_catalog.numeric(numeric, integer) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(numeric, integer) is 'adjust numeric to typmod precision/scale';

create function pg_catalog.numeric(real) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(real) is 'convert float4 to numeric';

create function pg_catalog.numeric(smallint) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(smallint) is 'convert int2 to numeric';

create function pg_catalog.numeric_abs(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_abs(numeric) is 'implementation of @ operator';

create function pg_catalog.numeric_accum(internal, numeric) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_accum(internal, numeric) is 'aggregate transition function';

create function pg_catalog.numeric_accum_inv(internal, numeric) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_accum_inv(internal, numeric) is 'aggregate transition function';

create function pg_catalog.numeric_add(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_add(numeric, numeric) is 'implementation of + operator';

create function pg_catalog.numeric_avg(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg(internal) is 'aggregate final function';

create function pg_catalog.numeric_avg_accum(internal, numeric) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_accum(internal, numeric) is 'aggregate transition function';

create function pg_catalog.numeric_avg_combine(internal, internal) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_combine(internal, internal) is 'aggregate combine function';

create function pg_catalog.numeric_avg_deserialize(bytea, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_deserialize(bytea, internal) is 'aggregate deserial function';

create function pg_catalog.numeric_avg_serialize(internal) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_serialize(internal) is 'aggregate serial function';

create function pg_catalog.numeric_cmp(numeric, numeric) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_cmp(numeric, numeric) is 'less-equal-greater';

create function pg_catalog.numeric_combine(internal, internal) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_combine(internal, internal) is 'aggregate combine function';

create function pg_catalog.numeric_deserialize(bytea, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_deserialize(bytea, internal) is 'aggregate deserial function';

create function pg_catalog.numeric_div(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_div(numeric, numeric) is 'implementation of / operator';

create function pg_catalog.numeric_div_trunc(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_div_trunc(numeric, numeric) is 'trunc(x/y)';

create function pg_catalog.numeric_eq(numeric, numeric) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_eq(numeric, numeric) is 'implementation of = operator';

create function pg_catalog.numeric_exp(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_exp(numeric) is 'natural exponential (e^x)';

create function pg_catalog.numeric_fac(bigint) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_fac(bigint) is 'implementation of deprecated ! and !! factorial operators';

create function pg_catalog.numeric_ge(numeric, numeric) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ge(numeric, numeric) is 'implementation of >= operator';

create function pg_catalog.numeric_gt(numeric, numeric) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_gt(numeric, numeric) is 'implementation of > operator';

create function pg_catalog.numeric_in(cstring, oid, integer) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.numeric_inc(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_inc(numeric) is 'increment by one';

create function pg_catalog.numeric_larger(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_larger(numeric, numeric) is 'larger of two';

create function pg_catalog.numeric_le(numeric, numeric) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_le(numeric, numeric) is 'implementation of <= operator';

create function pg_catalog.numeric_ln(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ln(numeric) is 'natural logarithm';

create function pg_catalog.numeric_log(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_log(numeric, numeric) is 'logarithm base m of n';

create function pg_catalog.numeric_lt(numeric, numeric) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_lt(numeric, numeric) is 'implementation of < operator';

create function pg_catalog.numeric_mod(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_mod(numeric, numeric) is 'implementation of % operator';

create function pg_catalog.numeric_mul(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_mul(numeric, numeric) is 'implementation of * operator';

create function pg_catalog.numeric_ne(numeric, numeric) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ne(numeric, numeric) is 'implementation of <> operator';

create function pg_catalog.numeric_out(numeric) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_out(numeric) is 'I/O';

create function pg_catalog.numeric_poly_avg(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_avg(internal) is 'aggregate final function';

create function pg_catalog.numeric_poly_combine(internal, internal) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_combine(internal, internal) is 'aggregate combine function';

create function pg_catalog.numeric_poly_deserialize(bytea, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_deserialize(bytea, internal) is 'aggregate deserial function';

create function pg_catalog.numeric_poly_serialize(internal) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_serialize(internal) is 'aggregate serial function';

create function pg_catalog.numeric_poly_stddev_pop(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_stddev_pop(internal) is 'aggregate final function';

create function pg_catalog.numeric_poly_stddev_samp(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_stddev_samp(internal) is 'aggregate final function';

create function pg_catalog.numeric_poly_sum(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_sum(internal) is 'aggregate final function';

create function pg_catalog.numeric_poly_var_pop(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_var_pop(internal) is 'aggregate final function';

create function pg_catalog.numeric_poly_var_samp(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_var_samp(internal) is 'aggregate final function';

create function pg_catalog.numeric_power(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_power(numeric, numeric) is 'implementation of ^ operator';

create function pg_catalog.numeric_recv(internal, oid, integer) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.numeric_send(numeric) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_send(numeric) is 'I/O';

create function pg_catalog.numeric_serialize(internal) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_serialize(internal) is 'aggregate serial function';

create function pg_catalog.numeric_smaller(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_smaller(numeric, numeric) is 'smaller of two';

create function pg_catalog.numeric_sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sortsupport(internal) is 'sort support';

create function pg_catalog.numeric_sqrt(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sqrt(numeric) is 'square root';

create function pg_catalog.numeric_stddev_pop(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_stddev_pop(internal) is 'aggregate final function';

create function pg_catalog.numeric_stddev_samp(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_stddev_samp(internal) is 'aggregate final function';

create function pg_catalog.numeric_sub(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sub(numeric, numeric) is 'implementation of - operator';

create function pg_catalog.numeric_sum(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sum(internal) is 'aggregate final function';

create function pg_catalog.numeric_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_support(internal) is 'planner support for numeric length coercion';

create function pg_catalog.numeric_uminus(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_uminus(numeric) is 'implementation of - operator';

create function pg_catalog.numeric_uplus(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_uplus(numeric) is 'implementation of + operator';

create function pg_catalog.numeric_var_pop(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_var_pop(internal) is 'aggregate final function';

create function pg_catalog.numeric_var_samp(internal) returns numeric
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_var_samp(internal) is 'aggregate final function';

create function pg_catalog.numerictypmodin(cstring[]) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numerictypmodin(cstring[]) is 'I/O typmod';

create function pg_catalog.numerictypmodout(integer) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numerictypmodout(integer) is 'I/O typmod';

create function pg_catalog.numnode(tsquery) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numnode(tsquery) is 'number of nodes';

create function pg_catalog.numrange(numeric, numeric) returns numrange
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange(numeric, numeric) is 'numrange constructor';

create function pg_catalog.numrange(numeric, numeric, text) returns numrange
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange(numeric, numeric, text) is 'numrange constructor';

create function pg_catalog.numrange_subdiff(numeric, numeric) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange_subdiff(numeric, numeric) is 'float8 difference of two numeric values';

create function pg_catalog.obj_description(oid) returns text
    stable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.obj_description(oid) is 'deprecated, use two-argument form instead';

create function pg_catalog.obj_description(oid, name) returns text
    stable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.obj_description(oid, name) is 'get description for object id and catalog name';

create function pg_catalog.octet_length(bit) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(bit) is 'octet length';

create function pg_catalog.octet_length(bytea) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(bytea) is 'octet length';

create function pg_catalog.octet_length(char) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(char) is 'octet length';

create function pg_catalog.octet_length(text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(text) is 'octet length';

create function pg_catalog.oid(bigint) returns oid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oid(bigint) is 'convert int8 to oid';

create function pg_catalog.oideq(oid, oid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oideq(oid, oid) is 'implementation of = operator';

create function pg_catalog.oidge(oid, oid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidge(oid, oid) is 'implementation of >= operator';

create function pg_catalog.oidgt(oid, oid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidgt(oid, oid) is 'implementation of > operator';

create function pg_catalog.oidin(cstring) returns oid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidin(cstring) is 'I/O';

create function pg_catalog.oidlarger(oid, oid) returns oid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidlarger(oid, oid) is 'larger of two';

create function pg_catalog.oidle(oid, oid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidle(oid, oid) is 'implementation of <= operator';

create function pg_catalog.oidlt(oid, oid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidlt(oid, oid) is 'implementation of < operator';

create function pg_catalog.oidne(oid, oid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidne(oid, oid) is 'implementation of <> operator';

create function pg_catalog.oidout(oid) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidout(oid) is 'I/O';

create function pg_catalog.oidrecv(internal) returns oid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidrecv(internal) is 'I/O';

create function pg_catalog.oidsend(oid) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidsend(oid) is 'I/O';

create function pg_catalog.oidsmaller(oid, oid) returns oid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidsmaller(oid, oid) is 'smaller of two';

create function pg_catalog.oidvectoreq(oidvector, oidvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectoreq(oidvector, oidvector) is 'implementation of = operator';

create function pg_catalog.oidvectorge(oidvector, oidvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorge(oidvector, oidvector) is 'implementation of >= operator';

create function pg_catalog.oidvectorgt(oidvector, oidvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorgt(oidvector, oidvector) is 'implementation of > operator';

create function pg_catalog.oidvectorin(cstring) returns oidvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorin(cstring) is 'I/O';

create function pg_catalog.oidvectorle(oidvector, oidvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorle(oidvector, oidvector) is 'implementation of <= operator';

create function pg_catalog.oidvectorlt(oidvector, oidvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorlt(oidvector, oidvector) is 'implementation of < operator';

create function pg_catalog.oidvectorne(oidvector, oidvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorne(oidvector, oidvector) is 'implementation of <> operator';

create function pg_catalog.oidvectorout(oidvector) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorout(oidvector) is 'I/O';

create function pg_catalog.oidvectorrecv(internal) returns oidvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorrecv(internal) is 'I/O';

create function pg_catalog.oidvectorsend(oidvector) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorsend(oidvector) is 'I/O';

create function pg_catalog.oidvectortypes(oidvector) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectortypes(oidvector) is 'print type names of oidvector field';

create function pg_catalog.on_pb(point, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_pb(point, box) is 'implementation of <@ operator';

create function pg_catalog.on_pl(point, line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_pl(point, line) is 'implementation of <@ operator';

create function pg_catalog.on_ppath(point, path) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_ppath(point, path) is 'implementation of <@ operator';

create function pg_catalog.on_ps(point, lseg) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_ps(point, lseg) is 'implementation of <@ operator';

create function pg_catalog.on_sb(lseg, box) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_sb(lseg, box) is 'implementation of <@ operator';

create function pg_catalog.on_sl(lseg, line) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_sl(lseg, line) is 'implementation of <@ operator';

create function pg_catalog.ordered_set_transition(internal, "any") returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ordered_set_transition(internal, "any") is 'aggregate transition function';

create function pg_catalog.ordered_set_transition_multi(internal, "any") returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ordered_set_transition_multi(internal, "any") is 'aggregate transition function';

create function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone, time with time zone) returns boolean
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone, time with time zone) is 'intervals overlap?';

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, interval) returns boolean
    immutable
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(time, interval, time, interval) is 'intervals overlap?';

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, time without time zone) returns boolean
    immutable
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(time, interval, time, time) is 'intervals overlap?';

create function pg_catalog."overlaps"(time without time zone, time without time zone, time without time zone, interval) returns boolean
    immutable
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(time, time, time, interval) is 'intervals overlap?';

create function pg_catalog."overlaps"(time, time, time, time) returns boolean
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(time, time, time, time) is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval) returns boolean
    stable
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval) is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, timestamp with time zone) returns boolean
    stable
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, timestamp with time zone) is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, interval) returns boolean
    stable
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, interval) is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone) is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone, interval) returns boolean
    immutable
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp, interval, timestamp, interval) is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone, timestamp without time zone) returns boolean
    immutable
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp, interval, timestamp, timestamp) is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp without time zone, timestamp without time zone, timestamp without time zone, interval) returns boolean
    immutable
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp, timestamp, timestamp, interval) is 'intervals overlap?';

create function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp) returns boolean
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp) is 'intervals overlap?';

create function pg_catalog.overlay(bit, bit, integer) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bit, bit, integer) is 'substitute portion of bitstring';

create function pg_catalog.overlay(bit, bit, integer, integer) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bit, bit, integer, integer) is 'substitute portion of bitstring';

create function pg_catalog.overlay(bytea, bytea, integer) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bytea, bytea, integer) is 'substitute portion of string';

create function pg_catalog.overlay(bytea, bytea, integer, integer) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bytea, bytea, integer, integer) is 'substitute portion of string';

create function pg_catalog.overlay(text, text, integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(text, text, integer) is 'substitute portion of string';

create function pg_catalog.overlay(text, text, integer, integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(text, text, integer, integer) is 'substitute portion of string';

create function pg_catalog.parse_ident(str text, strict boolean default true) returns text[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.parse_ident(text, boolean) is 'parse qualified identifier to array of identifiers';

create function pg_catalog.path(polygon) returns path
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path(polygon) is 'convert polygon to path';

create function pg_catalog.path_add(path, path) returns path
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_add(path, path) is 'implementation of + operator';

create function pg_catalog.path_add_pt(path, point) returns path
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_add_pt(path, point) is 'implementation of + operator';

create function pg_catalog.path_center(path) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_center(path) is 'implementation of @@ operator';

create function pg_catalog.path_contain_pt(path, point) returns boolean
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_contain_pt(path, point) is 'implementation of @> operator';

create function pg_catalog.path_distance(path, path) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_distance(path, path) is 'implementation of <-> operator';

create function pg_catalog.path_div_pt(path, point) returns path
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_div_pt(path, point) is 'implementation of / operator';

create function pg_catalog.path_in(cstring) returns path
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_in(cstring) is 'I/O';

create function pg_catalog.path_inter(path, path) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_inter(path, path) is 'implementation of ?# operator';

create function pg_catalog.path_length(path) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_length(path) is 'implementation of @-@ operator';

create function pg_catalog.path_mul_pt(path, point) returns path
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_mul_pt(path, point) is 'implementation of * operator';

create function pg_catalog.path_n_eq(path, path) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_eq(path, path) is 'implementation of = operator';

create function pg_catalog.path_n_ge(path, path) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_ge(path, path) is 'implementation of >= operator';

create function pg_catalog.path_n_gt(path, path) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_gt(path, path) is 'implementation of > operator';

create function pg_catalog.path_n_le(path, path) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_le(path, path) is 'implementation of <= operator';

create function pg_catalog.path_n_lt(path, path) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_lt(path, path) is 'implementation of < operator';

create function pg_catalog.path_npoints(path) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_npoints(path) is 'implementation of # operator';

create function pg_catalog.path_out(path) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_out(path) is 'I/O';

create function pg_catalog.path_recv(internal) returns path
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_recv(internal) is 'I/O';

create function pg_catalog.path_send(path) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_send(path) is 'I/O';

create function pg_catalog.path_sub_pt(path, point) returns path
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_sub_pt(path, point) is 'implementation of - operator';

create function pg_catalog.pclose(path) returns path
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pclose(path) is 'close path';

create function pg_catalog.percent_rank() returns double precision
    immutable
    window
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percent_rank() is 'fractional rank within partition';

create function pg_catalog.percent_rank_final(internal, "any") returns double precision
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percent_rank_final(internal, "any") is 'aggregate final function';

create function pg_catalog.percentile_cont_float8_final(internal, double precision) returns double precision
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_float8_final(internal, double precision) is 'aggregate final function';

create function pg_catalog.percentile_cont_float8_multi_final(internal, double precision[]) returns double precision[]
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_float8_multi_final(internal, double precision[]) is 'aggregate final function';

create function pg_catalog.percentile_cont_interval_final(internal, double precision) returns interval
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_interval_final(internal, double precision) is 'aggregate final function';

create function pg_catalog.percentile_cont_interval_multi_final(internal, double precision[]) returns interval[]
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_interval_multi_final(internal, double precision[]) is 'aggregate final function';

create function pg_catalog.percentile_disc_final(internal, double precision, anyelement) returns anyelement
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_disc_final(internal, double precision, anyelement) is 'aggregate final function';

create function pg_catalog.percentile_disc_multi_final(internal, double precision[], anyelement) returns anyarray
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_disc_multi_final(internal, double precision[], anyelement) is 'aggregate final function';

create function pg_catalog.pg_advisory_lock(bigint) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock(bigint) is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_lock(integer, integer) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock(integer, integer) is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_lock_shared(bigint) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock_shared(bigint) is 'obtain shared advisory lock';

create function pg_catalog.pg_advisory_lock_shared(integer, integer) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock_shared(integer, integer) is 'obtain shared advisory lock';

create function pg_catalog.pg_advisory_unlock(bigint) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock(bigint) is 'release exclusive advisory lock';

create function pg_catalog.pg_advisory_unlock(integer, integer) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock(integer, integer) is 'release exclusive advisory lock';

create function pg_catalog.pg_advisory_unlock_all() returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_all() is 'release all advisory locks';

create function pg_catalog.pg_advisory_unlock_shared(bigint) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_shared(bigint) is 'release shared advisory lock';

create function pg_catalog.pg_advisory_unlock_shared(integer, integer) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_shared(integer, integer) is 'release shared advisory lock';

create function pg_catalog.pg_advisory_xact_lock(bigint) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock(bigint) is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_xact_lock(integer, integer) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock(integer, integer) is 'obtain exclusive advisory lock';

create function pg_catalog.pg_advisory_xact_lock_shared(bigint) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock_shared(bigint) is 'obtain shared advisory lock';

create function pg_catalog.pg_advisory_xact_lock_shared(integer, integer) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock_shared(integer, integer) is 'obtain shared advisory lock';

create function pg_catalog.pg_available_extension_versions(out name name, out version text, out superuser boolean, out trusted boolean, out relocatable boolean, out schema name, out requires name[], out comment text) returns setof setof record
    stable
    strict
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_available_extension_versions(out name, out text, out boolean, out boolean, out boolean, out name, out name[], out text) is 'list available extension versions';

create function pg_catalog.pg_available_extensions(out name name, out default_version text, out comment text) returns setof setof record
    stable
    strict
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_available_extensions(out name, out text, out text) is 'list available extensions';

create function pg_catalog.pg_backend_pid() returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_backend_pid() is 'statistics: current backend PID';

create function pg_catalog.pg_backup_start_time() returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_backup_start_time() is 'start time of an online backup';

create function pg_catalog.pg_blocking_pids(integer) returns integer[]
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_blocking_pids(integer) is 'get array of PIDs of sessions blocking specified backend PID from acquiring a heavyweight lock';

create function pg_catalog.pg_cancel_backend(integer) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_cancel_backend(integer) is 'cancel a server process'' current query';

create function pg_catalog.pg_char_to_encoding(name) returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_char_to_encoding(name) is 'convert encoding name to encoding id';

create function pg_catalog.pg_client_encoding() returns name
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_client_encoding() is 'encoding name of current database';

create function pg_catalog.pg_collation_actual_version(oid) returns text
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_actual_version(oid) is 'get actual version of collation from operating system';

create function pg_catalog.pg_collation_for("any") returns text
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_for("any") is 'collation of the argument; implementation of the COLLATION FOR expression';

create function pg_catalog.pg_collation_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_is_visible(oid) is 'is collation visible in search path?';

create function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean) is 'is a column updatable';

create function pg_catalog.pg_column_size("any") returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_column_size("any") is 'bytes required to store the value, perhaps with compression';

create function pg_catalog.pg_conf_load_time() returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_conf_load_time() is 'configuration load time';

create function pg_catalog.pg_config(out name text, out setting text) returns setof setof record
    stable
    strict
    cost 1
    rows 23
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_config(out text, out text) is 'pg_config binary as a function';

create function pg_catalog.pg_control_checkpoint(out checkpoint_lsn pg_lsn, out redo_lsn pg_lsn, out redo_wal_file text, out timeline_id integer, out prev_timeline_id integer, out full_page_writes boolean, out next_xid text, out next_oid oid, out next_multixact_id xid, out next_multi_offset xid, out oldest_xid xid, out oldest_xid_dbid oid, out oldest_active_xid xid, out oldest_multi_xid xid, out oldest_multi_dbid oid, out oldest_commit_ts_xid xid, out newest_commit_ts_xid xid, out checkpoint_time timestamp with time zone) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_checkpoint(out pg_lsn, out pg_lsn, out text, out integer, out integer, out boolean, out text, out oid, out xid, out xid, out xid, out oid, out xid, out xid, out oid, out xid, out xid, out timestamp with time zone) is 'pg_controldata checkpoint state information as a function';

create function pg_catalog.pg_control_init(out max_data_alignment integer, out database_block_size integer, out blocks_per_segment integer, out wal_block_size integer, out bytes_per_wal_segment integer, out max_identifier_length integer, out max_index_columns integer, out max_toast_chunk_size integer, out large_object_chunk_size integer, out float8_pass_by_value boolean, out data_page_checksum_version integer) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_init(out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out boolean, out integer) is 'pg_controldata init state information as a function';

create function pg_catalog.pg_control_recovery(out min_recovery_end_lsn pg_lsn, out min_recovery_end_timeline integer, out backup_start_lsn pg_lsn, out backup_end_lsn pg_lsn, out end_of_backup_record_required boolean) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_recovery(out pg_lsn, out integer, out pg_lsn, out pg_lsn, out boolean) is 'pg_controldata recovery state information as a function';

create function pg_catalog.pg_control_system(out pg_control_version integer, out catalog_version_no integer, out system_identifier bigint, out pg_control_last_modified timestamp with time zone) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_system(out integer, out integer, out bigint, out timestamp with time zone) is 'pg_controldata general state information as a function';

create function pg_catalog.pg_conversion_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_conversion_is_visible(oid) is 'is conversion visible in search path?';

create function pg_catalog.pg_copy_logical_replication_slot(src_slot_name name, dst_slot_name name, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot(name, name, out name, out pg_lsn) is 'copy a logical replication slot';

create function pg_catalog.pg_copy_logical_replication_slot(src_slot_name name, dst_slot_name name, temporary boolean, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot(name, name, boolean, out name, out pg_lsn) is 'copy a logical replication slot, changing temporality';

create function pg_catalog.pg_copy_logical_replication_slot(src_slot_name name, dst_slot_name name, temporary boolean, plugin name, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot(name, name, boolean, name, out name, out pg_lsn) is 'copy a logical replication slot, changing temporality and plugin';

create function pg_catalog.pg_copy_physical_replication_slot(src_slot_name name, dst_slot_name name, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_physical_replication_slot(name, name, out name, out pg_lsn) is 'copy a physical replication slot';

create function pg_catalog.pg_copy_physical_replication_slot(src_slot_name name, dst_slot_name name, temporary boolean, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_physical_replication_slot(name, name, boolean, out name, out pg_lsn) is 'copy a physical replication slot, changing temporality';

create function pg_catalog.pg_create_logical_replication_slot(slot_name name, plugin name, temporary boolean default false, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_logical_replication_slot(name, name, boolean, out name, out pg_lsn) is 'set up a logical replication slot';

create function pg_catalog.pg_create_physical_replication_slot(slot_name name, immediately_reserve boolean default false, temporary boolean default false, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_physical_replication_slot(name, boolean, boolean, out name, out pg_lsn) is 'create a physical replication slot';

create function pg_catalog.pg_create_restore_point(text) returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_restore_point(text) is 'create a named restore point';

create function pg_catalog.pg_current_logfile() returns text
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_logfile() is 'current logging collector file location';

create function pg_catalog.pg_current_logfile(text) returns text
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_logfile(text) is 'current logging collector file location';

create function pg_catalog.pg_current_snapshot() returns pg_snapshot
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_snapshot() is 'get current snapshot';

create function pg_catalog.pg_current_wal_flush_lsn() returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_flush_lsn() is 'current wal flush location';

create function pg_catalog.pg_current_wal_insert_lsn() returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_insert_lsn() is 'current wal insert location';

create function pg_catalog.pg_current_wal_lsn() returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_lsn() is 'current wal write location';

create function pg_catalog.pg_current_xact_id() returns xid8
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_xact_id() is 'get current transaction ID';

create function pg_catalog.pg_current_xact_id_if_assigned() returns xid8
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_xact_id_if_assigned() is 'get current transaction ID';

create function pg_catalog.pg_cursor(out name text, out statement text, out is_holdable boolean, out is_binary boolean, out is_scrollable boolean, out creation_time timestamp with time zone) returns setof setof record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_cursor(out text, out text, out boolean, out boolean, out boolean, out timestamp with time zone) is 'get the open cursors for this session';

create function pg_catalog.pg_database_size(name) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_database_size(name) is 'total disk space usage for the specified database';

create function pg_catalog.pg_database_size(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_database_size(oid) is 'total disk space usage for the specified database';

create function pg_catalog.pg_ddl_command_in(cstring) returns pg_ddl_command
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_in(cstring) is 'I/O';

create function pg_catalog.pg_ddl_command_out(pg_ddl_command) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_out(pg_ddl_command) is 'I/O';

create function pg_catalog.pg_ddl_command_recv(internal) returns pg_ddl_command
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_recv(internal) is 'I/O';

create function pg_catalog.pg_ddl_command_send(pg_ddl_command) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_send(pg_ddl_command) is 'I/O';

create function pg_catalog.pg_dependencies_in(cstring) returns pg_dependencies
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_in(cstring) is 'I/O';

create function pg_catalog.pg_dependencies_out(pg_dependencies) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_out(pg_dependencies) is 'I/O';

create function pg_catalog.pg_dependencies_recv(internal) returns pg_dependencies
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_recv(internal) is 'I/O';

create function pg_catalog.pg_dependencies_send(pg_dependencies) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_send(pg_dependencies) is 'I/O';

create function pg_catalog.pg_describe_object(oid, oid, integer) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_describe_object(oid, oid, integer) is 'get identification of SQL object';

create function pg_catalog.pg_drop_replication_slot(name) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_drop_replication_slot(name) is 'drop a replication slot';

create function pg_catalog.pg_encoding_max_length(integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_encoding_max_length(integer) is 'maximum octet length of a character in given encoding';

create function pg_catalog.pg_encoding_to_char(integer) returns name
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_encoding_to_char(integer) is 'convert encoding id to encoding name';

create function pg_catalog.pg_event_trigger_ddl_commands(out classid oid, out objid oid, out objsubid integer, out command_tag text, out object_type text, out schema_name text, out object_identity text, out in_extension boolean, out command pg_ddl_command) returns setof setof record
    stable
    strict
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_event_trigger_ddl_commands(out oid, out oid, out integer, out text, out text, out text, out text, out boolean, out pg_ddl_command) is 'list DDL actions being executed by the current command';

create function pg_catalog.pg_event_trigger_dropped_objects(out classid oid, out objid oid, out objsubid integer, out original boolean, out normal boolean, out is_temporary boolean, out object_type text, out schema_name text, out object_name text, out object_identity text, out address_names text[], out address_args text[]) returns setof setof record
    stable
    strict
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_event_trigger_dropped_objects(out oid, out oid, out integer, out boolean, out boolean, out boolean, out text, out text, out text, out text, out text[], out text[]) is 'list objects dropped by the current command';

create function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid oid) returns oid
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid) is 'return Oid of the table getting rewritten';

create function pg_catalog.pg_event_trigger_table_rewrite_reason() returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_table_rewrite_reason() is 'return reason code for table getting rewritten';

create function pg_catalog.pg_export_snapshot() returns text
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_export_snapshot() is 'export a snapshot';

create function pg_catalog.pg_extension_config_dump(regclass, text) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_extension_config_dump(regclass, text) is 'flag an extension''s table contents to be emitted by pg_dump';

create function pg_catalog.pg_extension_update_paths(name name, out source text, out target text, out path text) returns setof setof record
    stable
    strict
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_extension_update_paths(name, out text, out text, out text) is 'list an extension''s version update paths';

create function pg_catalog.pg_filenode_relation(oid, oid) returns regclass
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_filenode_relation(oid, oid) is 'relation OID for filenode and tablespace';

create function pg_catalog.pg_function_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_function_is_visible(oid) is 'is function visible in search path?';

create function pg_catalog.pg_get_constraintdef(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_constraintdef(oid) is 'constraint description';

create function pg_catalog.pg_get_constraintdef(oid, boolean) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_constraintdef(oid, boolean) is 'constraint description with pretty-print option';

create function pg_catalog.pg_get_expr(pg_node_tree, oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_expr(pg_node_tree, oid) is 'deparse an encoded expression';

create function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean) is 'deparse an encoded expression with pretty-print option';

create function pg_catalog.pg_get_function_arg_default(oid, integer) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_arg_default(oid, integer) is 'function argument default';

create function pg_catalog.pg_get_function_arguments(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_arguments(oid) is 'argument list of a function';

create function pg_catalog.pg_get_function_identity_arguments(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_identity_arguments(oid) is 'identity argument list of a function';

create function pg_catalog.pg_get_function_result(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_result(oid) is 'result type of a function';

create function pg_catalog.pg_get_functiondef(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_functiondef(oid) is 'definition of a function';

create function pg_catalog.pg_get_indexdef(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_indexdef(oid) is 'index description';

create function pg_catalog.pg_get_indexdef(oid, integer, boolean) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_indexdef(oid, integer, boolean) is 'index description (full create statement or single expression) with pretty-print option';

create function pg_catalog.pg_get_keywords(out word text, out catcode "char", out catdesc text) returns setof setof record
    stable
    strict
    cost 10
    rows 400
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_keywords(out text, out "char", out text) is 'list of SQL keywords';

create function pg_catalog.pg_get_multixact_members(multixid xid, out xid xid, out mode text) returns setof setof record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_multixact_members(xid, out xid, out text) is 'view members of a multixactid';

create function pg_catalog.pg_get_object_address(type text, object_names text[], object_args text[], out classid oid, out objid oid, out objsubid integer) returns record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_object_address(text, text[], text[], out oid, out oid, out integer) is 'get OID-based object address from name/args arrays';

create function pg_catalog.pg_get_partition_constraintdef(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_partition_constraintdef(oid) is 'partition constraint description';

create function pg_catalog.pg_get_partkeydef(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_partkeydef(oid) is 'partition key description';

create function pg_catalog.pg_get_publication_tables(pubname text, out relid oid) returns setof setof oid
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_publication_tables(text, out oid) is 'get OIDs of tables in a publication';

create function pg_catalog.pg_get_replica_identity_index(regclass) returns regclass
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_replica_identity_index(regclass) is 'oid of replica identity index if any';

create function pg_catalog.pg_get_replication_slots(out slot_name name, out plugin name, out slot_type text, out datoid oid, out temporary boolean, out active boolean, out active_pid integer, out xmin xid, out catalog_xmin xid, out restart_lsn pg_lsn, out confirmed_flush_lsn pg_lsn, out wal_status text, out safe_wal_size bigint) returns setof setof record
    stable
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_replication_slots(out name, out name, out text, out oid, out boolean, out boolean, out integer, out xid, out xid, out pg_lsn, out pg_lsn, out text, out bigint) is 'information about replication slots currently in use';

create function pg_catalog.pg_get_ruledef(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_ruledef(oid) is 'source text of a rule';

create function pg_catalog.pg_get_ruledef(oid, boolean) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_ruledef(oid, boolean) is 'source text of a rule with pretty-print option';

create function pg_catalog.pg_get_serial_sequence(text, text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_serial_sequence(text, text) is 'name of sequence for a serial column';

create function pg_catalog.pg_get_shmem_allocations(out name text, out "off" bigint, out size bigint, out allocated_size bigint) returns setof setof record
    strict
    cost 1
    rows 50
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_shmem_allocations(out text, out bigint, out bigint, out bigint) is 'allocations from the main shared memory segment';

create function pg_catalog.pg_get_statisticsobjdef(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_statisticsobjdef(oid) is 'extended statistics object description';

create function pg_catalog.pg_get_triggerdef(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_triggerdef(oid) is 'trigger description';

create function pg_catalog.pg_get_triggerdef(oid, boolean) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_triggerdef(oid, boolean) is 'trigger description with pretty-print option';

create function pg_catalog.pg_get_userbyid(oid) returns name
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_userbyid(oid) is 'role name by OID (with fallback)';

create function pg_catalog.pg_get_viewdef(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(oid) is 'select statement of a view';

create function pg_catalog.pg_get_viewdef(oid, boolean) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(oid, boolean) is 'select statement of a view with pretty-print option';

create function pg_catalog.pg_get_viewdef(oid, integer) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(oid, integer) is 'select statement of a view with pretty-printing and specified line wrapping';

create function pg_catalog.pg_get_viewdef(text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(text) is 'select statement of a view';

create function pg_catalog.pg_get_viewdef(text, boolean) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(text, boolean) is 'select statement of a view with pretty-print option';

create function pg_catalog.pg_has_role(name, name, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(name, name, text) is 'user privilege on role by username, role name';

create function pg_catalog.pg_has_role(name, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(name, oid, text) is 'user privilege on role by username, role oid';

create function pg_catalog.pg_has_role(name, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(name, text) is 'current user privilege on role by role name';

create function pg_catalog.pg_has_role(oid, name, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(oid, name, text) is 'user privilege on role by user oid, role name';

create function pg_catalog.pg_has_role(oid, oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(oid, oid, text) is 'user privilege on role by user oid, role oid';

create function pg_catalog.pg_has_role(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(oid, text) is 'current user privilege on role by role oid';

create function pg_catalog.pg_hba_file_rules(out line_number integer, out type text, out database text[], out user_name text[], out address text, out netmask text, out auth_method text, out options text[], out error text) returns setof setof record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_hba_file_rules(out integer, out text, out text[], out text[], out text, out text, out text, out text[], out text) is 'show pg_hba.conf rules';

create function pg_catalog.pg_identify_object(classid oid, objid oid, objsubid integer, out type text, out schema text, out name text, out identity text) returns record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_identify_object(oid, oid, integer, out text, out text, out text, out text) is 'get machine-parseable identification of SQL object';

create function pg_catalog.pg_identify_object_as_address(classid oid, objid oid, objsubid integer, out type text, out object_names text[], out object_args text[]) returns record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_identify_object_as_address(oid, oid, integer, out text, out text[], out text[]) is 'get identification of SQL object for pg_get_object_address()';

create function pg_catalog.pg_import_system_collations(regnamespace) returns integer
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_import_system_collations(regnamespace) is 'import collations from operating system';

create function pg_catalog.pg_index_column_has_property(regclass, integer, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_index_column_has_property(regclass, integer, text) is 'test property of an index column';

create function pg_catalog.pg_index_has_property(regclass, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_index_has_property(regclass, text) is 'test property of an index';

create function pg_catalog.pg_indexam_has_property(oid, text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexam_has_property(oid, text) is 'test property of an index access method';

create function pg_catalog.pg_indexam_progress_phasename(oid, bigint) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexam_progress_phasename(oid, bigint) is 'return name of given index build phase';

create function pg_catalog.pg_indexes_size(regclass) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexes_size(regclass) is 'disk space usage for all indexes attached to the specified table';

create function pg_catalog.pg_is_in_backup() returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_in_backup() is 'true if server is in online backup';

create function pg_catalog.pg_is_in_recovery() returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_in_recovery() is 'true if server is in recovery';

create function pg_catalog.pg_is_other_temp_schema(oid) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_other_temp_schema(oid) is 'is schema another session''s temp schema?';

create function pg_catalog.pg_is_wal_replay_paused() returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_wal_replay_paused() is 'true if wal replay is paused';

create function pg_catalog.pg_isolation_test_session_is_blocked(integer, integer[]) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_isolation_test_session_is_blocked(integer, integer[]) is 'isolationtester support function';

create function pg_catalog.pg_jit_available() returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_jit_available() is 'Is JIT compilation available in this session?';

create function pg_catalog.pg_last_committed_xact(out xid xid, out timestamp timestamp with time zone) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_committed_xact(out xid, out timestamp with time zone) is 'get transaction Id and commit timestamp of latest transaction commit';

create function pg_catalog.pg_last_wal_receive_lsn() returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_wal_receive_lsn() is 'current wal flush location';

create function pg_catalog.pg_last_wal_replay_lsn() returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_wal_replay_lsn() is 'last wal replay location';

create function pg_catalog.pg_last_xact_replay_timestamp() returns timestamp with time zone
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_xact_replay_timestamp() is 'timestamp of last replay xact';

create function pg_catalog.pg_listening_channels() returns setof setof text
    stable
    strict
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_listening_channels() is 'get the channels that the current backend listens to';

create function pg_catalog.pg_lock_status(out locktype text, out database oid, out relation oid, out page integer, out tuple smallint, out virtualxid text, out transactionid xid, out classid oid, out objid oid, out objsubid smallint, out virtualtransaction text, out pid integer, out mode text, out granted boolean, out fastpath boolean) returns setof setof record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_lock_status(out text, out oid, out oid, out integer, out smallint, out text, out xid, out oid, out oid, out smallint, out text, out integer, out text, out boolean, out boolean) is 'view system lock information';

create function pg_catalog.pg_logical_emit_message(boolean, text, bytea) returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_emit_message(boolean, text, bytea) is 'emit a binary logical decoding message';

create function pg_catalog.pg_logical_emit_message(boolean, text, text) returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_emit_message(boolean, text, text) is 'emit a textual logical decoding message';

create function pg_catalog.pg_logical_slot_get_binary_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer, options text[] default '{}'::text[], out lsn pg_lsn, out xid xid, out data bytea) returns setof setof record
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_logical_slot_get_binary_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out bytea) is 'get binary changes from replication slot';

create function pg_catalog.pg_logical_slot_get_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer, options text[] default '{}'::text[], out lsn pg_lsn, out xid xid, out data text) returns setof setof record
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_logical_slot_get_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out text) is 'get changes from replication slot';

create function pg_catalog.pg_logical_slot_peek_binary_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer, options text[] default '{}'::text[], out lsn pg_lsn, out xid xid, out data bytea) returns setof setof record
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_logical_slot_peek_binary_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out bytea) is 'peek at binary changes from replication slot';

create function pg_catalog.pg_logical_slot_peek_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer, options text[] default '{}'::text[], out lsn pg_lsn, out xid xid, out data text) returns setof setof record
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_logical_slot_peek_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out text) is 'peek at changes from replication slot';

create function pg_catalog.pg_ls_archive_statusdir(out name text, out size bigint, out modification timestamp with time zone) returns setof setof record
    strict
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_archive_statusdir(out text, out bigint, out timestamp with time zone) is 'list of files in the archive_status directory';

create function pg_catalog.pg_ls_dir(text) returns setof setof text
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_dir(text) is 'list all files in a directory';

create function pg_catalog.pg_ls_dir(text, boolean, boolean) returns setof setof text
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_dir(text, boolean, boolean) is 'list all files in a directory';

create function pg_catalog.pg_ls_logdir(out name text, out size bigint, out modification timestamp with time zone) returns setof setof record
    strict
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_logdir(out text, out bigint, out timestamp with time zone) is 'list files in the log directory';

create function pg_catalog.pg_ls_tmpdir(out name text, out size bigint, out modification timestamp with time zone) returns setof setof record
    strict
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_tmpdir(out text, out bigint, out timestamp with time zone) is 'list files in the pgsql_tmp directory';

create function pg_catalog.pg_ls_tmpdir(tablespace oid, out name text, out size bigint, out modification timestamp with time zone) returns setof setof record
    strict
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_tmpdir(oid, out text, out bigint, out timestamp with time zone) is 'list files in the pgsql_tmp directory';

create function pg_catalog.pg_ls_waldir(out name text, out size bigint, out modification timestamp with time zone) returns setof setof record
    strict
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_waldir(out text, out bigint, out timestamp with time zone) is 'list of files in the WAL directory';

create function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn) is 'less-equal-greater';

create function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn) is 'implementation of = operator';

create function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn) is 'implementation of >= operator';

create function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn) is 'implementation of > operator';

create function pg_catalog.pg_lsn_hash(pg_lsn) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_hash(pg_lsn) is 'hash';

create function pg_catalog.pg_lsn_hash_extended(pg_lsn, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_hash_extended(pg_lsn, bigint) is 'hash';

create function pg_catalog.pg_lsn_in(cstring) returns pg_lsn
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_in(cstring) is 'I/O';

create function pg_catalog.pg_lsn_larger(pg_lsn, pg_lsn) returns pg_lsn
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_larger(pg_lsn, pg_lsn) is 'larger of two';

create function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn) is 'implementation of <= operator';

create function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn) is 'implementation of < operator';

create function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn) is 'implementation of - operator';

create function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn) is 'implementation of <> operator';

create function pg_catalog.pg_lsn_out(pg_lsn) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_out(pg_lsn) is 'I/O';

create function pg_catalog.pg_lsn_recv(internal) returns pg_lsn
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_recv(internal) is 'I/O';

create function pg_catalog.pg_lsn_send(pg_lsn) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_send(pg_lsn) is 'I/O';

create function pg_catalog.pg_lsn_smaller(pg_lsn, pg_lsn) returns pg_lsn
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_smaller(pg_lsn, pg_lsn) is 'smaller of two';

create function pg_catalog.pg_mcv_list_in(cstring) returns pg_mcv_list
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_in(cstring) is 'I/O';

create function pg_catalog.pg_mcv_list_items(mcv_list pg_mcv_list, out index integer, out values text[], out nulls boolean[], out frequency double precision, out base_frequency double precision) returns setof setof record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_mcv_list_items(pg_mcv_list, out integer, out text[], out boolean[], out double precision, out double precision) is 'details about MCV list items';

create function pg_catalog.pg_mcv_list_out(pg_mcv_list) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_out(pg_mcv_list) is 'I/O';

create function pg_catalog.pg_mcv_list_recv(internal) returns pg_mcv_list
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_recv(internal) is 'I/O';

create function pg_catalog.pg_mcv_list_send(pg_mcv_list) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_send(pg_mcv_list) is 'I/O';

create function pg_catalog.pg_my_temp_schema() returns oid
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_my_temp_schema() is 'get OID of current session''s temp schema, if any';

create function pg_catalog.pg_ndistinct_in(cstring) returns pg_ndistinct
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_in(cstring) is 'I/O';

create function pg_catalog.pg_ndistinct_out(pg_ndistinct) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_out(pg_ndistinct) is 'I/O';

create function pg_catalog.pg_ndistinct_recv(internal) returns pg_ndistinct
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_recv(internal) is 'I/O';

create function pg_catalog.pg_ndistinct_send(pg_ndistinct) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_send(pg_ndistinct) is 'I/O';

create function pg_catalog.pg_nextoid(regclass, name, regclass) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_nextoid(regclass, name, regclass) is 'return the next oid for a system table';

create function pg_catalog.pg_node_tree_in(cstring) returns pg_node_tree
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_in(cstring) is 'I/O';

create function pg_catalog.pg_node_tree_out(pg_node_tree) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_out(pg_node_tree) is 'I/O';

create function pg_catalog.pg_node_tree_recv(internal) returns pg_node_tree
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_recv(internal) is 'I/O';

create function pg_catalog.pg_node_tree_send(pg_node_tree) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_send(pg_node_tree) is 'I/O';

create function pg_catalog.pg_notification_queue_usage() returns double precision
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_notification_queue_usage() is 'get the fraction of the asynchronous notification queue currently in use';

create function pg_catalog.pg_notify(text, text) returns void
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_notify(text, text) is 'send a notification event';

create function pg_catalog.pg_opclass_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_opclass_is_visible(oid) is 'is opclass visible in search path?';

create function pg_catalog.pg_operator_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_operator_is_visible(oid) is 'is operator visible in search path?';

create function pg_catalog.pg_opfamily_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_opfamily_is_visible(oid) is 'is opfamily visible in search path?';

create function pg_catalog.pg_options_to_table(options_array text[], out option_name text, out option_value text) returns setof setof record
    stable
    strict
    cost 1
    rows 3
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_options_to_table(text[], out text, out text) is 'convert generic options array to name/value table';

create function pg_catalog.pg_partition_ancestors(partitionid regclass, out relid regclass) returns setof setof regclass
    strict
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_partition_ancestors(regclass, out regclass) is 'view ancestors of the partition';

create function pg_catalog.pg_partition_root(regclass) returns regclass
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_partition_root(regclass) is 'get top-most partition root parent';

create function pg_catalog.pg_partition_tree(rootrelid regclass, out relid regclass, out parentrelid regclass, out isleaf boolean, out level integer) returns setof setof record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_partition_tree(regclass, out regclass, out regclass, out boolean, out integer) is 'view partition tree tables';

create function pg_catalog.pg_postmaster_start_time() returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_postmaster_start_time() is 'postmaster start time';

create function pg_catalog.pg_prepared_statement(out name text, out statement text, out prepare_time timestamp with time zone, out parameter_types regtype[], out from_sql boolean) returns setof setof record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_prepared_statement(out text, out text, out timestamp with time zone, out regtype[], out boolean) is 'get the prepared statements for this session';

create function pg_catalog.pg_prepared_xact(out transaction xid, out gid text, out prepared timestamp with time zone, out ownerid oid, out dbid oid) returns setof setof record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_prepared_xact(out xid, out text, out timestamp with time zone, out oid, out oid) is 'view two-phase transactions';

create function pg_catalog.pg_promote(wait boolean default true, wait_seconds integer default 60) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_promote(boolean, integer) is 'promote standby server';

create function pg_catalog.pg_read_binary_file(text) returns bytea
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file(text) is 'read bytea from a file';

create function pg_catalog.pg_read_binary_file(text, bigint, bigint) returns bytea
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file(text, bigint, bigint) is 'read bytea from a file';

create function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean) returns bytea
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean) is 'read bytea from a file';

create function pg_catalog.pg_read_file(text) returns text
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file(text) is 'read text from a file';

create function pg_catalog.pg_read_file(text, bigint, bigint) returns text
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file(text, bigint, bigint) is 'read text from a file';

create function pg_catalog.pg_read_file(text, bigint, bigint, boolean) returns text
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file(text, bigint, bigint, boolean) is 'read text from a file';

create function pg_catalog.pg_read_file_old(text, bigint, bigint) returns text
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file_old(text, bigint, bigint) is 'read text from a file - old version for adminpack 1.0';

create function pg_catalog.pg_relation_filenode(regclass) returns oid
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_filenode(regclass) is 'filenode identifier of relation';

create function pg_catalog.pg_relation_filepath(regclass) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_filepath(regclass) is 'file path of relation';

create function pg_catalog.pg_relation_is_publishable(regclass) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_is_publishable(regclass) is 'returns whether a relation can be part of a publication';

create function pg_catalog.pg_relation_is_updatable(regclass, boolean) returns integer
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_is_updatable(regclass, boolean) is 'is a relation insertable/updatable/deletable';

create function pg_catalog.pg_relation_size(regclass) returns bigint
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_size(regclass) is 'disk space usage for the main fork of the specified table or index';

create function pg_catalog.pg_relation_size(regclass, text) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_size(regclass, text) is 'disk space usage for the specified fork of a table or index';

create function pg_catalog.pg_reload_conf() returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_reload_conf() is 'reload configuration files';

create function pg_catalog.pg_replication_origin_advance(text, pg_lsn) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_advance(text, pg_lsn) is 'advance replication origin to specific location';

create function pg_catalog.pg_replication_origin_create(text) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_create(text) is 'create a replication origin';

create function pg_catalog.pg_replication_origin_drop(text) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_drop(text) is 'drop replication origin identified by its name';

create function pg_catalog.pg_replication_origin_oid(text) returns oid
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_oid(text) is 'translate the replication origin''s name to its id';

create function pg_catalog.pg_replication_origin_progress(text, boolean) returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_progress(text, boolean) is 'get an individual replication origin''s replication progress';

create function pg_catalog.pg_replication_origin_session_is_setup() returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_is_setup() is 'is a replication origin configured in this session';

create function pg_catalog.pg_replication_origin_session_progress(boolean) returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_progress(boolean) is 'get the replication progress of the current session';

create function pg_catalog.pg_replication_origin_session_reset() returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_reset() is 'teardown configured replication progress tracking';

create function pg_catalog.pg_replication_origin_session_setup(text) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_setup(text) is 'configure session to maintain replication progress tracking for the passed in origin';

create function pg_catalog.pg_replication_origin_xact_reset() returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_xact_reset() is 'reset the transaction''s origin lsn and timestamp';

create function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone) is 'setup the transaction''s origin lsn and timestamp';

create function pg_catalog.pg_replication_slot_advance(slot_name name, upto_lsn pg_lsn, out slot_name name, out end_lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_slot_advance(name, pg_lsn, out name, out pg_lsn) is 'advance logical replication slot';

create function pg_catalog.pg_rotate_logfile() returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_rotate_logfile() is 'rotate log file';

create function pg_catalog.pg_rotate_logfile_old() returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_rotate_logfile_old() is 'rotate log file - old version for adminpack 1.0';

create function pg_catalog.pg_safe_snapshot_blocking_pids(integer) returns integer[]
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_safe_snapshot_blocking_pids(integer) is 'get array of PIDs of sessions blocking specified backend PID from acquiring a safe snapshot';

create function pg_catalog.pg_sequence_last_value(regclass) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sequence_last_value(regclass) is 'sequence last value';

create function pg_catalog.pg_sequence_parameters(sequence_oid oid, out start_value bigint, out minimum_value bigint, out maximum_value bigint, out increment bigint, out cycle_option boolean, out cache_size bigint, out data_type oid) returns record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sequence_parameters(oid, out bigint, out bigint, out bigint, out bigint, out boolean, out bigint, out oid) is 'sequence parameters, for use by information schema';

create function pg_catalog.pg_show_all_file_settings(out sourcefile text, out sourceline integer, out seqno integer, out name text, out setting text, out applied boolean, out error text) returns setof setof record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_show_all_file_settings(out text, out integer, out integer, out text, out text, out boolean, out text) is 'show config file settings';

create function pg_catalog.pg_show_all_settings(out name text, out setting text, out unit text, out category text, out short_desc text, out extra_desc text, out context text, out vartype text, out source text, out min_val text, out max_val text, out enumvals text[], out boot_val text, out reset_val text, out sourcefile text, out sourceline integer, out pending_restart boolean) returns setof setof record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_show_all_settings(out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text[], out text, out text, out text, out integer, out boolean) is 'SHOW ALL as a function';

create function pg_catalog.pg_show_replication_origin_status(out local_id oid, out external_id text, out remote_lsn pg_lsn, out local_lsn pg_lsn) returns setof setof record
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_show_replication_origin_status(out oid, out text, out pg_lsn, out pg_lsn) is 'get progress for all replication origins';

create function pg_catalog.pg_size_bytes(text) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_bytes(text) is 'convert a size in human-readable format with size units into bytes';

create function pg_catalog.pg_size_pretty(bigint) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_pretty(bigint) is 'convert a long int to a human readable text using size units';

create function pg_catalog.pg_size_pretty(numeric) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_pretty(numeric) is 'convert a numeric to a human readable text using size units';

create function pg_catalog.pg_sleep(double precision) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sleep(double precision) is 'sleep for the specified time in seconds';

create function pg_catalog.pg_sleep_for(interval) returns void
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sleep_for(interval) is 'sleep for the specified interval';

create function pg_catalog.pg_sleep_until(timestamp with time zone) returns void
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sleep_until(timestamp with time zone) is 'sleep until the specified time';

create function pg_catalog.pg_snapshot_in(cstring) returns pg_snapshot
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_in(cstring) is 'I/O';

create function pg_catalog.pg_snapshot_out(pg_snapshot) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_out(pg_snapshot) is 'I/O';

create function pg_catalog.pg_snapshot_recv(internal) returns pg_snapshot
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_recv(internal) is 'I/O';

create function pg_catalog.pg_snapshot_send(pg_snapshot) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_send(pg_snapshot) is 'I/O';

create function pg_catalog.pg_snapshot_xip(pg_snapshot) returns setof setof xid8
    immutable
    strict
    cost 1
    rows 50
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_snapshot_xip(pg_snapshot) is 'get set of in-progress transactions in snapshot';

create function pg_catalog.pg_snapshot_xmax(pg_snapshot) returns xid8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_xmax(pg_snapshot) is 'get xmax of snapshot';

create function pg_catalog.pg_snapshot_xmin(pg_snapshot) returns xid8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_xmin(pg_snapshot) is 'get xmin of snapshot';

create function pg_catalog.pg_start_backup(label text, fast boolean default false, exclusive boolean default true) returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_start_backup(text, boolean, boolean) is 'prepare for taking an online backup';

create function pg_catalog.pg_stat_clear_snapshot() returns void
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_clear_snapshot() is 'statistics: discard current transaction''s statistics snapshot';

create function pg_catalog.pg_stat_file(filename text, out size bigint, out access timestamp with time zone, out modification timestamp with time zone, out change timestamp with time zone, out creation timestamp with time zone, out isdir boolean) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_file(text, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean) is 'get information about file';

create function pg_catalog.pg_stat_file(filename text, missing_ok boolean, out size bigint, out access timestamp with time zone, out modification timestamp with time zone, out change timestamp with time zone, out creation timestamp with time zone, out isdir boolean) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_file(text, boolean, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean) is 'get information about file';

create function pg_catalog.pg_stat_get_activity(pid integer, out datid oid, out pid integer, out usesysid oid, out application_name text, out state text, out query text, out wait_event_type text, out wait_event text, out xact_start timestamp with time zone, out query_start timestamp with time zone, out backend_start timestamp with time zone, out state_change timestamp with time zone, out client_addr inet, out client_hostname text, out client_port integer, out backend_xid xid, out backend_xmin xid, out backend_type text, out ssl boolean, out sslversion text, out sslcipher text, out sslbits integer, out sslcompression boolean, out ssl_client_dn text, out ssl_client_serial numeric, out ssl_issuer_dn text, out gss_auth boolean, out gss_princ text, out gss_enc boolean, out leader_pid integer) returns setof setof record
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_activity(integer, out oid, out integer, out oid, out text, out text, out text, out text, out text, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out inet, out text, out integer, out xid, out xid, out text, out boolean, out text, out text, out integer, out boolean, out text, out numeric, out text, out boolean, out text, out boolean, out integer) is 'statistics: information about currently active backends';

create function pg_catalog.pg_stat_get_analyze_count(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_analyze_count(oid) is 'statistics: number of manual analyzes for a table';

create function pg_catalog.pg_stat_get_archiver(out archived_count bigint, out last_archived_wal text, out last_archived_time timestamp with time zone, out failed_count bigint, out last_failed_wal text, out last_failed_time timestamp with time zone, out stats_reset timestamp with time zone) returns record
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_archiver(out bigint, out text, out timestamp with time zone, out bigint, out text, out timestamp with time zone, out timestamp with time zone) is 'statistics: information about WAL archiver';

create function pg_catalog.pg_stat_get_autoanalyze_count(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_autoanalyze_count(oid) is 'statistics: number of auto analyzes for a table';

create function pg_catalog.pg_stat_get_autovacuum_count(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_autovacuum_count(oid) is 'statistics: number of auto vacuums for a table';

create function pg_catalog.pg_stat_get_backend_activity(integer) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_activity(integer) is 'statistics: current query of backend';

create function pg_catalog.pg_stat_get_backend_activity_start(integer) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_activity_start(integer) is 'statistics: start time for current query of backend';

create function pg_catalog.pg_stat_get_backend_client_addr(integer) returns inet
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_client_addr(integer) is 'statistics: address of client connected to backend';

create function pg_catalog.pg_stat_get_backend_client_port(integer) returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_client_port(integer) is 'statistics: port number of client connected to backend';

create function pg_catalog.pg_stat_get_backend_dbid(integer) returns oid
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_dbid(integer) is 'statistics: database ID of backend';

create function pg_catalog.pg_stat_get_backend_idset() returns setof setof integer
    stable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_backend_idset() is 'statistics: currently active backend IDs';

create function pg_catalog.pg_stat_get_backend_pid(integer) returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_pid(integer) is 'statistics: PID of backend';

create function pg_catalog.pg_stat_get_backend_start(integer) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_start(integer) is 'statistics: start time for current backend session';

create function pg_catalog.pg_stat_get_backend_userid(integer) returns oid
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_userid(integer) is 'statistics: user ID of backend';

create function pg_catalog.pg_stat_get_backend_wait_event(integer) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_wait_event(integer) is 'statistics: wait event on which backend is currently waiting';

create function pg_catalog.pg_stat_get_backend_wait_event_type(integer) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_wait_event_type(integer) is 'statistics: wait event type on which backend is currently waiting';

create function pg_catalog.pg_stat_get_backend_xact_start(integer) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_xact_start(integer) is 'statistics: start time for backend''s current transaction';

create function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() is 'statistics: number of buffers written by the bgwriter during checkpoints';

create function pg_catalog.pg_stat_get_bgwriter_buf_written_clean() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_clean() is 'statistics: number of buffers written by the bgwriter for cleaning dirty buffers';

create function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() is 'statistics: number of times the bgwriter stopped processing when it had written too many buffers while cleaning';

create function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() is 'statistics: number of backend requested checkpoints started by the bgwriter';

create function pg_catalog.pg_stat_get_bgwriter_stat_reset_time() returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_stat_reset_time() is 'statistics: last reset for the bgwriter';

create function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() is 'statistics: number of timed checkpoints started by the bgwriter';

create function pg_catalog.pg_stat_get_blocks_fetched(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_blocks_fetched(oid) is 'statistics: number of blocks fetched';

create function pg_catalog.pg_stat_get_blocks_hit(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_blocks_hit(oid) is 'statistics: number of blocks found in cache';

create function pg_catalog.pg_stat_get_buf_alloc() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_alloc() is 'statistics: number of buffer allocations';

create function pg_catalog.pg_stat_get_buf_fsync_backend() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_fsync_backend() is 'statistics: number of backend buffer writes that did their own fsync';

create function pg_catalog.pg_stat_get_buf_written_backend() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_written_backend() is 'statistics: number of buffers written by backends';

create function pg_catalog.pg_stat_get_checkpoint_sync_time() returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_checkpoint_sync_time() is 'statistics: checkpoint time spent synchronizing buffers to disk, in milliseconds';

create function pg_catalog.pg_stat_get_checkpoint_write_time() returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_checkpoint_write_time() is 'statistics: checkpoint time spent writing buffers to disk, in milliseconds';

create function pg_catalog.pg_stat_get_db_blk_read_time(oid) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blk_read_time(oid) is 'statistics: block read time, in milliseconds';

create function pg_catalog.pg_stat_get_db_blk_write_time(oid) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blk_write_time(oid) is 'statistics: block write time, in milliseconds';

create function pg_catalog.pg_stat_get_db_blocks_fetched(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blocks_fetched(oid) is 'statistics: blocks fetched for database';

create function pg_catalog.pg_stat_get_db_blocks_hit(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blocks_hit(oid) is 'statistics: blocks found in cache for database';

create function pg_catalog.pg_stat_get_db_checksum_failures(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_checksum_failures(oid) is 'statistics: checksum failures detected in database';

create function pg_catalog.pg_stat_get_db_checksum_last_failure(oid) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_checksum_last_failure(oid) is 'statistics: when last checksum failure was detected in database';

create function pg_catalog.pg_stat_get_db_conflict_all(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_all(oid) is 'statistics: recovery conflicts in database';

create function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid) is 'statistics: recovery conflicts in database caused by shared buffer pin';

create function pg_catalog.pg_stat_get_db_conflict_lock(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_lock(oid) is 'statistics: recovery conflicts in database caused by relation lock';

create function pg_catalog.pg_stat_get_db_conflict_snapshot(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_snapshot(oid) is 'statistics: recovery conflicts in database caused by snapshot expiry';

create function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid) is 'statistics: recovery conflicts in database caused by buffer deadlock';

create function pg_catalog.pg_stat_get_db_conflict_tablespace(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_tablespace(oid) is 'statistics: recovery conflicts in database caused by drop tablespace';

create function pg_catalog.pg_stat_get_db_deadlocks(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_deadlocks(oid) is 'statistics: deadlocks detected in database';

create function pg_catalog.pg_stat_get_db_numbackends(oid) returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_numbackends(oid) is 'statistics: number of backends in database';

create function pg_catalog.pg_stat_get_db_stat_reset_time(oid) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_stat_reset_time(oid) is 'statistics: last reset for a database';

create function pg_catalog.pg_stat_get_db_temp_bytes(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_temp_bytes(oid) is 'statistics: number of bytes in temporary files written';

create function pg_catalog.pg_stat_get_db_temp_files(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_temp_files(oid) is 'statistics: number of temporary files written';

create function pg_catalog.pg_stat_get_db_tuples_deleted(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_deleted(oid) is 'statistics: tuples deleted in database';

create function pg_catalog.pg_stat_get_db_tuples_fetched(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_fetched(oid) is 'statistics: tuples fetched for database';

create function pg_catalog.pg_stat_get_db_tuples_inserted(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_inserted(oid) is 'statistics: tuples inserted in database';

create function pg_catalog.pg_stat_get_db_tuples_returned(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_returned(oid) is 'statistics: tuples returned for database';

create function pg_catalog.pg_stat_get_db_tuples_updated(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_updated(oid) is 'statistics: tuples updated in database';

create function pg_catalog.pg_stat_get_db_xact_commit(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_xact_commit(oid) is 'statistics: transactions committed';

create function pg_catalog.pg_stat_get_db_xact_rollback(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_xact_rollback(oid) is 'statistics: transactions rolled back';

create function pg_catalog.pg_stat_get_dead_tuples(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_dead_tuples(oid) is 'statistics: number of dead tuples';

create function pg_catalog.pg_stat_get_function_calls(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_calls(oid) is 'statistics: number of function calls';

create function pg_catalog.pg_stat_get_function_self_time(oid) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_self_time(oid) is 'statistics: self execution time of function, in milliseconds';

create function pg_catalog.pg_stat_get_function_total_time(oid) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_total_time(oid) is 'statistics: total execution time of function, in milliseconds';

create function pg_catalog.pg_stat_get_ins_since_vacuum(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_ins_since_vacuum(oid) is 'statistics: number of tuples inserted since last vacuum';

create function pg_catalog.pg_stat_get_last_analyze_time(oid) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_analyze_time(oid) is 'statistics: last manual analyze time for a table';

create function pg_catalog.pg_stat_get_last_autoanalyze_time(oid) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_autoanalyze_time(oid) is 'statistics: last auto analyze time for a table';

create function pg_catalog.pg_stat_get_last_autovacuum_time(oid) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_autovacuum_time(oid) is 'statistics: last auto vacuum time for a table';

create function pg_catalog.pg_stat_get_last_vacuum_time(oid) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_vacuum_time(oid) is 'statistics: last manual vacuum time for a table';

create function pg_catalog.pg_stat_get_live_tuples(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_live_tuples(oid) is 'statistics: number of live tuples';

create function pg_catalog.pg_stat_get_mod_since_analyze(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_mod_since_analyze(oid) is 'statistics: number of tuples changed since last analyze';

create function pg_catalog.pg_stat_get_numscans(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_numscans(oid) is 'statistics: number of scans done for table/index';

create function pg_catalog.pg_stat_get_progress_info(cmdtype text, out pid integer, out datid oid, out relid oid, out param1 bigint, out param2 bigint, out param3 bigint, out param4 bigint, out param5 bigint, out param6 bigint, out param7 bigint, out param8 bigint, out param9 bigint, out param10 bigint, out param11 bigint, out param12 bigint, out param13 bigint, out param14 bigint, out param15 bigint, out param16 bigint, out param17 bigint, out param18 bigint, out param19 bigint, out param20 bigint) returns setof setof record
    stable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_progress_info(text, out integer, out oid, out oid, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint) is 'statistics: information about progress of backends running maintenance command';

create function pg_catalog.pg_stat_get_slru(out name text, out blks_zeroed bigint, out blks_hit bigint, out blks_read bigint, out blks_written bigint, out blks_exists bigint, out flushes bigint, out truncates bigint, out stats_reset timestamp with time zone) returns setof setof record
    stable
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_slru(out text, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out timestamp with time zone) is 'statistics: information about SLRU caches';

create function pg_catalog.pg_stat_get_snapshot_timestamp() returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_snapshot_timestamp() is 'statistics: timestamp of the current statistics snapshot';

create function pg_catalog.pg_stat_get_subscription(subid oid, out subid oid, out relid oid, out pid integer, out received_lsn pg_lsn, out last_msg_send_time timestamp with time zone, out last_msg_receipt_time timestamp with time zone, out latest_end_lsn pg_lsn, out latest_end_time timestamp with time zone) returns record
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_subscription(oid, out oid, out oid, out integer, out pg_lsn, out timestamp with time zone, out timestamp with time zone, out pg_lsn, out timestamp with time zone) is 'statistics: information about subscription';

create function pg_catalog.pg_stat_get_tuples_deleted(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_deleted(oid) is 'statistics: number of tuples deleted';

create function pg_catalog.pg_stat_get_tuples_fetched(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_fetched(oid) is 'statistics: number of tuples fetched by idxscan';

create function pg_catalog.pg_stat_get_tuples_hot_updated(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_hot_updated(oid) is 'statistics: number of tuples hot updated';

create function pg_catalog.pg_stat_get_tuples_inserted(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_inserted(oid) is 'statistics: number of tuples inserted';

create function pg_catalog.pg_stat_get_tuples_returned(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_returned(oid) is 'statistics: number of tuples read by seqscan';

create function pg_catalog.pg_stat_get_tuples_updated(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_updated(oid) is 'statistics: number of tuples updated';

create function pg_catalog.pg_stat_get_vacuum_count(oid) returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_vacuum_count(oid) is 'statistics: number of manual vacuums for a table';

create function pg_catalog.pg_stat_get_wal_receiver(out pid integer, out status text, out receive_start_lsn pg_lsn, out receive_start_tli integer, out written_lsn pg_lsn, out flushed_lsn pg_lsn, out received_tli integer, out last_msg_send_time timestamp with time zone, out last_msg_receipt_time timestamp with time zone, out latest_end_lsn pg_lsn, out latest_end_time timestamp with time zone, out slot_name text, out sender_host text, out sender_port integer, out conninfo text) returns record
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_wal_receiver(out integer, out text, out pg_lsn, out integer, out pg_lsn, out pg_lsn, out integer, out timestamp with time zone, out timestamp with time zone, out pg_lsn, out timestamp with time zone, out text, out text, out integer, out text) is 'statistics: information about WAL receiver';

create function pg_catalog.pg_stat_get_wal_senders(out pid integer, out state text, out sent_lsn pg_lsn, out write_lsn pg_lsn, out flush_lsn pg_lsn, out replay_lsn pg_lsn, out write_lag interval, out flush_lag interval, out replay_lag interval, out sync_priority integer, out sync_state text, out reply_time timestamp with time zone) returns setof setof record
    stable
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_wal_senders(out integer, out text, out pg_lsn, out pg_lsn, out pg_lsn, out pg_lsn, out interval, out interval, out interval, out integer, out text, out timestamp with time zone) is 'statistics: information about currently active replication';

create function pg_catalog.pg_stat_get_xact_blocks_fetched(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_blocks_fetched(oid) is 'statistics: number of blocks fetched in current transaction';

create function pg_catalog.pg_stat_get_xact_blocks_hit(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_blocks_hit(oid) is 'statistics: number of blocks found in cache in current transaction';

create function pg_catalog.pg_stat_get_xact_function_calls(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_calls(oid) is 'statistics: number of function calls in current transaction';

create function pg_catalog.pg_stat_get_xact_function_self_time(oid) returns double precision
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_self_time(oid) is 'statistics: self execution time of function in current transaction, in milliseconds';

create function pg_catalog.pg_stat_get_xact_function_total_time(oid) returns double precision
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_total_time(oid) is 'statistics: total execution time of function in current transaction, in milliseconds';

create function pg_catalog.pg_stat_get_xact_numscans(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_numscans(oid) is 'statistics: number of scans done for table/index in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_deleted(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_deleted(oid) is 'statistics: number of tuples deleted in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_fetched(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_fetched(oid) is 'statistics: number of tuples fetched by idxscan in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid) is 'statistics: number of tuples hot updated in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_inserted(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_inserted(oid) is 'statistics: number of tuples inserted in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_returned(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_returned(oid) is 'statistics: number of tuples read by seqscan in current transaction';

create function pg_catalog.pg_stat_get_xact_tuples_updated(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_updated(oid) is 'statistics: number of tuples updated in current transaction';

create function pg_catalog.pg_stat_reset() returns void
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset() is 'statistics: reset collected statistics for current database';

create function pg_catalog.pg_stat_reset_shared(text) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_shared(text) is 'statistics: reset collected statistics shared across the cluster';

create function pg_catalog.pg_stat_reset_single_function_counters(oid) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_single_function_counters(oid) is 'statistics: reset collected statistics for a single function in the current database';

create function pg_catalog.pg_stat_reset_single_table_counters(oid) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_single_table_counters(oid) is 'statistics: reset collected statistics for a single table or index in the current database';

create function pg_catalog.pg_stat_reset_slru(text) returns void
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_slru(text) is 'statistics: reset collected statistics for a single SLRU';

create function pg_catalog.pg_statistics_obj_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_statistics_obj_is_visible(oid) is 'is statistics object visible in search path?';

create function pg_catalog.pg_stop_backup() returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stop_backup() is 'finish taking an online backup';

create function pg_catalog.pg_stop_backup(exclusive boolean, wait_for_archive boolean default true, out lsn pg_lsn, out labelfile text, out spcmapfile text) returns setof setof record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stop_backup(boolean, boolean, out pg_lsn, out text, out text) is 'finish taking an online backup';

create function pg_catalog.pg_switch_wal() returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_switch_wal() is 'switch to new wal file';

create function pg_catalog.pg_table_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_table_is_visible(oid) is 'is table visible in search path?';

create function pg_catalog.pg_table_size(regclass) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_table_size(regclass) is 'disk space usage for the specified table, including TOAST, free space and visibility map';

create function pg_catalog.pg_tablespace_databases(oid) returns setof setof oid
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_tablespace_databases(oid) is 'get OIDs of databases in a tablespace';

create function pg_catalog.pg_tablespace_location(oid) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_location(oid) is 'tablespace location';

create function pg_catalog.pg_tablespace_size(name) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_size(name) is 'total disk space usage for the specified tablespace';

create function pg_catalog.pg_tablespace_size(oid) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_size(oid) is 'total disk space usage for the specified tablespace';

create function pg_catalog.pg_terminate_backend(integer) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_terminate_backend(integer) is 'terminate a server process';

create function pg_catalog.pg_timezone_abbrevs(out abbrev text, out utc_offset interval, out is_dst boolean) returns setof setof record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_timezone_abbrevs(out text, out interval, out boolean) is 'get the available time zone abbreviations';

create function pg_catalog.pg_timezone_names(out name text, out abbrev text, out utc_offset interval, out is_dst boolean) returns setof setof record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_timezone_names(out text, out text, out interval, out boolean) is 'get the available time zone names';

create function pg_catalog.pg_total_relation_size(regclass) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_total_relation_size(regclass) is 'total disk space usage for the specified table and associated indexes';

create function pg_catalog.pg_trigger_depth() returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_trigger_depth() is 'current trigger depth';

create function pg_catalog.pg_try_advisory_lock(bigint) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock(bigint) is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_lock(integer, integer) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock(integer, integer) is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_lock_shared(bigint) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock_shared(bigint) is 'obtain shared advisory lock if available';

create function pg_catalog.pg_try_advisory_lock_shared(integer, integer) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock_shared(integer, integer) is 'obtain shared advisory lock if available';

create function pg_catalog.pg_try_advisory_xact_lock(bigint) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock(bigint) is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_xact_lock(integer, integer) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock(integer, integer) is 'obtain exclusive advisory lock if available';

create function pg_catalog.pg_try_advisory_xact_lock_shared(bigint) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(bigint) is 'obtain shared advisory lock if available';

create function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer) returns boolean
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer) is 'obtain shared advisory lock if available';

create function pg_catalog.pg_ts_config_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_config_is_visible(oid) is 'is text search configuration visible in search path?';

create function pg_catalog.pg_ts_dict_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_dict_is_visible(oid) is 'is text search dictionary visible in search path?';

create function pg_catalog.pg_ts_parser_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_parser_is_visible(oid) is 'is text search parser visible in search path?';

create function pg_catalog.pg_ts_template_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_template_is_visible(oid) is 'is text search template visible in search path?';

create function pg_catalog.pg_type_is_visible(oid) returns boolean
    stable
    strict
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_type_is_visible(oid) is 'is type visible in search path?';

create function pg_catalog.pg_typeof("any") returns regtype
    stable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_typeof("any") is 'type of the argument';

create function pg_catalog.pg_visible_in_snapshot(xid8, pg_snapshot) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_visible_in_snapshot(xid8, pg_snapshot) is 'is xid8 visible in snapshot?';

create function pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn) is 'difference in bytes, given two wal locations';

create function pg_catalog.pg_wal_replay_pause() returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_replay_pause() is 'pause wal replay';

create function pg_catalog.pg_wal_replay_resume() returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_replay_resume() is 'resume wal replay, if it was paused';

create function pg_catalog.pg_walfile_name(pg_lsn) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_walfile_name(pg_lsn) is 'wal filename, given a wal location';

create function pg_catalog.pg_walfile_name_offset(lsn pg_lsn, out file_name text, out file_offset integer) returns record
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_walfile_name_offset(pg_lsn, out text, out integer) is 'wal filename and byte offset, given a wal location';

create function pg_catalog.pg_xact_commit_timestamp(xid) returns timestamp with time zone
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_xact_commit_timestamp(xid) is 'get commit timestamp of a transaction';

create function pg_catalog.pg_xact_status(xid8) returns text
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_xact_status(xid8) is 'commit status of transaction';

create function pg_catalog.phraseto_tsquery(regconfig, text) returns tsquery
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.phraseto_tsquery(regconfig, text) is 'transform to tsquery';

create function pg_catalog.phraseto_tsquery(text) returns tsquery
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.phraseto_tsquery(text) is 'transform to tsquery';

create function pg_catalog.pi() returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pi() is 'PI';

create function pg_catalog.plainto_tsquery(regconfig, text) returns tsquery
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.plainto_tsquery(regconfig, text) is 'transform to tsquery';

create function pg_catalog.plainto_tsquery(text) returns tsquery
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.plainto_tsquery(text) is 'transform to tsquery';

create function pg_catalog.plpgsql_call_handler() returns language_handler
    language c
    as
$$
begin
-- missing source code
end;
$$;

create function pg_catalog.plpgsql_inline_handler(internal) returns void
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

create function pg_catalog.plpgsql_validator(oid) returns void
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

create function pg_catalog.point(box) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(box) is 'center of';

create function pg_catalog.point(circle) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(circle) is 'center of';

create function pg_catalog.point(double precision, double precision) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(double precision, double precision) is 'convert x, y to point';

create function pg_catalog.point(lseg) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(lseg) is 'center of';

create function pg_catalog.point(path) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(path) is 'center of';

create function pg_catalog.point(polygon) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(polygon) is 'center of';

create function pg_catalog.point_above(point, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_above(point, point) is 'implementation of >^ operator';

create function pg_catalog.point_add(point, point) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_add(point, point) is 'implementation of + operator';

create function pg_catalog.point_below(point, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_below(point, point) is 'implementation of <^ operator';

create function pg_catalog.point_distance(point, point) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_distance(point, point) is 'implementation of <-> operator';

create function pg_catalog.point_div(point, point) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_div(point, point) is 'implementation of / operator';

create function pg_catalog.point_eq(point, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_eq(point, point) is 'implementation of ~= operator';

create function pg_catalog.point_horiz(point, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_horiz(point, point) is 'implementation of ?- operator';

create function pg_catalog.point_in(cstring) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_in(cstring) is 'I/O';

create function pg_catalog.point_left(point, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_left(point, point) is 'implementation of << operator';

create function pg_catalog.point_mul(point, point) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_mul(point, point) is 'implementation of * operator';

create function pg_catalog.point_ne(point, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_ne(point, point) is 'implementation of <> operator';

create function pg_catalog.point_out(point) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_out(point) is 'I/O';

create function pg_catalog.point_recv(internal) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_recv(internal) is 'I/O';

create function pg_catalog.point_right(point, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_right(point, point) is 'implementation of >> operator';

create function pg_catalog.point_send(point) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_send(point) is 'I/O';

create function pg_catalog.point_sub(point, point) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_sub(point, point) is 'implementation of - operator';

create function pg_catalog.point_vert(point, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_vert(point, point) is 'implementation of ?| operator';

create function pg_catalog.poly_above(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_above(polygon, polygon) is 'implementation of |>> operator';

create function pg_catalog.poly_below(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_below(polygon, polygon) is 'implementation of <<| operator';

create function pg_catalog.poly_center(polygon) returns point
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_center(polygon) is 'implementation of @@ operator';

create function pg_catalog.poly_contain(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contain(polygon, polygon) is 'implementation of @> operator';

create function pg_catalog.poly_contain_pt(polygon, point) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contain_pt(polygon, point) is 'implementation of @> operator';

create function pg_catalog.poly_contained(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contained(polygon, polygon) is 'implementation of <@ operator';

create function pg_catalog.poly_distance(polygon, polygon) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_distance(polygon, polygon) is 'implementation of <-> operator';

create function pg_catalog.poly_in(cstring) returns polygon
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_in(cstring) is 'I/O';

create function pg_catalog.poly_left(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_left(polygon, polygon) is 'implementation of << operator';

create function pg_catalog.poly_npoints(polygon) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_npoints(polygon) is 'implementation of # operator';

create function pg_catalog.poly_out(polygon) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_out(polygon) is 'I/O';

create function pg_catalog.poly_overabove(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overabove(polygon, polygon) is 'implementation of |&> operator';

create function pg_catalog.poly_overbelow(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overbelow(polygon, polygon) is 'implementation of &<| operator';

create function pg_catalog.poly_overlap(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overlap(polygon, polygon) is 'implementation of && operator';

create function pg_catalog.poly_overleft(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overleft(polygon, polygon) is 'implementation of &< operator';

create function pg_catalog.poly_overright(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overright(polygon, polygon) is 'implementation of &> operator';

create function pg_catalog.poly_recv(internal) returns polygon
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_recv(internal) is 'I/O';

create function pg_catalog.poly_right(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_right(polygon, polygon) is 'implementation of >> operator';

create function pg_catalog.poly_same(polygon, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_same(polygon, polygon) is 'implementation of ~= operator';

create function pg_catalog.poly_send(polygon) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_send(polygon) is 'I/O';

create function pg_catalog.polygon(box) returns polygon
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(box) is 'convert box to polygon';

create function pg_catalog.polygon(circle) returns polygon
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(circle) is 'convert circle to 12-vertex polygon';

create function pg_catalog.polygon(integer, circle) returns polygon
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(integer, circle) is 'convert vertex count and circle to polygon';

create function pg_catalog.polygon(path) returns polygon
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(path) is 'convert path to polygon';

create function pg_catalog.popen(path) returns path
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.popen(path) is 'open path';

create function pg_catalog.position(bit, bit) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(bit, bit) is 'position of sub-bitstring';

create function pg_catalog.position(bytea, bytea) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(bytea, bytea) is 'position of substring';

create function pg_catalog.position(text, text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(text, text) is 'position of substring';

create function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for position-comparison operators';

create function pg_catalog.positionsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.positionsel(internal, oid, internal, integer) is 'restriction selectivity for position-comparison operators';

create function pg_catalog.postgresql_fdw_validator(text[], oid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.postgresql_fdw_validator(text[], oid) is '(internal)';

create function pg_catalog.pow(double precision, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pow(double precision, double precision) is 'exponentiation';

create function pg_catalog.pow(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pow(numeric, numeric) is 'exponentiation';

create function pg_catalog.power(double precision, double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.power(double precision, double precision) is 'exponentiation';

create function pg_catalog.power(numeric, numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.power(numeric, numeric) is 'exponentiation';

create function pg_catalog.prefixjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prefixjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of exact prefix';

create function pg_catalog.prefixsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prefixsel(internal, oid, internal, integer) is 'restriction selectivity of exact prefix';

create function pg_catalog.prsd_end(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_end(internal) is '(internal)';

create function pg_catalog.prsd_headline(internal, internal, tsquery) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_headline(internal, internal, tsquery) is '(internal)';

create function pg_catalog.prsd_lextype(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_lextype(internal) is '(internal)';

create function pg_catalog.prsd_nexttoken(internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_nexttoken(internal, internal, internal) is '(internal)';

create function pg_catalog.prsd_start(internal, integer) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_start(internal, integer) is '(internal)';

create function pg_catalog.pt_contained_circle(point, circle) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pt_contained_circle(point, circle) is 'implementation of <@ operator';

create function pg_catalog.pt_contained_poly(point, polygon) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pt_contained_poly(point, polygon) is 'implementation of <@ operator';

create function pg_catalog.query_to_xml(query text, nulls boolean, tableforest boolean, targetns text) returns xml
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xml(text, boolean, boolean, text) is 'map query result to XML';

create function pg_catalog.query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text) returns xml
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xml_and_xmlschema(text, boolean, boolean, text) is 'map query result and structure to XML and XML Schema';

create function pg_catalog.query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text) returns xml
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xmlschema(text, boolean, boolean, text) is 'map query result structure to XML Schema';

create function pg_catalog.querytree(tsquery) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.querytree(tsquery) is 'show real useful query for GiST index';

create function pg_catalog.quote_ident(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_ident(text) is 'quote an identifier for usage in a querystring';

create function pg_catalog.quote_literal(anyelement) returns text
    stable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_literal(anyelement) is 'quote a data value for usage in a querystring';

create function pg_catalog.quote_literal(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_literal(text) is 'quote a literal for usage in a querystring';

create function pg_catalog.quote_nullable(anyelement) returns text
    stable
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_nullable(anyelement) is 'quote a possibly-null data value for usage in a querystring';

create function pg_catalog.quote_nullable(text) returns text
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_nullable(text) is 'quote a possibly-null literal for usage in a querystring';

create function pg_catalog.radians(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.radians(double precision) is 'degrees to radians';

create function pg_catalog.radius(circle) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.radius(circle) is 'radius of circle';

create function pg_catalog.random() returns double precision
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.random() is 'random value';

create function pg_catalog.range_adjacent(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_adjacent(anyrange, anyrange) is 'implementation of -|- operator';

create function pg_catalog.range_after(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_after(anyrange, anyrange) is 'implementation of >> operator';

create function pg_catalog.range_before(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_before(anyrange, anyrange) is 'implementation of << operator';

create function pg_catalog.range_cmp(anyrange, anyrange) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_cmp(anyrange, anyrange) is 'less-equal-greater';

create function pg_catalog.range_contained_by(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contained_by(anyrange, anyrange) is 'implementation of <@ operator';

create function pg_catalog.range_contains(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contains(anyrange, anyrange) is 'implementation of @> operator';

create function pg_catalog.range_contains_elem(anyrange, anyelement) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contains_elem(anyrange, anyelement) is 'implementation of @> operator';

create function pg_catalog.range_eq(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_eq(anyrange, anyrange) is 'implementation of = operator';

create function pg_catalog.range_ge(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_ge(anyrange, anyrange) is 'implementation of >= operator';

create function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal) is 'GiST support';

create function pg_catalog.range_gist_penalty(internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_penalty(internal, internal, internal) is 'GiST support';

create function pg_catalog.range_gist_picksplit(internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_picksplit(internal, internal) is 'GiST support';

create function pg_catalog.range_gist_same(anyrange, anyrange, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_same(anyrange, anyrange, internal) is 'GiST support';

create function pg_catalog.range_gist_union(internal, internal) returns anyrange
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_union(internal, internal) is 'GiST support';

create function pg_catalog.range_gt(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gt(anyrange, anyrange) is 'implementation of > operator';

create function pg_catalog.range_in(cstring, oid, integer) returns anyrange
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.range_intersect(anyrange, anyrange) returns anyrange
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_intersect(anyrange, anyrange) is 'implementation of * operator';

create function pg_catalog.range_le(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_le(anyrange, anyrange) is 'implementation of <= operator';

create function pg_catalog.range_lt(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_lt(anyrange, anyrange) is 'implementation of < operator';

create function pg_catalog.range_merge(anyrange, anyrange) returns anyrange
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_merge(anyrange, anyrange) is 'the smallest range which includes both of the given ranges';

create function pg_catalog.range_minus(anyrange, anyrange) returns anyrange
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_minus(anyrange, anyrange) is 'implementation of - operator';

create function pg_catalog.range_ne(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_ne(anyrange, anyrange) is 'implementation of <> operator';

create function pg_catalog.range_out(anyrange) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_out(anyrange) is 'I/O';

create function pg_catalog.range_overlaps(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overlaps(anyrange, anyrange) is 'implementation of && operator';

create function pg_catalog.range_overleft(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overleft(anyrange, anyrange) is 'implementation of &< operator';

create function pg_catalog.range_overright(anyrange, anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overright(anyrange, anyrange) is 'implementation of &> operator';

create function pg_catalog.range_recv(internal, oid, integer) returns anyrange
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.range_send(anyrange) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_send(anyrange) is 'I/O';

create function pg_catalog.range_typanalyze(internal) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_typanalyze(internal) is 'range typanalyze';

create function pg_catalog.range_union(anyrange, anyrange) returns anyrange
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_union(anyrange, anyrange) is 'implementation of + operator';

create function pg_catalog.rangesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rangesel(internal, oid, internal, integer) is 'restriction selectivity for range operators';

create function pg_catalog.rank() returns bigint
    immutable
    window
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rank() is 'integer rank with gaps';

create function pg_catalog.rank_final(internal, "any") returns bigint
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rank_final(internal, "any") is 'aggregate final function';

create function pg_catalog.record_eq(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_eq(record, record) is 'implementation of = operator';

create function pg_catalog.record_ge(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_ge(record, record) is 'implementation of >= operator';

create function pg_catalog.record_gt(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_gt(record, record) is 'implementation of > operator';

create function pg_catalog.record_image_eq(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_eq(record, record) is 'implementation of *= operator';

create function pg_catalog.record_image_ge(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_ge(record, record) is 'implementation of *>= operator';

create function pg_catalog.record_image_gt(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_gt(record, record) is 'implementation of *> operator';

create function pg_catalog.record_image_le(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_le(record, record) is 'implementation of *<= operator';

create function pg_catalog.record_image_lt(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_lt(record, record) is 'implementation of *< operator';

create function pg_catalog.record_image_ne(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_ne(record, record) is 'implementation of *<> operator';

create function pg_catalog.record_in(cstring, oid, integer) returns record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.record_le(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_le(record, record) is 'implementation of <= operator';

create function pg_catalog.record_lt(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_lt(record, record) is 'implementation of < operator';

create function pg_catalog.record_ne(record, record) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_ne(record, record) is 'implementation of <> operator';

create function pg_catalog.record_out(record) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_out(record) is 'I/O';

create function pg_catalog.record_recv(internal, oid, integer) returns record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.record_send(record) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_send(record) is 'I/O';

create function pg_catalog.regclass(text) returns regclass
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclass(text) is 'convert text to regclass';

create function pg_catalog.regclassin(cstring) returns regclass
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassin(cstring) is 'I/O';

create function pg_catalog.regclassout(regclass) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassout(regclass) is 'I/O';

create function pg_catalog.regclassrecv(internal) returns regclass
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassrecv(internal) is 'I/O';

create function pg_catalog.regclasssend(regclass) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclasssend(regclass) is 'I/O';

create function pg_catalog.regcollationin(cstring) returns regcollation
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationin(cstring) is 'I/O';

create function pg_catalog.regcollationout(regcollation) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationout(regcollation) is 'I/O';

create function pg_catalog.regcollationrecv(internal) returns regcollation
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationrecv(internal) is 'I/O';

create function pg_catalog.regcollationsend(regcollation) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationsend(regcollation) is 'I/O';

create function pg_catalog.regconfigin(cstring) returns regconfig
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigin(cstring) is 'I/O';

create function pg_catalog.regconfigout(regconfig) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigout(regconfig) is 'I/O';

create function pg_catalog.regconfigrecv(internal) returns regconfig
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigrecv(internal) is 'I/O';

create function pg_catalog.regconfigsend(regconfig) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigsend(regconfig) is 'I/O';

create function pg_catalog.regdictionaryin(cstring) returns regdictionary
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryin(cstring) is 'I/O';

create function pg_catalog.regdictionaryout(regdictionary) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryout(regdictionary) is 'I/O';

create function pg_catalog.regdictionaryrecv(internal) returns regdictionary
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryrecv(internal) is 'I/O';

create function pg_catalog.regdictionarysend(regdictionary) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionarysend(regdictionary) is 'I/O';

create function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of regex match';

create function pg_catalog.regexeqsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexeqsel(internal, oid, internal, integer) is 'restriction selectivity of regex match';

create function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of regex non-match';

create function pg_catalog.regexnesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexnesel(internal, oid, internal, integer) is 'restriction selectivity of regex non-match';

create function pg_catalog.regexp_match(text, text) returns text[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_match(text, text) is 'find first match for regexp';

create function pg_catalog.regexp_match(text, text, text) returns text[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_match(text, text, text) is 'find first match for regexp';

create function pg_catalog.regexp_matches(text, text) returns setof setof text[]
    immutable
    strict
    cost 1
    rows 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.regexp_matches(text, text) is 'find match(es) for regexp';

create function pg_catalog.regexp_matches(text, text, text) returns setof setof text[]
    immutable
    strict
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.regexp_matches(text, text, text) is 'find match(es) for regexp';

create function pg_catalog.regexp_replace(text, text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_replace(text, text, text) is 'replace text using regexp';

create function pg_catalog.regexp_replace(text, text, text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_replace(text, text, text, text) is 'replace text using regexp';

create function pg_catalog.regexp_split_to_array(text, text) returns text[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_array(text, text) is 'split string by pattern';

create function pg_catalog.regexp_split_to_array(text, text, text) returns text[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_array(text, text, text) is 'split string by pattern';

create function pg_catalog.regexp_split_to_table(text, text) returns setof setof text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.regexp_split_to_table(text, text) is 'split string by pattern';

create function pg_catalog.regexp_split_to_table(text, text, text) returns setof setof text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.regexp_split_to_table(text, text, text) is 'split string by pattern';

create function pg_catalog.regnamespacein(cstring) returns regnamespace
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacein(cstring) is 'I/O';

create function pg_catalog.regnamespaceout(regnamespace) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespaceout(regnamespace) is 'I/O';

create function pg_catalog.regnamespacerecv(internal) returns regnamespace
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacerecv(internal) is 'I/O';

create function pg_catalog.regnamespacesend(regnamespace) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacesend(regnamespace) is 'I/O';

create function pg_catalog.regoperatorin(cstring) returns regoperator
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorin(cstring) is 'I/O';

create function pg_catalog.regoperatorout(regoperator) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorout(regoperator) is 'I/O';

create function pg_catalog.regoperatorrecv(internal) returns regoperator
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorrecv(internal) is 'I/O';

create function pg_catalog.regoperatorsend(regoperator) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorsend(regoperator) is 'I/O';

create function pg_catalog.regoperin(cstring) returns regoper
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperin(cstring) is 'I/O';

create function pg_catalog.regoperout(regoper) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperout(regoper) is 'I/O';

create function pg_catalog.regoperrecv(internal) returns regoper
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperrecv(internal) is 'I/O';

create function pg_catalog.regopersend(regoper) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regopersend(regoper) is 'I/O';

create function pg_catalog.regprocedurein(cstring) returns regprocedure
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedurein(cstring) is 'I/O';

create function pg_catalog.regprocedureout(regprocedure) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedureout(regprocedure) is 'I/O';

create function pg_catalog.regprocedurerecv(internal) returns regprocedure
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedurerecv(internal) is 'I/O';

create function pg_catalog.regproceduresend(regprocedure) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regproceduresend(regprocedure) is 'I/O';

create function pg_catalog.regprocin(cstring) returns regproc
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocin(cstring) is 'I/O';

create function pg_catalog.regprocout(regproc) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocout(regproc) is 'I/O';

create function pg_catalog.regprocrecv(internal) returns regproc
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocrecv(internal) is 'I/O';

create function pg_catalog.regprocsend(regproc) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocsend(regproc) is 'I/O';

create function pg_catalog.regrolein(cstring) returns regrole
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolein(cstring) is 'I/O';

create function pg_catalog.regroleout(regrole) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regroleout(regrole) is 'I/O';

create function pg_catalog.regrolerecv(internal) returns regrole
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolerecv(internal) is 'I/O';

create function pg_catalog.regrolesend(regrole) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolesend(regrole) is 'I/O';

create function pg_catalog.regtypein(cstring) returns regtype
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypein(cstring) is 'I/O';

create function pg_catalog.regtypeout(regtype) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypeout(regtype) is 'I/O';

create function pg_catalog.regtyperecv(internal) returns regtype
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtyperecv(internal) is 'I/O';

create function pg_catalog.regtypesend(regtype) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypesend(regtype) is 'I/O';

create function pg_catalog.repeat(text, integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.repeat(text, integer) is 'replicate string n times';

create function pg_catalog.replace(text, text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.replace(text, text, text) is 'replace all occurrences in string of old_substr with new_substr';

create function pg_catalog.reverse(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.reverse(text) is 'reverse text';

create function pg_catalog."right"(text, integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."right"(text, integer) is 'extract the last n characters';

create function pg_catalog.round(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.round(double precision) is 'round to nearest integer';

create function pg_catalog.round(numeric) returns numeric
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.round(numeric) is 'value rounded to ''scale'' of zero';

create function pg_catalog.round(numeric, integer) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.round(numeric, integer) is 'value rounded to ''scale''';

create function pg_catalog.row_number() returns bigint
    immutable
    window
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_number() is 'row number within partition';

create function pg_catalog.row_security_active(oid) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_security_active(oid) is 'row security for current context active on table by table oid';

create function pg_catalog.row_security_active(text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_security_active(text) is 'row security for current context active on table by table name';

create function pg_catalog.row_to_json(record) returns json
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_to_json(record) is 'map row to json';

create function pg_catalog.row_to_json(record, boolean) returns json
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_to_json(record, boolean) is 'map row to json with optional pretty printing';

create function pg_catalog.rpad(text, integer) returns text
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rpad(text, integer) is 'right-pad string to length';

create function pg_catalog.rpad(text, integer, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rpad(text, integer, text) is 'right-pad string to length';

create function pg_catalog.rtrim(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rtrim(text) is 'trim spaces from right end of string';

create function pg_catalog.rtrim(text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rtrim(text, text) is 'trim selected characters from right end of string';

create function pg_catalog.satisfies_hash_partition(oid, integer, integer, "any") returns boolean
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.satisfies_hash_partition(oid, integer, integer, "any") is 'hash partition CHECK constraint';

create function pg_catalog.scalargejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of >= and related operators on scalar datatypes';

create function pg_catalog.scalargesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargesel(internal, oid, internal, integer) is 'restriction selectivity of >= and related operators on scalar datatypes';

create function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of > and related operators on scalar datatypes';

create function pg_catalog.scalargtsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargtsel(internal, oid, internal, integer) is 'restriction selectivity of > and related operators on scalar datatypes';

create function pg_catalog.scalarlejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarlejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of <= and related operators on scalar datatypes';

create function pg_catalog.scalarlesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarlesel(internal, oid, internal, integer) is 'restriction selectivity of <= and related operators on scalar datatypes';

create function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of < and related operators on scalar datatypes';

create function pg_catalog.scalarltsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarltsel(internal, oid, internal, integer) is 'restriction selectivity of < and related operators on scalar datatypes';

create function pg_catalog.scale(numeric) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scale(numeric) is 'number of decimal digits in the fractional part';

create function pg_catalog.schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xml(name, boolean, boolean, text) is 'map schema contents to XML';

create function pg_catalog.schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xml_and_xmlschema(name, boolean, boolean, text) is 'map schema contents and structure to XML and XML Schema';

create function pg_catalog.schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xmlschema(name, boolean, boolean, text) is 'map schema structure to XML Schema';

create function pg_catalog."session_user"() returns name
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."session_user"() is 'session user name';

create function pg_catalog.set_bit(bit, integer, integer) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_bit(bit, integer, integer) is 'set bit';

create function pg_catalog.set_bit(bytea, bigint, integer) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_bit(bytea, bigint, integer) is 'set bit';

create function pg_catalog.set_byte(bytea, integer, integer) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_byte(bytea, integer, integer) is 'set byte';

create function pg_catalog.set_config(text, text, boolean) returns text
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_config(text, text, boolean) is 'SET X as a function';

create function pg_catalog.set_masklen(cidr, integer) returns cidr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_masklen(cidr, integer) is 'change netmask of cidr';

create function pg_catalog.set_masklen(inet, integer) returns inet
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_masklen(inet, integer) is 'change netmask of inet';

create function pg_catalog.setseed(double precision) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setseed(double precision) is 'set random seed';

create function pg_catalog.setval(regclass, bigint) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setval(regclass, bigint) is 'set sequence value';

create function pg_catalog.setval(regclass, bigint, boolean) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setval(regclass, bigint, boolean) is 'set sequence value and is_called status';

create function pg_catalog.setweight(tsvector, "char") returns tsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setweight(tsvector, "char") is 'set given weight for whole tsvector';

create function pg_catalog.setweight(tsvector, "char", text[]) returns tsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setweight(tsvector, "char", text[]) is 'set given weight for given lexemes';

create function pg_catalog.sha224(bytea) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha224(bytea) is 'SHA-224 hash';

create function pg_catalog.sha256(bytea) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha256(bytea) is 'SHA-256 hash';

create function pg_catalog.sha384(bytea) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha384(bytea) is 'SHA-384 hash';

create function pg_catalog.sha512(bytea) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha512(bytea) is 'SHA-512 hash';

create function pg_catalog.shell_in(cstring) returns void
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shell_in(cstring) is 'I/O';

create function pg_catalog.shell_out(void) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shell_out(void) is 'I/O';

create function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer) is 'internal conversion function for SHIFT_JIS_2004 to EUC_JIS_2004';

create function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for SHIFT_JIS_2004 to UTF8';

create function pg_catalog.shobj_description(oid, name) returns text
    stable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shobj_description(oid, name) is 'get description for object id and shared catalog name';

create function pg_catalog.sign(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sign(double precision) is 'sign of value';

create function pg_catalog.sign(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sign(numeric) is 'sign of value';

create function pg_catalog.similar_escape(text, text) returns text
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.similar_escape(text, text) is 'convert SQL regexp pattern to POSIX style';

create function pg_catalog.similar_to_escape(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.similar_to_escape(text) is 'convert SQL regexp pattern to POSIX style';

create function pg_catalog.similar_to_escape(text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.similar_to_escape(text, text) is 'convert SQL regexp pattern to POSIX style';

create function pg_catalog.sin(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sin(double precision) is 'sine';

create function pg_catalog.sind(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sind(double precision) is 'sine, degrees';

create function pg_catalog.sinh(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sinh(double precision) is 'hyperbolic sine';

create function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer) is 'internal conversion function for SJIS to EUC_JP';

create function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for SJIS to MULE_INTERNAL';

create function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for SJIS to UTF8';

create function pg_catalog.slope(point, point) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.slope(point, point) is 'slope between points';

create function pg_catalog.spg_bbox_quad_config(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_bbox_quad_config(internal, internal) is 'SP-GiST support for quad tree over 2-D types represented by their bounding boxes';

create function pg_catalog.spg_box_quad_choose(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_choose(internal, internal) is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_config(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_config(internal, internal) is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_inner_consistent(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_inner_consistent(internal, internal) is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_leaf_consistent(internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_leaf_consistent(internal, internal) is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_box_quad_picksplit(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_picksplit(internal, internal) is 'SP-GiST support for quad tree over box';

create function pg_catalog.spg_kd_choose(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_choose(internal, internal) is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_kd_config(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_config(internal, internal) is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_kd_inner_consistent(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_inner_consistent(internal, internal) is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_kd_picksplit(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_picksplit(internal, internal) is 'SP-GiST support for k-d tree over point';

create function pg_catalog.spg_poly_quad_compress(polygon) returns box
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_poly_quad_compress(polygon) is 'SP-GiST support for quad tree over polygons';

create function pg_catalog.spg_quad_choose(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_choose(internal, internal) is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_quad_config(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_config(internal, internal) is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_quad_inner_consistent(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_inner_consistent(internal, internal) is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_quad_leaf_consistent(internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_leaf_consistent(internal, internal) is 'SP-GiST support for quad tree and k-d tree over point';

create function pg_catalog.spg_quad_picksplit(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_picksplit(internal, internal) is 'SP-GiST support for quad tree over point';

create function pg_catalog.spg_range_quad_choose(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_choose(internal, internal) is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_config(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_config(internal, internal) is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_inner_consistent(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_inner_consistent(internal, internal) is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_leaf_consistent(internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_leaf_consistent(internal, internal) is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_range_quad_picksplit(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_picksplit(internal, internal) is 'SP-GiST support for quad tree over range';

create function pg_catalog.spg_text_choose(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_choose(internal, internal) is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_config(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_config(internal, internal) is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_inner_consistent(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_inner_consistent(internal, internal) is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_leaf_consistent(internal, internal) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_leaf_consistent(internal, internal) is 'SP-GiST support for radix tree over text';

create function pg_catalog.spg_text_picksplit(internal, internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_picksplit(internal, internal) is 'SP-GiST support for radix tree over text';

create function pg_catalog.spghandler(internal) returns index_am_handler
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spghandler(internal) is 'spgist index access method handler';

create function pg_catalog.split_part(text, text, integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.split_part(text, text, integer) is 'split string by field_sep and return field_num';

create function pg_catalog.sqrt(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sqrt(double precision) is 'square root';

create function pg_catalog.sqrt(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sqrt(numeric) is 'square root';

create function pg_catalog.starts_with(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.starts_with(text, text) is 'implementation of ^@ operator';

create function pg_catalog.statement_timestamp() returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.statement_timestamp() is 'current statement time';

create function pg_catalog.string_agg_finalfn(internal) returns text
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_agg_finalfn(internal) is 'aggregate final function';

create function pg_catalog.string_agg_transfn(internal, text, text) returns internal
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_agg_transfn(internal, text, text) is 'aggregate transition function';

create function pg_catalog.string_to_array(text, text) returns text[]
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_to_array(text, text) is 'split delimited text into text[]';

create function pg_catalog.string_to_array(text, text, text) returns text[]
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_to_array(text, text, text) is 'split delimited text into text[], with null string';

create function pg_catalog.strip(tsvector) returns tsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.strip(tsvector) is 'strip position information';

create function pg_catalog.strpos(text, text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.strpos(text, text) is 'position of substring';

create function pg_catalog.substr(bytea, integer) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(bytea, integer) is 'extract portion of string';

create function pg_catalog.substr(bytea, integer, integer) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(bytea, integer, integer) is 'extract portion of string';

create function pg_catalog.substr(text, integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(text, integer) is 'extract portion of string';

create function pg_catalog.substr(text, integer, integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(text, integer, integer) is 'extract portion of string';

create function pg_catalog.substring(bit, integer) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bit, integer) is 'extract portion of bitstring';

create function pg_catalog.substring(bit, integer, integer) returns bit
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bit, integer, integer) is 'extract portion of bitstring';

create function pg_catalog.substring(bytea, integer) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bytea, integer) is 'extract portion of string';

create function pg_catalog.substring(bytea, integer, integer) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bytea, integer, integer) is 'extract portion of string';

create function pg_catalog.substring(text, integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(text, integer) is 'extract portion of string';

create function pg_catalog.substring(text, integer, integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(text, integer, integer) is 'extract portion of string';

create function pg_catalog.substring(text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(text, text) is 'extract text matching regular expression';

create function pg_catalog.substring(text, text, text) returns text
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(text, text, text) is 'extract text matching SQL regular expression';

create function pg_catalog.suppress_redundant_updates_trigger() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.suppress_redundant_updates_trigger() is 'trigger to suppress updates when new and old records match';

create function pg_catalog.system(internal) returns tsm_handler
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.system(internal) is 'SYSTEM tablesample method handler';

create function pg_catalog.table_am_handler_in(cstring) returns table_am_handler
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_am_handler_in(cstring) is 'I/O';

create function pg_catalog.table_am_handler_out(table_am_handler) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_am_handler_out(table_am_handler) is 'I/O';

create function pg_catalog.table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xml(regclass, boolean, boolean, text) is 'map table contents to XML';

create function pg_catalog.table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xml_and_xmlschema(regclass, boolean, boolean, text) is 'map table contents and structure to XML and XML Schema';

create function pg_catalog.table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xmlschema(regclass, boolean, boolean, text) is 'map table structure to XML Schema';

create function pg_catalog.tan(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tan(double precision) is 'tangent';

create function pg_catalog.tand(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tand(double precision) is 'tangent, degrees';

create function pg_catalog.tanh(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tanh(double precision) is 'hyperbolic tangent';

create function pg_catalog.text("char") returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text("char") is 'convert char to text';

create function pg_catalog.text(boolean) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(boolean) is 'convert boolean to text';

create function pg_catalog.text(char) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(char) is 'convert char(n) to text';

create function pg_catalog.text(inet) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(inet) is 'show all parts of inet/cidr value';

create function pg_catalog.text(name) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(name) is 'convert name to text';

create function pg_catalog.text(xml) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(xml) is 'serialize an XML value to a character string';

create function pg_catalog.text_ge(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_ge(text, text) is 'implementation of >= operator';

create function pg_catalog.text_gt(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_gt(text, text) is 'implementation of > operator';

create function pg_catalog.text_larger(text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_larger(text, text) is 'larger of two';

create function pg_catalog.text_le(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_le(text, text) is 'implementation of <= operator';

create function pg_catalog.text_lt(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_lt(text, text) is 'implementation of < operator';

create function pg_catalog.text_pattern_ge(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_ge(text, text) is 'implementation of ~>=~ operator';

create function pg_catalog.text_pattern_gt(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_gt(text, text) is 'implementation of ~>~ operator';

create function pg_catalog.text_pattern_le(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_le(text, text) is 'implementation of ~<=~ operator';

create function pg_catalog.text_pattern_lt(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_lt(text, text) is 'implementation of ~<~ operator';

create function pg_catalog.text_smaller(text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_smaller(text, text) is 'smaller of two';

create function pg_catalog.textanycat(text, anynonarray) returns text
    stable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textanycat(text, anynonarray) is 'implementation of || operator';

create function pg_catalog.textcat(text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textcat(text, text) is 'implementation of || operator';

create function pg_catalog.texteq(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texteq(text, text) is 'implementation of = operator';

create function pg_catalog.texteqname(text, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texteqname(text, name) is 'implementation of = operator';

create function pg_catalog.textgename(text, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textgename(text, name) is 'implementation of >= operator';

create function pg_catalog.textgtname(text, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textgtname(text, name) is 'implementation of > operator';

create function pg_catalog.texticlike(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticlike(text, text) is 'implementation of ~~* operator';

create function pg_catalog.texticlike_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticlike_support(internal) is 'planner support for texticlike';

create function pg_catalog.texticnlike(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticnlike(text, text) is 'implementation of !~~* operator';

create function pg_catalog.texticregexeq(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexeq(text, text) is 'implementation of ~* operator';

create function pg_catalog.texticregexeq_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexeq_support(internal) is 'planner support for texticregexeq';

create function pg_catalog.texticregexne(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexne(text, text) is 'implementation of !~* operator';

create function pg_catalog.textin(cstring) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textin(cstring) is 'I/O';

create function pg_catalog.textlen(text) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlen(text) is 'length';

create function pg_catalog.textlename(text, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlename(text, name) is 'implementation of <= operator';

create function pg_catalog.textlike(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlike(text, text) is 'implementation of ~~ operator';

create function pg_catalog.textlike_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlike_support(internal) is 'planner support for textlike';

create function pg_catalog.textltname(text, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textltname(text, name) is 'implementation of < operator';

create function pg_catalog.textne(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textne(text, text) is 'implementation of <> operator';

create function pg_catalog.textnename(text, name) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textnename(text, name) is 'implementation of <> operator';

create function pg_catalog.textnlike(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textnlike(text, text) is 'implementation of !~~ operator';

create function pg_catalog.textout(text) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textout(text) is 'I/O';

create function pg_catalog.textrecv(internal) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textrecv(internal) is 'I/O';

create function pg_catalog.textregexeq(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexeq(text, text) is 'implementation of ~ operator';

create function pg_catalog.textregexeq_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexeq_support(internal) is 'planner support for textregexeq';

create function pg_catalog.textregexne(text, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexne(text, text) is 'implementation of !~ operator';

create function pg_catalog.textsend(text) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textsend(text) is 'I/O';

create function pg_catalog.thesaurus_init(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.thesaurus_init(internal) is '(internal)';

create function pg_catalog.thesaurus_lexize(internal, internal, internal, internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.thesaurus_lexize(internal, internal, internal, internal) is '(internal)';

create function pg_catalog.tideq(tid, tid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tideq(tid, tid) is 'implementation of = operator';

create function pg_catalog.tidge(tid, tid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidge(tid, tid) is 'implementation of >= operator';

create function pg_catalog.tidgt(tid, tid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidgt(tid, tid) is 'implementation of > operator';

create function pg_catalog.tidin(cstring) returns tid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidin(cstring) is 'I/O';

create function pg_catalog.tidlarger(tid, tid) returns tid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidlarger(tid, tid) is 'larger of two';

create function pg_catalog.tidle(tid, tid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidle(tid, tid) is 'implementation of <= operator';

create function pg_catalog.tidlt(tid, tid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidlt(tid, tid) is 'implementation of < operator';

create function pg_catalog.tidne(tid, tid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidne(tid, tid) is 'implementation of <> operator';

create function pg_catalog.tidout(tid) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidout(tid) is 'I/O';

create function pg_catalog.tidrecv(internal) returns tid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidrecv(internal) is 'I/O';

create function pg_catalog.tidsend(tid) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidsend(tid) is 'I/O';

create function pg_catalog.tidsmaller(tid, tid) returns tid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidsmaller(tid, tid) is 'smaller of two';

create function pg_catalog.time(interval) returns time
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(interval) is 'convert interval to time';

create function pg_catalog.time(time with time zone) returns time
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(time with time zone) is 'convert time with time zone to time';

create function pg_catalog.time(time, integer) returns time
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(time, integer) is 'adjust time precision';

create function pg_catalog.time(timestamp with time zone) returns time
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(timestamp with time zone) is 'convert timestamp with time zone to time';

create function pg_catalog.time(timestamp) returns time
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(timestamp) is 'convert timestamp to time';

create function pg_catalog.time_cmp(time, time) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_cmp(time, time) is 'less-equal-greater';

create function pg_catalog.time_eq(time, time) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_eq(time, time) is 'implementation of = operator';

create function pg_catalog.time_ge(time, time) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_ge(time, time) is 'implementation of >= operator';

create function pg_catalog.time_gt(time, time) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_gt(time, time) is 'implementation of > operator';

create function pg_catalog.time_hash(time) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_hash(time) is 'hash';

create function pg_catalog.time_hash_extended(time, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_hash_extended(time, bigint) is 'hash';

create function pg_catalog.time_in(cstring, oid, integer) returns time
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.time_larger(time, time) returns time
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_larger(time, time) is 'larger of two';

create function pg_catalog.time_le(time, time) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_le(time, time) is 'implementation of <= operator';

create function pg_catalog.time_lt(time, time) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_lt(time, time) is 'implementation of < operator';

create function pg_catalog.time_mi_interval(time, interval) returns time
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_mi_interval(time, interval) is 'implementation of - operator';

create function pg_catalog.time_mi_time(time, time) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_mi_time(time, time) is 'implementation of - operator';

create function pg_catalog.time_ne(time, time) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_ne(time, time) is 'implementation of <> operator';

create function pg_catalog.time_out(time) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_out(time) is 'I/O';

create function pg_catalog.time_pl_interval(time, interval) returns time
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_pl_interval(time, interval) is 'implementation of + operator';

create function pg_catalog.time_recv(internal, oid, integer) returns time
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.time_send(time) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_send(time) is 'I/O';

create function pg_catalog.time_smaller(time, time) returns time
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_smaller(time, time) is 'smaller of two';

create function pg_catalog.time_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_support(internal) is 'planner support for time length coercion';

create function pg_catalog.timedate_pl(time without time zone, date) returns timestamp without time zone
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timedate_pl(time, date) is 'implementation of + operator';

create function pg_catalog.timeofday() returns text
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timeofday() is 'current date and time - increments during transactions';

create function pg_catalog.timestamp(date) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(date) is 'convert date to timestamp';

create function pg_catalog.timestamp(date, time) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(date, time) is 'convert date and time to timestamp';

create function pg_catalog.timestamp(timestamp with time zone) returns timestamp
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(timestamp with time zone) is 'convert timestamp with time zone to timestamp';

create function pg_catalog.timestamp(timestamp, integer) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(timestamp, integer) is 'adjust timestamp precision';

create function pg_catalog.timestamp_cmp(timestamp, timestamp) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp(timestamp, timestamp) is 'less-equal-greater';

create function pg_catalog.timestamp_cmp_date(timestamp, date) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp_date(timestamp, date) is 'less-equal-greater';

create function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone) returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone) is 'less-equal-greater';

create function pg_catalog.timestamp_eq(timestamp, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq(timestamp, timestamp) is 'implementation of = operator';

create function pg_catalog.timestamp_eq_date(timestamp, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq_date(timestamp, date) is 'implementation of = operator';

create function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone) is 'implementation of = operator';

create function pg_catalog.timestamp_ge(timestamp, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge(timestamp, timestamp) is 'implementation of >= operator';

create function pg_catalog.timestamp_ge_date(timestamp, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge_date(timestamp, date) is 'implementation of >= operator';

create function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone) is 'implementation of >= operator';

create function pg_catalog.timestamp_gt(timestamp, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt(timestamp, timestamp) is 'implementation of > operator';

create function pg_catalog.timestamp_gt_date(timestamp, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt_date(timestamp, date) is 'implementation of > operator';

create function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone) is 'implementation of > operator';

create function pg_catalog.timestamp_hash(timestamp) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_hash(timestamp) is 'hash';

create function pg_catalog.timestamp_hash_extended(timestamp, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_hash_extended(timestamp, bigint) is 'hash';

create function pg_catalog.timestamp_in(cstring, oid, integer) returns timestamp
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.timestamp_larger(timestamp, timestamp) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_larger(timestamp, timestamp) is 'larger of two';

create function pg_catalog.timestamp_le(timestamp, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le(timestamp, timestamp) is 'implementation of <= operator';

create function pg_catalog.timestamp_le_date(timestamp, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le_date(timestamp, date) is 'implementation of <= operator';

create function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone) is 'implementation of <= operator';

create function pg_catalog.timestamp_lt(timestamp, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt(timestamp, timestamp) is 'implementation of < operator';

create function pg_catalog.timestamp_lt_date(timestamp, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt_date(timestamp, date) is 'implementation of < operator';

create function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone) is 'implementation of < operator';

create function pg_catalog.timestamp_mi(timestamp, timestamp) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_mi(timestamp, timestamp) is 'implementation of - operator';

create function pg_catalog.timestamp_mi_interval(timestamp, interval) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_mi_interval(timestamp, interval) is 'implementation of - operator';

create function pg_catalog.timestamp_ne(timestamp, timestamp) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne(timestamp, timestamp) is 'implementation of <> operator';

create function pg_catalog.timestamp_ne_date(timestamp, date) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne_date(timestamp, date) is 'implementation of <> operator';

create function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone) is 'implementation of <> operator';

create function pg_catalog.timestamp_out(timestamp) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_out(timestamp) is 'I/O';

create function pg_catalog.timestamp_pl_interval(timestamp, interval) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_pl_interval(timestamp, interval) is 'implementation of + operator';

create function pg_catalog.timestamp_recv(internal, oid, integer) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.timestamp_send(timestamp) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_send(timestamp) is 'I/O';

create function pg_catalog.timestamp_smaller(timestamp, timestamp) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_smaller(timestamp, timestamp) is 'smaller of two';

create function pg_catalog.timestamp_sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_sortsupport(internal) is 'sort support';

create function pg_catalog.timestamp_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_support(internal) is 'planner support for timestamp length coercion';

create function pg_catalog.timestamptypmodin(cstring[]) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptypmodin(cstring[]) is 'I/O typmod';

create function pg_catalog.timestamptypmodout(integer) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptypmodout(integer) is 'I/O typmod';

create function pg_catalog.timestamptz(date) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(date) is 'convert date to timestamp with time zone';

create function pg_catalog.timestamptz(date, time with time zone) returns timestamp with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(date, time with time zone) is 'convert date and time with time zone to timestamp with time zone';

create function pg_catalog.timestamptz(date, time without time zone) returns timestamp with time zone
    stable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(date, time) is 'convert date and time to timestamp with time zone';

create function pg_catalog.timestamptz(timestamp with time zone, integer) returns timestamp with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(timestamp with time zone, integer) is 'adjust timestamptz precision';

create function pg_catalog.timestamptz(timestamp) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(timestamp) is 'convert timestamp to timestamp with time zone';

create function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone) is 'less-equal-greater';

create function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date) returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date) is 'less-equal-greater';

create function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp) returns integer
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp) is 'less-equal-greater';

create function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone) is 'implementation of = operator';

create function pg_catalog.timestamptz_eq_date(timestamp with time zone, date) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq_date(timestamp with time zone, date) is 'implementation of = operator';

create function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp) is 'implementation of = operator';

create function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone) is 'implementation of >= operator';

create function pg_catalog.timestamptz_ge_date(timestamp with time zone, date) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge_date(timestamp with time zone, date) is 'implementation of >= operator';

create function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp) is 'implementation of >= operator';

create function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone) is 'implementation of > operator';

create function pg_catalog.timestamptz_gt_date(timestamp with time zone, date) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt_date(timestamp with time zone, date) is 'implementation of > operator';

create function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp) is 'implementation of > operator';

create function pg_catalog.timestamptz_in(cstring, oid, integer) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone) returns timestamp with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone) is 'larger of two';

create function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone) is 'implementation of <= operator';

create function pg_catalog.timestamptz_le_date(timestamp with time zone, date) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le_date(timestamp with time zone, date) is 'implementation of <= operator';

create function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp) is 'implementation of <= operator';

create function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone) is 'implementation of < operator';

create function pg_catalog.timestamptz_lt_date(timestamp with time zone, date) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt_date(timestamp with time zone, date) is 'implementation of < operator';

create function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp) is 'implementation of < operator';

create function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone) returns interval
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone) is 'implementation of - operator';

create function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval) is 'implementation of - operator';

create function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone) is 'implementation of <> operator';

create function pg_catalog.timestamptz_ne_date(timestamp with time zone, date) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne_date(timestamp with time zone, date) is 'implementation of <> operator';

create function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp) is 'implementation of <> operator';

create function pg_catalog.timestamptz_out(timestamp with time zone) returns cstring
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_out(timestamp with time zone) is 'I/O';

create function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval) is 'implementation of + operator';

create function pg_catalog.timestamptz_recv(internal, oid, integer) returns timestamp with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.timestamptz_send(timestamp with time zone) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_send(timestamp with time zone) is 'I/O';

create function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone) returns timestamp with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone) is 'smaller of two';

create function pg_catalog.timestamptztypmodin(cstring[]) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptztypmodin(cstring[]) is 'I/O typmod';

create function pg_catalog.timestamptztypmodout(integer) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptztypmodout(integer) is 'I/O typmod';

create function pg_catalog.timetypmodin(cstring[]) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetypmodin(cstring[]) is 'I/O typmod';

create function pg_catalog.timetypmodout(integer) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetypmodout(integer) is 'I/O typmod';

create function pg_catalog.timetz(time with time zone, integer) returns time with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(time with time zone, integer) is 'adjust time with time zone precision';

create function pg_catalog.timetz(time) returns time with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(time) is 'convert time to time with time zone';

create function pg_catalog.timetz(timestamp with time zone) returns time with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(timestamp with time zone) is 'convert timestamp with time zone to time with time zone';

create function pg_catalog.timetz_cmp(time with time zone, time with time zone) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_cmp(time with time zone, time with time zone) is 'less-equal-greater';

create function pg_catalog.timetz_eq(time with time zone, time with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_eq(time with time zone, time with time zone) is 'implementation of = operator';

create function pg_catalog.timetz_ge(time with time zone, time with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_ge(time with time zone, time with time zone) is 'implementation of >= operator';

create function pg_catalog.timetz_gt(time with time zone, time with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_gt(time with time zone, time with time zone) is 'implementation of > operator';

create function pg_catalog.timetz_hash(time with time zone) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_hash(time with time zone) is 'hash';

create function pg_catalog.timetz_hash_extended(time with time zone, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_hash_extended(time with time zone, bigint) is 'hash';

create function pg_catalog.timetz_in(cstring, oid, integer) returns time with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.timetz_larger(time with time zone, time with time zone) returns time with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_larger(time with time zone, time with time zone) is 'larger of two';

create function pg_catalog.timetz_le(time with time zone, time with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_le(time with time zone, time with time zone) is 'implementation of <= operator';

create function pg_catalog.timetz_lt(time with time zone, time with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_lt(time with time zone, time with time zone) is 'implementation of < operator';

create function pg_catalog.timetz_mi_interval(time with time zone, interval) returns time with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_mi_interval(time with time zone, interval) is 'implementation of - operator';

create function pg_catalog.timetz_ne(time with time zone, time with time zone) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_ne(time with time zone, time with time zone) is 'implementation of <> operator';

create function pg_catalog.timetz_out(time with time zone) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_out(time with time zone) is 'I/O';

create function pg_catalog.timetz_pl_interval(time with time zone, interval) returns time with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_pl_interval(time with time zone, interval) is 'implementation of + operator';

create function pg_catalog.timetz_recv(internal, oid, integer) returns time with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.timetz_send(time with time zone) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_send(time with time zone) is 'I/O';

create function pg_catalog.timetz_smaller(time with time zone, time with time zone) returns time with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_smaller(time with time zone, time with time zone) is 'smaller of two';

create function pg_catalog.timetzdate_pl(time with time zone, date) returns timestamp with time zone
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetzdate_pl(time with time zone, date) is 'implementation of + operator';

create function pg_catalog.timetztypmodin(cstring[]) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetztypmodin(cstring[]) is 'I/O typmod';

create function pg_catalog.timetztypmodout(integer) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetztypmodout(integer) is 'I/O typmod';

create function pg_catalog.timezone(interval, time with time zone) returns time with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(interval, time with time zone) is 'adjust time with time zone to new zone';

create function pg_catalog.timezone(interval, timestamp with time zone) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(interval, timestamp with time zone) is 'adjust timestamp to new time zone';

create function pg_catalog.timezone(interval, timestamp) returns timestamp with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(interval, timestamp) is 'adjust timestamp to new time zone';

create function pg_catalog.timezone(text, time with time zone) returns time with time zone
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(text, time with time zone) is 'adjust time with time zone to new zone';

create function pg_catalog.timezone(text, timestamp with time zone) returns timestamp
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(text, timestamp with time zone) is 'adjust timestamp to new time zone';

create function pg_catalog.timezone(text, timestamp) returns timestamp with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(text, timestamp) is 'adjust timestamp to new time zone';

create function pg_catalog.to_ascii(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii(text) is 'encode text from DB encoding to ASCII text';

create function pg_catalog.to_ascii(text, integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii(text, integer) is 'encode text from encoding to ASCII text';

create function pg_catalog.to_ascii(text, name) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii(text, name) is 'encode text from encoding to ASCII text';

create function pg_catalog.to_char(bigint, text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(bigint, text) is 'format int8 to text';

create function pg_catalog.to_char(double precision, text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(double precision, text) is 'format float8 to text';

create function pg_catalog.to_char(integer, text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(integer, text) is 'format int4 to text';

create function pg_catalog.to_char(interval, text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(interval, text) is 'format interval to text';

create function pg_catalog.to_char(numeric, text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(numeric, text) is 'format numeric to text';

create function pg_catalog.to_char(real, text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(real, text) is 'format float4 to text';

create function pg_catalog.to_char(timestamp with time zone, text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(timestamp with time zone, text) is 'format timestamp with time zone to text';

create function pg_catalog.to_char(timestamp, text) returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(timestamp, text) is 'format timestamp to text';

create function pg_catalog.to_date(text, text) returns date
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_date(text, text) is 'convert text to date';

create function pg_catalog.to_hex(bigint) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_hex(bigint) is 'convert int8 number to hex';

create function pg_catalog.to_hex(integer) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_hex(integer) is 'convert int4 number to hex';

create function pg_catalog.to_json(anyelement) returns json
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_json(anyelement) is 'map input to json';

create function pg_catalog.to_jsonb(anyelement) returns jsonb
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_jsonb(anyelement) is 'map input to jsonb';

create function pg_catalog.to_number(text, text) returns numeric
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_number(text, text) is 'convert text to numeric';

create function pg_catalog.to_regclass(text) returns regclass
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regclass(text) is 'convert classname to regclass';

create function pg_catalog.to_regcollation(text) returns regcollation
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regcollation(text) is 'convert classname to regcollation';

create function pg_catalog.to_regnamespace(text) returns regnamespace
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regnamespace(text) is 'convert namespace name to regnamespace';

create function pg_catalog.to_regoper(text) returns regoper
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regoper(text) is 'convert operator name to regoper';

create function pg_catalog.to_regoperator(text) returns regoperator
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regoperator(text) is 'convert operator name to regoperator';

create function pg_catalog.to_regproc(text) returns regproc
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regproc(text) is 'convert proname to regproc';

create function pg_catalog.to_regprocedure(text) returns regprocedure
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regprocedure(text) is 'convert proname to regprocedure';

create function pg_catalog.to_regrole(text) returns regrole
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regrole(text) is 'convert role name to regrole';

create function pg_catalog.to_regtype(text) returns regtype
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regtype(text) is 'convert type name to regtype';

create function pg_catalog.to_timestamp(double precision) returns timestamp with time zone
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_timestamp(double precision) is 'convert UNIX epoch to timestamptz';

create function pg_catalog.to_timestamp(text, text) returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_timestamp(text, text) is 'convert text to timestamp with time zone';

create function pg_catalog.to_tsquery(regconfig, text) returns tsquery
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsquery(regconfig, text) is 'make tsquery';

create function pg_catalog.to_tsquery(text) returns tsquery
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsquery(text) is 'make tsquery';

create function pg_catalog.to_tsvector(json) returns tsvector
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(json) is 'transform string values from json to tsvector';

create function pg_catalog.to_tsvector(jsonb) returns tsvector
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(jsonb) is 'transform string values from jsonb to tsvector';

create function pg_catalog.to_tsvector(regconfig, json) returns tsvector
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(regconfig, json) is 'transform string values from json to tsvector';

create function pg_catalog.to_tsvector(regconfig, jsonb) returns tsvector
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(regconfig, jsonb) is 'transform string values from jsonb to tsvector';

create function pg_catalog.to_tsvector(regconfig, text) returns tsvector
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(regconfig, text) is 'transform to tsvector';

create function pg_catalog.to_tsvector(text) returns tsvector
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(text) is 'transform to tsvector';

create function pg_catalog.transaction_timestamp() returns timestamp with time zone
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.transaction_timestamp() is 'current transaction time';

create function pg_catalog.translate(text, text, text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.translate(text, text, text) is 'map a set of characters appearing in string';

create function pg_catalog.trigger_in(cstring) returns trigger
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trigger_in(cstring) is 'I/O';

create function pg_catalog.trigger_out(trigger) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trigger_out(trigger) is 'I/O';

create function pg_catalog.trim_scale(numeric) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trim_scale(numeric) is 'numeric with minimum scale needed to represent the value';

create function pg_catalog.trunc(double precision) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(double precision) is 'truncate to integer';

create function pg_catalog.trunc(macaddr) returns macaddr
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(macaddr) is 'MACADDR manufacturer fields';

create function pg_catalog.trunc(macaddr8) returns macaddr8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(macaddr8) is 'MACADDR8 manufacturer fields';

create function pg_catalog.trunc(numeric) returns numeric
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(numeric) is 'value truncated to ''scale'' of zero';

create function pg_catalog.trunc(numeric, integer) returns numeric
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(numeric, integer) is 'value truncated to ''scale''';

create function pg_catalog.ts_debug(config regconfig, document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[]) returns SETOF record
    stable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_debug(regconfig, text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) is 'debug function for text search configuration';

create function pg_catalog.ts_debug(document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[]) returns SETOF record
    stable
    strict
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_debug(text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) is 'debug function for current text search configuration';

create function pg_catalog.ts_delete(tsvector, text) returns tsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_delete(tsvector, text) is 'delete lexeme';

create function pg_catalog.ts_delete(tsvector, text[]) returns tsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_delete(tsvector, text[]) is 'delete given lexemes';

create function pg_catalog.ts_filter(tsvector, "char"[]) returns tsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_filter(tsvector, "char"[]) is 'delete lexemes that do not have one of the given weights';

create function pg_catalog.ts_headline(json, tsquery) returns json
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(json, tsquery) is 'generate headline from json';

create function pg_catalog.ts_headline(json, tsquery, text) returns json
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(json, tsquery, text) is 'generate headline from json';

create function pg_catalog.ts_headline(jsonb, tsquery) returns jsonb
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(jsonb, tsquery) is 'generate headline from jsonb';

create function pg_catalog.ts_headline(jsonb, tsquery, text) returns jsonb
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(jsonb, tsquery, text) is 'generate headline from jsonb';

create function pg_catalog.ts_headline(regconfig, json, tsquery) returns json
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, json, tsquery) is 'generate headline from json';

create function pg_catalog.ts_headline(regconfig, json, tsquery, text) returns json
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, json, tsquery, text) is 'generate headline from json';

create function pg_catalog.ts_headline(regconfig, jsonb, tsquery) returns jsonb
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, jsonb, tsquery) is 'generate headline from jsonb';

create function pg_catalog.ts_headline(regconfig, jsonb, tsquery, text) returns jsonb
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, jsonb, tsquery, text) is 'generate headline from jsonb';

create function pg_catalog.ts_headline(regconfig, text, tsquery) returns text
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, text, tsquery) is 'generate headline';

create function pg_catalog.ts_headline(regconfig, text, tsquery, text) returns text
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, text, tsquery, text) is 'generate headline';

create function pg_catalog.ts_headline(text, tsquery) returns text
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(text, tsquery) is 'generate headline';

create function pg_catalog.ts_headline(text, tsquery, text) returns text
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(text, tsquery, text) is 'generate headline';

create function pg_catalog.ts_lexize(regdictionary, text) returns text[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_lexize(regdictionary, text) is 'normalize one word by dictionary';

create function pg_catalog.ts_match_qv(tsquery, tsvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_qv(tsquery, tsvector) is 'implementation of @@ operator';

create function pg_catalog.ts_match_tq(text, tsquery) returns boolean
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_tq(text, tsquery) is 'implementation of @@ operator';

create function pg_catalog.ts_match_tt(text, text) returns boolean
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_tt(text, text) is 'implementation of @@ operator';

create function pg_catalog.ts_match_vq(tsvector, tsquery) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_vq(tsvector, tsquery) is 'implementation of @@ operator';

create function pg_catalog.ts_parse(parser_oid oid, txt text, out tokid integer, out token text) returns setof setof record
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_parse(oid, text, out integer, out text) is 'parse text to tokens';

create function pg_catalog.ts_parse(parser_name text, txt text, out tokid integer, out token text) returns setof setof record
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_parse(text, text, out integer, out text) is 'parse text to tokens';

create function pg_catalog.ts_rank(real[], tsvector, tsquery) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(real[], tsvector, tsquery) is 'relevance';

create function pg_catalog.ts_rank(real[], tsvector, tsquery, integer) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(real[], tsvector, tsquery, integer) is 'relevance';

create function pg_catalog.ts_rank(tsvector, tsquery) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(tsvector, tsquery) is 'relevance';

create function pg_catalog.ts_rank(tsvector, tsquery, integer) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(tsvector, tsquery, integer) is 'relevance';

create function pg_catalog.ts_rank_cd(real[], tsvector, tsquery) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(real[], tsvector, tsquery) is 'relevance';

create function pg_catalog.ts_rank_cd(real[], tsvector, tsquery, integer) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(real[], tsvector, tsquery, integer) is 'relevance';

create function pg_catalog.ts_rank_cd(tsvector, tsquery) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(tsvector, tsquery) is 'relevance';

create function pg_catalog.ts_rank_cd(tsvector, tsquery, integer) returns real
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(tsvector, tsquery, integer) is 'relevance';

create function pg_catalog.ts_rewrite(tsquery, text) returns tsquery
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rewrite(tsquery, text) is 'rewrite tsquery';

create function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery) returns tsquery
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery) is 'rewrite tsquery';

create function pg_catalog.ts_stat(query text, out word text, out ndoc integer, out nentry integer) returns setof setof record
    strict
    cost 10
    rows 10000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_stat(text, out text, out integer, out integer) is 'statistics of tsvector column';

create function pg_catalog.ts_stat(query text, weights text, out word text, out ndoc integer, out nentry integer) returns setof setof record
    strict
    cost 10
    rows 10000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_stat(text, text, out text, out integer, out integer) is 'statistics of tsvector column';

create function pg_catalog.ts_token_type(parser_oid oid, out tokid integer, out alias text, out description text) returns setof setof record
    immutable
    strict
    cost 1
    rows 16
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_token_type(oid, out integer, out text, out text) is 'get parser''s token types';

create function pg_catalog.ts_token_type(parser_name text, out tokid integer, out alias text, out description text) returns setof setof record
    stable
    strict
    cost 1
    rows 16
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_token_type(text, out integer, out text, out text) is 'get parser''s token types';

create function pg_catalog.ts_typanalyze(internal) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_typanalyze(internal) is 'tsvector typanalyze';

create function pg_catalog.tsm_handler_in(cstring) returns tsm_handler
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsm_handler_in(cstring) is 'I/O';

create function pg_catalog.tsm_handler_out(tsm_handler) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsm_handler_out(tsm_handler) is 'I/O';

create function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of tsvector @@ tsquery';

create function pg_catalog.tsmatchsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmatchsel(internal, oid, internal, integer) is 'restriction selectivity of tsvector @@ tsquery';

create function pg_catalog.tsq_mcontained(tsquery, tsquery) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsq_mcontained(tsquery, tsquery) is 'implementation of <@ operator';

create function pg_catalog.tsq_mcontains(tsquery, tsquery) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsq_mcontains(tsquery, tsquery) is 'implementation of @> operator';

create function pg_catalog.tsquery_and(tsquery, tsquery) returns tsquery
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_and(tsquery, tsquery) is 'implementation of && operator';

create function pg_catalog.tsquery_cmp(tsquery, tsquery) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_cmp(tsquery, tsquery) is 'less-equal-greater';

create function pg_catalog.tsquery_eq(tsquery, tsquery) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_eq(tsquery, tsquery) is 'implementation of = operator';

create function pg_catalog.tsquery_ge(tsquery, tsquery) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_ge(tsquery, tsquery) is 'implementation of >= operator';

create function pg_catalog.tsquery_gt(tsquery, tsquery) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_gt(tsquery, tsquery) is 'implementation of > operator';

create function pg_catalog.tsquery_le(tsquery, tsquery) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_le(tsquery, tsquery) is 'implementation of <= operator';

create function pg_catalog.tsquery_lt(tsquery, tsquery) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_lt(tsquery, tsquery) is 'implementation of < operator';

create function pg_catalog.tsquery_ne(tsquery, tsquery) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_ne(tsquery, tsquery) is 'implementation of <> operator';

create function pg_catalog.tsquery_not(tsquery) returns tsquery
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_not(tsquery) is 'implementation of !! operator';

create function pg_catalog.tsquery_or(tsquery, tsquery) returns tsquery
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_or(tsquery, tsquery) is 'implementation of || operator';

create function pg_catalog.tsquery_phrase(tsquery, tsquery) returns tsquery
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_phrase(tsquery, tsquery) is 'implementation of <-> operator';

create function pg_catalog.tsquery_phrase(tsquery, tsquery, integer) returns tsquery
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_phrase(tsquery, tsquery, integer) is 'phrase-concatenate with distance';

create function pg_catalog.tsqueryin(cstring) returns tsquery
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryin(cstring) is 'I/O';

create function pg_catalog.tsqueryout(tsquery) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryout(tsquery) is 'I/O';

create function pg_catalog.tsqueryrecv(internal) returns tsquery
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryrecv(internal) is 'I/O';

create function pg_catalog.tsquerysend(tsquery) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquerysend(tsquery) is 'I/O';

create function pg_catalog.tsrange(timestamp, timestamp) returns tsrange
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange(timestamp, timestamp) is 'tsrange constructor';

create function pg_catalog.tsrange(timestamp, timestamp, text) returns tsrange
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange(timestamp, timestamp, text) is 'tsrange constructor';

create function pg_catalog.tsrange_subdiff(timestamp, timestamp) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange_subdiff(timestamp, timestamp) is 'float8 difference of two timestamp values';

create function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone) returns tstzrange
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone) is 'tstzrange constructor';

create function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text) returns tstzrange
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text) is 'tstzrange constructor';

create function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone) is 'float8 difference of two timestamp with time zone values';

create function pg_catalog.tsvector_cmp(tsvector, tsvector) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_cmp(tsvector, tsvector) is 'less-equal-greater';

create function pg_catalog.tsvector_concat(tsvector, tsvector) returns tsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_concat(tsvector, tsvector) is 'implementation of || operator';

create function pg_catalog.tsvector_eq(tsvector, tsvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_eq(tsvector, tsvector) is 'implementation of = operator';

create function pg_catalog.tsvector_ge(tsvector, tsvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_ge(tsvector, tsvector) is 'implementation of >= operator';

create function pg_catalog.tsvector_gt(tsvector, tsvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_gt(tsvector, tsvector) is 'implementation of > operator';

create function pg_catalog.tsvector_le(tsvector, tsvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_le(tsvector, tsvector) is 'implementation of <= operator';

create function pg_catalog.tsvector_lt(tsvector, tsvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_lt(tsvector, tsvector) is 'implementation of < operator';

create function pg_catalog.tsvector_ne(tsvector, tsvector) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_ne(tsvector, tsvector) is 'implementation of <> operator';

create function pg_catalog.tsvector_to_array(tsvector) returns text[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_to_array(tsvector) is 'convert tsvector to array of lexemes';

create function pg_catalog.tsvector_update_trigger() returns trigger
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_update_trigger() is 'trigger for automatic update of tsvector column';

create function pg_catalog.tsvector_update_trigger_column() returns trigger
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_update_trigger_column() is 'trigger for automatic update of tsvector column';

create function pg_catalog.tsvectorin(cstring) returns tsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorin(cstring) is 'I/O';

create function pg_catalog.tsvectorout(tsvector) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorout(tsvector) is 'I/O';

create function pg_catalog.tsvectorrecv(internal) returns tsvector
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorrecv(internal) is 'I/O';

create function pg_catalog.tsvectorsend(tsvector) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorsend(tsvector) is 'I/O';

create function pg_catalog.txid_current() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current() is 'get current transaction ID';

create function pg_catalog.txid_current_if_assigned() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current_if_assigned() is 'get current transaction ID';

create function pg_catalog.txid_current_snapshot() returns txid_snapshot
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current_snapshot() is 'get current snapshot';

create function pg_catalog.txid_snapshot_in(cstring) returns txid_snapshot
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_in(cstring) is 'I/O';

create function pg_catalog.txid_snapshot_out(txid_snapshot) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_out(txid_snapshot) is 'I/O';

create function pg_catalog.txid_snapshot_recv(internal) returns txid_snapshot
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_recv(internal) is 'I/O';

create function pg_catalog.txid_snapshot_send(txid_snapshot) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_send(txid_snapshot) is 'I/O';

create function pg_catalog.txid_snapshot_xip(txid_snapshot) returns setof setof bigint
    immutable
    strict
    cost 1
    rows 50
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.txid_snapshot_xip(txid_snapshot) is 'get set of in-progress txids in snapshot';

create function pg_catalog.txid_snapshot_xmax(txid_snapshot) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_xmax(txid_snapshot) is 'get xmax of snapshot';

create function pg_catalog.txid_snapshot_xmin(txid_snapshot) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_xmin(txid_snapshot) is 'get xmin of snapshot';

create function pg_catalog.txid_status(bigint) returns text
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_status(bigint) is 'commit status of transaction';

create function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot) is 'is txid visible in snapshot?';

create function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for UHC to UTF8';

create function pg_catalog.unique_key_recheck() returns trigger
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unique_key_recheck() is 'deferred UNIQUE constraint check';

create function pg_catalog.unknownin(cstring) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownin(cstring) is 'I/O';

create function pg_catalog.unknownout(unknown) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownout(unknown) is 'I/O';

create function pg_catalog.unknownrecv(internal) returns unknown
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownrecv(internal) is 'I/O';

create function pg_catalog.unknownsend(unknown) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownsend(unknown) is 'I/O';

create function pg_catalog.unnest(anyarray) returns setof setof anyelement
    immutable
    strict
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.unnest(anyarray) is 'expand array to set of rows';

create function pg_catalog.unnest(tsvector tsvector, out lexeme text, out positions smallint[], out weights text[]) returns setof setof record
    immutable
    strict
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.unnest(tsvector, out text, out smallint[], out text[]) is 'expand tsvector to set of rows';

create function pg_catalog.upper(anyrange) returns anyelement
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper(anyrange) is 'upper bound of range';

create function pg_catalog.upper(text) returns text
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper(text) is 'uppercase';

create function pg_catalog.upper_inc(anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inc(anyrange) is 'is the range''s upper bound inclusive?';

create function pg_catalog.upper_inf(anyrange) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inf(anyrange) is 'is the range''s upper bound infinite?';

create function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to BIG5';

create function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to EUC_CN';

create function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to EUC_JIS_2004';

create function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to EUC_JP';

create function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to EUC_KR';

create function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to EUC_TW';

create function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to GB18030';

create function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to GBK';

create function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to ISO-8859 2-16';

create function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to LATIN1';

create function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to JOHAB';

create function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to KOI8R';

create function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to KOI8U';

create function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to SHIFT_JIS_2004';

create function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to SJIS';

create function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to UHC';

create function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to WIN';

create function pg_catalog.uuid_cmp(uuid, uuid) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_cmp(uuid, uuid) is 'less-equal-greater';

create function pg_catalog.uuid_eq(uuid, uuid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_eq(uuid, uuid) is 'implementation of = operator';

create function pg_catalog.uuid_ge(uuid, uuid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_ge(uuid, uuid) is 'implementation of >= operator';

create function pg_catalog.uuid_gt(uuid, uuid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_gt(uuid, uuid) is 'implementation of > operator';

create function pg_catalog.uuid_hash(uuid) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_hash(uuid) is 'hash';

create function pg_catalog.uuid_hash_extended(uuid, bigint) returns bigint
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_hash_extended(uuid, bigint) is 'hash';

create function pg_catalog.uuid_in(cstring) returns uuid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_in(cstring) is 'I/O';

create function pg_catalog.uuid_le(uuid, uuid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_le(uuid, uuid) is 'implementation of <= operator';

create function pg_catalog.uuid_lt(uuid, uuid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_lt(uuid, uuid) is 'implementation of < operator';

create function pg_catalog.uuid_ne(uuid, uuid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_ne(uuid, uuid) is 'implementation of <> operator';

create function pg_catalog.uuid_out(uuid) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_out(uuid) is 'I/O';

create function pg_catalog.uuid_recv(internal) returns uuid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_recv(internal) is 'I/O';

create function pg_catalog.uuid_send(uuid) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_send(uuid) is 'I/O';

create function pg_catalog.uuid_sortsupport(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_sortsupport(internal) is 'sort support';

create function pg_catalog.varbit(bit varying, integer, boolean) returns bit varying
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit(bit varying, integer, boolean) is 'adjust varbit() to typmod length';

create function pg_catalog.varbit_in(cstring, oid, integer) returns bit varying
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_in(cstring, oid, integer) is 'I/O';

create function pg_catalog.varbit_out(bit varying) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_out(bit varying) is 'I/O';

create function pg_catalog.varbit_recv(internal, oid, integer) returns bit varying
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_recv(internal, oid, integer) is 'I/O';

create function pg_catalog.varbit_send(bit varying) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_send(bit varying) is 'I/O';

create function pg_catalog.varbit_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_support(internal) is 'planner support for varbit length coercion';

create function pg_catalog.varbitcmp(bit varying, bit varying) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitcmp(bit varying, bit varying) is 'less-equal-greater';

create function pg_catalog.varbiteq(bit varying, bit varying) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbiteq(bit varying, bit varying) is 'implementation of = operator';

create function pg_catalog.varbitge(bit varying, bit varying) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitge(bit varying, bit varying) is 'implementation of >= operator';

create function pg_catalog.varbitgt(bit varying, bit varying) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitgt(bit varying, bit varying) is 'implementation of > operator';

create function pg_catalog.varbitle(bit varying, bit varying) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitle(bit varying, bit varying) is 'implementation of <= operator';

create function pg_catalog.varbitlt(bit varying, bit varying) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitlt(bit varying, bit varying) is 'implementation of < operator';

create function pg_catalog.varbitne(bit varying, bit varying) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitne(bit varying, bit varying) is 'implementation of <> operator';

create function pg_catalog.varbittypmodin(cstring[]) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbittypmodin(cstring[]) is 'I/O typmod';

create function pg_catalog.varbittypmodout(integer) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbittypmodout(integer) is 'I/O typmod';

create function pg_catalog.varchar(name) returns varchar
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar(name) is 'convert name to varchar';

create function pg_catalog.varchar(varchar, integer, boolean) returns varchar
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar(varchar, integer, boolean) is 'adjust varchar() to typmod length';

create function pg_catalog.varchar_support(internal) returns internal
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar_support(internal) is 'planner support for varchar length coercion';

create function pg_catalog.varcharin(cstring, oid, integer) returns varchar
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharin(cstring, oid, integer) is 'I/O';

create function pg_catalog.varcharout(varchar) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharout(varchar) is 'I/O';

create function pg_catalog.varcharrecv(internal, oid, integer) returns varchar
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharrecv(internal, oid, integer) is 'I/O';

create function pg_catalog.varcharsend(varchar) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharsend(varchar) is 'I/O';

create function pg_catalog.varchartypmodin(cstring[]) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchartypmodin(cstring[]) is 'I/O typmod';

create function pg_catalog.varchartypmodout(integer) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchartypmodout(integer) is 'I/O typmod';

create function pg_catalog.version() returns text
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.version() is 'PostgreSQL version string';

create function pg_catalog.void_in(cstring) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_in(cstring) is 'I/O';

create function pg_catalog.void_out(void) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_out(void) is 'I/O';

create function pg_catalog.void_recv(internal) returns void
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_recv(internal) is 'I/O';

create function pg_catalog.void_send(void) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_send(void) is 'I/O';

create function pg_catalog.websearch_to_tsquery(regconfig, text) returns tsquery
    immutable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.websearch_to_tsquery(regconfig, text) is 'transform to tsquery';

create function pg_catalog.websearch_to_tsquery(text) returns tsquery
    stable
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.websearch_to_tsquery(text) is 'transform to tsquery';

create function pg_catalog.width(box) returns double precision
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width(box) is 'box width';

create function pg_catalog.width_bucket(anyelement, anyarray) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket(anyelement, anyarray) is 'bucket number of operand given a sorted array of bucket lower bounds';

create function pg_catalog.width_bucket(double precision, double precision, double precision, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket(double precision, double precision, double precision, integer) is 'bucket number of operand in equal-width histogram';

create function pg_catalog.width_bucket(numeric, numeric, numeric, integer) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket(numeric, numeric, numeric, integer) is 'bucket number of operand in equal-width histogram';

create function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1250 to LATIN2';

create function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1250 to MULE_INTERNAL';

create function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1251 to ISO-8859-5';

create function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1251 to KOI8R';

create function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1251 to MULE_INTERNAL';

create function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1251 to WIN866';

create function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN866 to ISO-8859-5';

create function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN866 to KOI8R';

create function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN866 to MULE_INTERNAL';

create function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN866 to WIN1251';

create function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer) returns void
    immutable
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN to UTF8';

create function pg_catalog.xid(xid8) returns xid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid(xid8) is 'convert xid8 to xid';

create function pg_catalog.xid8cmp(xid8, xid8) returns integer
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8cmp(xid8, xid8) is 'less-equal-greater';

create function pg_catalog.xid8eq(xid8, xid8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8eq(xid8, xid8) is 'implementation of = operator';

create function pg_catalog.xid8ge(xid8, xid8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8ge(xid8, xid8) is 'implementation of >= operator';

create function pg_catalog.xid8gt(xid8, xid8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8gt(xid8, xid8) is 'implementation of > operator';

create function pg_catalog.xid8in(cstring) returns xid8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8in(cstring) is 'I/O';

create function pg_catalog.xid8le(xid8, xid8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8le(xid8, xid8) is 'implementation of <= operator';

create function pg_catalog.xid8lt(xid8, xid8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8lt(xid8, xid8) is 'implementation of < operator';

create function pg_catalog.xid8ne(xid8, xid8) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8ne(xid8, xid8) is 'implementation of <> operator';

create function pg_catalog.xid8out(xid8) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8out(xid8) is 'I/O';

create function pg_catalog.xid8recv(internal) returns xid8
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8recv(internal) is 'I/O';

create function pg_catalog.xid8send(xid8) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8send(xid8) is 'I/O';

create function pg_catalog.xideq(xid, xid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xideq(xid, xid) is 'implementation of = operator';

create function pg_catalog.xideqint4(xid, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xideqint4(xid, integer) is 'implementation of = operator';

create function pg_catalog.xidin(cstring) returns xid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidin(cstring) is 'I/O';

create function pg_catalog.xidneq(xid, xid) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidneq(xid, xid) is 'implementation of <> operator';

create function pg_catalog.xidneqint4(xid, integer) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidneqint4(xid, integer) is 'implementation of <> operator';

create function pg_catalog.xidout(xid) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidout(xid) is 'I/O';

create function pg_catalog.xidrecv(internal) returns xid
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidrecv(internal) is 'I/O';

create function pg_catalog.xidsend(xid) returns bytea
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidsend(xid) is 'I/O';

create function pg_catalog.xml(text) returns xml
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml(text) is 'perform a non-validating parse of a character string to produce an XML value';

create function pg_catalog.xml_in(cstring) returns xml
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_in(cstring) is 'I/O';

create function pg_catalog.xml_is_well_formed(text) returns boolean
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed(text) is 'determine if a string is well formed XML';

create function pg_catalog.xml_is_well_formed_content(text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed_content(text) is 'determine if a string is well formed XML content';

create function pg_catalog.xml_is_well_formed_document(text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed_document(text) is 'determine if a string is well formed XML document';

create function pg_catalog.xml_out(xml) returns cstring
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_out(xml) is 'I/O';

create function pg_catalog.xml_recv(internal) returns xml
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_recv(internal) is 'I/O';

create function pg_catalog.xml_send(xml) returns bytea
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_send(xml) is 'I/O';

create function pg_catalog.xmlcomment(text) returns xml
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlcomment(text) is 'generate XML comment';

create function pg_catalog.xmlconcat2(xml, xml) returns xml
    immutable
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlconcat2(xml, xml) is 'aggregate transition function';

create function pg_catalog.xmlexists(text, xml) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlexists(text, xml) is 'test XML value against XPath expression';

create function pg_catalog.xmlvalidate(xml, text) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlvalidate(xml, text) is 'validate an XML value';

create function pg_catalog.xpath(text, xml) returns xml[]
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath(text, xml) is 'evaluate XPath expression';

create function pg_catalog.xpath(text, xml, text[]) returns xml[]
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath(text, xml, text[]) is 'evaluate XPath expression, with namespaces support';

create function pg_catalog.xpath_exists(text, xml) returns boolean
    immutable
    strict
    cost 1
    language sql
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath_exists(text, xml) is 'test XML value against XPath expression';

create function pg_catalog.xpath_exists(text, xml, text[]) returns boolean
    immutable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath_exists(text, xml, text[]) is 'test XML value against XPath expression, with namespace support';

create operator = (procedure = geometry_eq, leftarg = geometry, rightarg = geometry, commutator = =, join = contjoinsel, restrict = contsel, hashes, merges);

alter operator =(geometry, geometry) owner to postgres;

create operator && (procedure = geometry_overlaps, leftarg = geometry, rightarg = geometry, commutator = &&, join = gserialized_gist_joinsel_2d, restrict = gserialized_gist_sel_2d);

alter operator &&(geometry, geometry) owner to postgres;

create operator ~= (procedure = geometry_same, leftarg = geometry, rightarg = geometry, join = contjoinsel, restrict = contsel);

alter operator ~=(geometry, geometry) owner to postgres;

create operator <-> (procedure = geometry_distance_centroid, leftarg = geometry, rightarg = geometry, commutator = <->);

alter operator <->(geometry, geometry) owner to postgres;

create operator <#> (procedure = geometry_distance_box, leftarg = geometry, rightarg = geometry, commutator = <#>);

alter operator <#>(geometry, geometry) owner to postgres;

create operator &< (procedure = geometry_overleft, leftarg = geometry, rightarg = geometry, join = positionjoinsel, restrict = positionsel);

alter operator &<(geometry, geometry) owner to postgres;

create operator &<| (procedure = geometry_overbelow, leftarg = geometry, rightarg = geometry, join = positionjoinsel, restrict = positionsel);

alter operator &<|(geometry, geometry) owner to postgres;

create operator &> (procedure = geometry_overright, leftarg = geometry, rightarg = geometry, join = positionjoinsel, restrict = positionsel);

alter operator &>(geometry, geometry) owner to postgres;

create operator |&> (procedure = geometry_overabove, leftarg = geometry, rightarg = geometry, join = positionjoinsel, restrict = positionsel);

alter operator |&>(geometry, geometry) owner to postgres;

create operator &&& (procedure = geometry_overlaps_nd, leftarg = geometry, rightarg = geometry, commutator = &&&, join = gserialized_gist_joinsel_nd, restrict = gserialized_gist_sel_nd);

alter operator &&&(geometry, geometry) owner to postgres;

create operator ~~= (procedure = geometry_same_nd, leftarg = geometry, rightarg = geometry, commutator = ~~=, join = gserialized_gist_joinsel_nd, restrict = gserialized_gist_sel_nd);

alter operator ~~=(geometry, geometry) owner to postgres;

create operator <<->> (procedure = geometry_distance_centroid_nd, leftarg = geometry, rightarg = geometry, commutator = <<->>);

alter operator <<->>(geometry, geometry) owner to postgres;

create operator |=| (procedure = geometry_distance_cpa, leftarg = geometry, rightarg = geometry, commutator = |=|);

alter operator |=|(geometry, geometry) owner to postgres;

create operator && (procedure = geography_overlaps, leftarg = geography, rightarg = geography, commutator = &&, join = gserialized_gist_joinsel_nd, restrict = gserialized_gist_sel_nd);

alter operator &&(geography, geography) owner to postgres;

create operator <-> (procedure = geography_distance_knn, leftarg = geography, rightarg = geography, commutator = <->);

alter operator <->(geography, geography) owner to postgres;

create operator && (procedure = overlaps_geog, leftarg = gidx, rightarg = gidx, commutator = &&);

alter operator &&(gidx, gidx) owner to postgres;

create operator = (procedure = geography_eq, leftarg = geography, rightarg = geography, commutator = =, join = contjoinsel, restrict = contsel);

alter operator =(geography, geography) owner to postgres;

create operator && (procedure = overlaps_2d, leftarg = box2df, rightarg = box2df, commutator = &&);

alter operator &&(box2df, box2df) owner to postgres;

create operator &&& (procedure = overlaps_nd, leftarg = gidx, rightarg = gidx, commutator = &&&);

alter operator &&&(gidx, gidx) owner to postgres;

create operator &/& (procedure = geometry_overlaps_3d, leftarg = geometry, rightarg = geometry, commutator = &/&, join = gserialized_gist_joinsel_nd, restrict = gserialized_gist_sel_nd);

alter operator &/&(geometry, geometry) owner to postgres;

create operator ~== (procedure = geometry_same_3d, leftarg = geometry, rightarg = geometry, commutator = ~==, join = gserialized_gist_joinsel_nd, restrict = gserialized_gist_sel_nd);

alter operator ~==(geometry, geometry) owner to postgres;

create operator = (procedure = raster_eq, leftarg = raster, rightarg = raster, commutator = =, join = eqjoinsel, restrict = eqsel);

alter operator =(raster, raster) owner to postgres;

create operator && (procedure = raster_overlap, leftarg = raster, rightarg = raster, commutator = &&, join = contjoinsel, restrict = contsel);

alter operator &&(raster, raster) owner to postgres;

create operator ~= (procedure = raster_same, leftarg = raster, rightarg = raster, commutator = ~=, join = eqjoinsel, restrict = eqsel);

alter operator ~=(raster, raster) owner to postgres;

create operator ~ (procedure = geometry_raster_contain, leftarg = geometry, rightarg = raster, join = contjoinsel, restrict = contsel);

alter operator ~(geometry, raster) owner to postgres;

create operator @ (procedure = raster_contained_by_geometry, leftarg = raster, rightarg = geometry, commutator = ~, join = contjoinsel, restrict = contsel);

alter operator @(raster, geometry) owner to postgres;

create operator pg_catalog.!! (procedure = pg_catalog.numeric_fac, rightarg = bigint);

comment on operator pg_catalog.!!(none, bigint) is 'deprecated, use factorial() instead';

create operator pg_catalog.!! (procedure = pg_catalog.tsquery_not, rightarg = tsquery);

comment on operator pg_catalog.!!(none, tsquery) is 'NOT tsquery';

create operator pg_catalog.! (procedure = pg_catalog.numeric_fac, leftarg = bigint);

comment on operator pg_catalog.!(bigint, none) is 'deprecated, use factorial() instead';

create operator pg_catalog.## (procedure = pg_catalog.close_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.##(line, box) is 'closest point to A on B';

create operator pg_catalog.## (procedure = pg_catalog.close_ls, leftarg = line, rightarg = lseg);

comment on operator pg_catalog.##(line, lseg) is 'closest point to A on B';

create operator pg_catalog.## (procedure = pg_catalog.close_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.##(lseg, box) is 'closest point to A on B';

create operator pg_catalog.## (procedure = pg_catalog.close_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.##(lseg, line) is 'closest point to A on B';

create operator pg_catalog.## (procedure = pg_catalog.close_lseg, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.##(lseg, lseg) is 'closest point to A on B';

create operator pg_catalog.## (procedure = pg_catalog.close_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.##(point, box) is 'closest point to A on B';

create operator pg_catalog.## (procedure = pg_catalog.close_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.##(point, line) is 'closest point to A on B';

create operator pg_catalog.## (procedure = pg_catalog.close_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.##(point, lseg) is 'closest point to A on B';

create operator pg_catalog.# (procedure = pg_catalog.int8xor, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.#);

comment on operator pg_catalog.#(bigint, bigint) is 'bitwise exclusive or';

create operator pg_catalog.# (procedure = pg_catalog.bitxor, leftarg = bit, rightarg = bit, commutator = pg_catalog.#);

comment on operator pg_catalog.#(bit, bit) is 'bitwise exclusive or';

create operator pg_catalog.# (procedure = pg_catalog.box_intersect, leftarg = box, rightarg = box);

comment on operator pg_catalog.#(box, box) is 'box intersection';

create operator pg_catalog.# (procedure = pg_catalog.int4xor, leftarg = integer, rightarg = integer, commutator = pg_catalog.#);

comment on operator pg_catalog.#(integer, integer) is 'bitwise exclusive or';

create operator pg_catalog.# (procedure = pg_catalog.line_interpt, leftarg = line, rightarg = line, commutator = pg_catalog.#);

comment on operator pg_catalog.#(line, line) is 'intersection point';

create operator pg_catalog.# (procedure = pg_catalog.lseg_interpt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.#);

comment on operator pg_catalog.#(lseg, lseg) is 'intersection point';

create operator pg_catalog.# (procedure = pg_catalog.int2xor, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.#);

comment on operator pg_catalog.#(smallint, smallint) is 'bitwise exclusive or';

create operator pg_catalog.# (procedure = pg_catalog.path_npoints, rightarg = path);

comment on operator pg_catalog.#(none, path) is 'number of points';

create operator pg_catalog.# (procedure = pg_catalog.poly_npoints, rightarg = polygon);

comment on operator pg_catalog.#(none, polygon) is 'number of points';

create operator pg_catalog.#- (procedure = pg_catalog.jsonb_delete_path, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#-(jsonb, text[]) is 'delete path';

create operator pg_catalog.#> (procedure = pg_catalog.json_extract_path, leftarg = json, rightarg = text[]);

comment on operator pg_catalog.#>(json, text[]) is 'get value from json with path elements';

create operator pg_catalog.#> (procedure = pg_catalog.jsonb_extract_path, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#>(jsonb, text[]) is 'get value from jsonb with path elements';

create operator pg_catalog.#>> (procedure = pg_catalog.json_extract_path_text, leftarg = json, rightarg = text[]);

comment on operator pg_catalog.#>>(json, text[]) is 'get value from json as text with path elements';

create operator pg_catalog.#>> (procedure = pg_catalog.jsonb_extract_path_text, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#>>(jsonb, text[]) is 'get value from jsonb as text with path elements';

create operator pg_catalog.% (procedure = pg_catalog.int8mod, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.%(bigint, bigint) is 'modulus';

create operator pg_catalog.% (procedure = pg_catalog.int4mod, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.%(integer, integer) is 'modulus';

create operator pg_catalog.% (procedure = pg_catalog.numeric_mod, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.%(numeric, numeric) is 'modulus';

create operator pg_catalog.% (procedure = pg_catalog.int2mod, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.%(smallint, smallint) is 'modulus';

create operator pg_catalog.&& (procedure = pg_catalog.arrayoverlap, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.&&, join = pg_catalog.arraycontjoinsel, restrict = pg_catalog.arraycontsel);

comment on operator pg_catalog.&&(anyarray, anyarray) is 'overlaps';

create operator pg_catalog.&& (procedure = pg_catalog.range_overlaps, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.&&(anyrange, anyrange) is 'overlaps';

create operator pg_catalog.&& (procedure = pg_catalog.box_overlap, leftarg = box, rightarg = box, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.&&(box, box) is 'overlaps';

create operator pg_catalog.&& (procedure = pg_catalog.circle_overlap, leftarg = circle, rightarg = circle, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.&&(circle, circle) is 'overlaps';

create operator pg_catalog.&& (procedure = pg_catalog.network_overlap, leftarg = inet, rightarg = inet, commutator = pg_catalog.&&, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.&&(inet, inet) is 'overlaps (is subnet or supernet)';

create operator pg_catalog.&& (procedure = pg_catalog.poly_overlap, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.&&(polygon, polygon) is 'overlaps';

create operator pg_catalog.&& (procedure = pg_catalog.tsquery_and, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.&&(tsquery, tsquery) is 'AND-concatenate';

create operator pg_catalog.& (procedure = pg_catalog.int8and, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.&);

comment on operator pg_catalog.&(bigint, bigint) is 'bitwise and';

create operator pg_catalog.& (procedure = pg_catalog.bitand, leftarg = bit, rightarg = bit, commutator = pg_catalog.&);

comment on operator pg_catalog.&(bit, bit) is 'bitwise and';

create operator pg_catalog.& (procedure = pg_catalog.inetand, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.&(inet, inet) is 'bitwise and';

create operator pg_catalog.& (procedure = pg_catalog.int4and, leftarg = integer, rightarg = integer, commutator = pg_catalog.&);

comment on operator pg_catalog.&(integer, integer) is 'bitwise and';

create operator pg_catalog.& (procedure = pg_catalog.macaddr_and, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.&(macaddr, macaddr) is 'bitwise and';

create operator pg_catalog.& (procedure = pg_catalog.macaddr8_and, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.&(macaddr8, macaddr8) is 'bitwise and';

create operator pg_catalog.& (procedure = pg_catalog.int2and, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.&);

comment on operator pg_catalog.&(smallint, smallint) is 'bitwise and';

create operator pg_catalog.&< (procedure = pg_catalog.range_overleft, leftarg = anyrange, rightarg = anyrange, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.&<(anyrange, anyrange) is 'overlaps or is left of';

create operator pg_catalog.&< (procedure = pg_catalog.box_overleft, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<(box, box) is 'overlaps or is left of';

create operator pg_catalog.&< (procedure = pg_catalog.circle_overleft, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<(circle, circle) is 'overlaps or is left of';

create operator pg_catalog.&< (procedure = pg_catalog.poly_overleft, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<(polygon, polygon) is 'overlaps or is left of';

create operator pg_catalog.&<| (procedure = pg_catalog.box_overbelow, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<|(box, box) is 'overlaps or is below';

create operator pg_catalog.&<| (procedure = pg_catalog.circle_overbelow, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<|(circle, circle) is 'overlaps or is below';

create operator pg_catalog.&<| (procedure = pg_catalog.poly_overbelow, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<|(polygon, polygon) is 'overlaps or is below';

create operator pg_catalog.&> (procedure = pg_catalog.range_overright, leftarg = anyrange, rightarg = anyrange, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.&>(anyrange, anyrange) is 'overlaps or is right of';

create operator pg_catalog.&> (procedure = pg_catalog.box_overright, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&>(box, box) is 'overlaps or is right of';

create operator pg_catalog.&> (procedure = pg_catalog.circle_overright, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&>(circle, circle) is 'overlaps or is right of';

create operator pg_catalog.&> (procedure = pg_catalog.poly_overright, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&>(polygon, polygon) is 'overlaps or is right of';

create operator pg_catalog.* (procedure = pg_catalog.range_intersect, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.*);

comment on operator pg_catalog.*(anyrange, anyrange) is 'range intersection';

create operator pg_catalog.* (procedure = pg_catalog.int8mul, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, bigint) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.int84mul, leftarg = bigint, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, integer) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.int8_mul_cash, leftarg = bigint, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, money) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.int82mul, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, smallint) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.box_mul, leftarg = box, rightarg = point);

comment on operator pg_catalog.*(box, point) is 'multiply box by point (scale)';

create operator pg_catalog.* (procedure = pg_catalog.circle_mul_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.*(circle, point) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.float8mul, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, double precision) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.mul_d_interval, leftarg = double precision, rightarg = interval, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, interval) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.flt8_mul_cash, leftarg = double precision, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, money) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.float84mul, leftarg = double precision, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, real) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.int48mul, leftarg = integer, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, bigint) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.int4mul, leftarg = integer, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, integer) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.int4_mul_cash, leftarg = integer, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, money) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.int42mul, leftarg = integer, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, smallint) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.interval_mul, leftarg = interval, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(interval, double precision) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_int8, leftarg = money, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, bigint) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_flt8, leftarg = money, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, double precision) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_int4, leftarg = money, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, integer) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_flt4, leftarg = money, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, real) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_int2, leftarg = money, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, smallint) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.numeric_mul, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.*);

comment on operator pg_catalog.*(numeric, numeric) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.path_mul_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.*(path, point) is 'multiply (rotate/scale path)';

create operator pg_catalog.* (procedure = pg_catalog.point_mul, leftarg = point, rightarg = point, commutator = pg_catalog.*);

comment on operator pg_catalog.*(point, point) is 'multiply points (scale/rotate)';

create operator pg_catalog.* (procedure = pg_catalog.float48mul, leftarg = real, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, double precision) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.flt4_mul_cash, leftarg = real, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, money) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.float4mul, leftarg = real, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, real) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.int28mul, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, bigint) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.int24mul, leftarg = smallint, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, integer) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.int2_mul_cash, leftarg = smallint, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, money) is 'multiply';

create operator pg_catalog.* (procedure = pg_catalog.int2mul, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, smallint) is 'multiply';

create operator pg_catalog.+ (procedure = pg_catalog.aclinsert, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.+(aclitem[], aclitem) is 'add/update ACL item';

create operator pg_catalog.+ (procedure = pg_catalog.range_union, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.+);

comment on operator pg_catalog.+(anyrange, anyrange) is 'range union';

create operator pg_catalog.+ (procedure = pg_catalog.int8pl, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, bigint) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.int8pl_inet, leftarg = bigint, rightarg = inet, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, inet) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.int84pl, leftarg = bigint, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, integer) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.int82pl, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, smallint) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.box_add, leftarg = box, rightarg = point);

comment on operator pg_catalog.+(box, point) is 'add point to box (translate)';

create operator pg_catalog.+ (procedure = pg_catalog.circle_add_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.+(circle, point) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.integer_pl_date, leftarg = integer, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, date) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.date_pli, leftarg = date, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, integer) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.date_pl_interval, leftarg = date, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, interval) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.datetimetz_pl, leftarg = date, rightarg = time with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, time with time zone) is 'convert date and time with time zone to timestamp with time zone';

create operator pg_catalog.+ (procedure = pg_catalog.datetime_pl, leftarg = date, rightarg = time, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, time) is 'convert date and time to timestamp';

create operator pg_catalog.+ (procedure = pg_catalog.float8pl, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.+);

comment on operator pg_catalog.+(double precision, double precision) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.float84pl, leftarg = double precision, rightarg = real, commutator = pg_catalog.+);

comment on operator pg_catalog.+(double precision, real) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.inetpl, leftarg = inet, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(inet, bigint) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.int48pl, leftarg = integer, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, bigint) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.int4pl, leftarg = integer, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, integer) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.int42pl, leftarg = integer, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, smallint) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_date, leftarg = interval, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, date) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl, leftarg = interval, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, interval) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_timetz, leftarg = interval, rightarg = time with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, time with time zone) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_time, leftarg = interval, rightarg = time, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, time) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_timestamptz, leftarg = interval, rightarg = timestamp with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, timestamp with time zone) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_timestamp, leftarg = interval, rightarg = timestamp, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, timestamp) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.cash_pl, leftarg = money, rightarg = money, commutator = pg_catalog.+);

comment on operator pg_catalog.+(money, money) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.numeric_add, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.+);

comment on operator pg_catalog.+(numeric, numeric) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.path_add, leftarg = path, rightarg = path, commutator = pg_catalog.+);

comment on operator pg_catalog.+(path, path) is 'concatenate';

create operator pg_catalog.+ (procedure = pg_catalog.path_add_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.+(path, point) is 'add (translate path)';

create operator pg_catalog.+ (procedure = pg_catalog.point_add, leftarg = point, rightarg = point, commutator = pg_catalog.+);

comment on operator pg_catalog.+(point, point) is 'add points (translate)';

create operator pg_catalog.+ (procedure = pg_catalog.float48pl, leftarg = real, rightarg = double precision, commutator = pg_catalog.+);

comment on operator pg_catalog.+(real, double precision) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.float4pl, leftarg = real, rightarg = real, commutator = pg_catalog.+);

comment on operator pg_catalog.+(real, real) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.int28pl, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, bigint) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.int24pl, leftarg = smallint, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, integer) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.int2pl, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, smallint) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.timetzdate_pl, leftarg = time with time zone, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time with time zone, date) is 'convert time with time zone and date to timestamp with time zone';

create operator pg_catalog.+ (procedure = pg_catalog.timetz_pl_interval, leftarg = time with time zone, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time with time zone, interval) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.timedate_pl, leftarg = time, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time, date) is 'convert time and date to timestamp';

create operator pg_catalog.+ (procedure = pg_catalog.time_pl_interval, leftarg = time, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time, interval) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.timestamptz_pl_interval, leftarg = timestamp with time zone, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(timestamp with time zone, interval) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.timestamp_pl_interval, leftarg = timestamp, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(timestamp, interval) is 'add';

create operator pg_catalog.+ (procedure = pg_catalog.int8up, rightarg = bigint);

comment on operator pg_catalog.+(none, bigint) is 'unary plus';

create operator pg_catalog.+ (procedure = pg_catalog.float8up, rightarg = double precision);

comment on operator pg_catalog.+(none, double precision) is 'unary plus';

create operator pg_catalog.+ (procedure = pg_catalog.int4up, rightarg = integer);

comment on operator pg_catalog.+(none, integer) is 'unary plus';

create operator pg_catalog.+ (procedure = pg_catalog.numeric_uplus, rightarg = numeric);

comment on operator pg_catalog.+(none, numeric) is 'unary plus';

create operator pg_catalog.+ (procedure = pg_catalog.float4up, rightarg = real);

comment on operator pg_catalog.+(none, real) is 'unary plus';

create operator pg_catalog.+ (procedure = pg_catalog.int2up, rightarg = smallint);

comment on operator pg_catalog.+(none, smallint) is 'unary plus';

create operator pg_catalog.- (procedure = pg_catalog.aclremove, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.-(aclitem[], aclitem) is 'remove ACL item';

create operator pg_catalog.- (procedure = pg_catalog.range_minus, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.-(anyrange, anyrange) is 'range difference';

create operator pg_catalog.- (procedure = pg_catalog.int8mi, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.-(bigint, bigint) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.int84mi, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.-(bigint, integer) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.int82mi, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.-(bigint, smallint) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.box_sub, leftarg = box, rightarg = point);

comment on operator pg_catalog.-(box, point) is 'subtract point from box (translate)';

create operator pg_catalog.- (procedure = pg_catalog.circle_sub_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.-(circle, point) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.date_mi, leftarg = date, rightarg = date);

comment on operator pg_catalog.-(date, date) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.date_mii, leftarg = date, rightarg = integer);

comment on operator pg_catalog.-(date, integer) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.date_mi_interval, leftarg = date, rightarg = interval);

comment on operator pg_catalog.-(date, interval) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.float8mi, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.-(double precision, double precision) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.float84mi, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.-(double precision, real) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.inetmi_int8, leftarg = inet, rightarg = bigint);

comment on operator pg_catalog.-(inet, bigint) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.inetmi, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.-(inet, inet) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.int48mi, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.-(integer, bigint) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.int4mi, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.-(integer, integer) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.int42mi, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.-(integer, smallint) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.interval_mi, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.-(interval, interval) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.jsonb_delete, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.-(jsonb, integer) is 'delete array element';

create operator pg_catalog.- (procedure = pg_catalog.jsonb_delete, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.-(jsonb, text) is 'delete object field';

create operator pg_catalog.- (procedure = pg_catalog.jsonb_delete, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.-(jsonb, text[]) is 'delete object fields';

create operator pg_catalog.- (procedure = pg_catalog.cash_mi, leftarg = money, rightarg = money);

comment on operator pg_catalog.-(money, money) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.numeric_sub, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.-(numeric, numeric) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.path_sub_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.-(path, point) is 'subtract (translate path)';

create operator pg_catalog.- (procedure = pg_catalog.pg_lsn_mi, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.-(pg_lsn, pg_lsn) is 'minus';

create operator pg_catalog.- (procedure = pg_catalog.point_sub, leftarg = point, rightarg = point);

comment on operator pg_catalog.-(point, point) is 'subtract points (translate)';

create operator pg_catalog.- (procedure = pg_catalog.float48mi, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.-(real, double precision) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.float4mi, leftarg = real, rightarg = real);

comment on operator pg_catalog.-(real, real) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.int28mi, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.-(smallint, bigint) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.int24mi, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.-(smallint, integer) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.int2mi, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.-(smallint, smallint) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.timetz_mi_interval, leftarg = time with time zone, rightarg = interval);

comment on operator pg_catalog.-(time with time zone, interval) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.time_mi_interval, leftarg = time, rightarg = interval);

comment on operator pg_catalog.-(time, interval) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.time_mi_time, leftarg = time, rightarg = time);

comment on operator pg_catalog.-(time, time) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.timestamptz_mi_interval, leftarg = timestamp with time zone, rightarg = interval);

comment on operator pg_catalog.-(timestamp with time zone, interval) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.timestamptz_mi, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.-(timestamp with time zone, timestamp with time zone) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.timestamp_mi_interval, leftarg = timestamp, rightarg = interval);

comment on operator pg_catalog.-(timestamp, interval) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.timestamp_mi, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.-(timestamp, timestamp) is 'subtract';

create operator pg_catalog.- (procedure = pg_catalog.int8um, rightarg = bigint);

comment on operator pg_catalog.-(none, bigint) is 'negate';

create operator pg_catalog.- (procedure = pg_catalog.float8um, rightarg = double precision);

comment on operator pg_catalog.-(none, double precision) is 'negate';

create operator pg_catalog.- (procedure = pg_catalog.int4um, rightarg = integer);

comment on operator pg_catalog.-(none, integer) is 'negate';

create operator pg_catalog.- (procedure = pg_catalog.interval_um, rightarg = interval);

comment on operator pg_catalog.-(none, interval) is 'negate';

create operator pg_catalog.- (procedure = pg_catalog.numeric_uminus, rightarg = numeric);

comment on operator pg_catalog.-(none, numeric) is 'negate';

create operator pg_catalog.- (procedure = pg_catalog.float4um, rightarg = real);

comment on operator pg_catalog.-(none, real) is 'negate';

create operator pg_catalog.- (procedure = pg_catalog.int2um, rightarg = smallint);

comment on operator pg_catalog.-(none, smallint) is 'negate';

create operator pg_catalog.-> (procedure = pg_catalog.json_array_element, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->(json, integer) is 'get json array element';

create operator pg_catalog.-> (procedure = pg_catalog.json_object_field, leftarg = json, rightarg = text);

comment on operator pg_catalog.->(json, text) is 'get json object field';

create operator pg_catalog.-> (procedure = pg_catalog.jsonb_array_element, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->(jsonb, integer) is 'get jsonb array element';

create operator pg_catalog.-> (procedure = pg_catalog.jsonb_object_field, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->(jsonb, text) is 'get jsonb object field';

create operator pg_catalog.->> (procedure = pg_catalog.json_array_element_text, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->>(json, integer) is 'get json array element as text';

create operator pg_catalog.->> (procedure = pg_catalog.json_object_field_text, leftarg = json, rightarg = text);

comment on operator pg_catalog.->>(json, text) is 'get json object field as text';

create operator pg_catalog.->> (procedure = pg_catalog.jsonb_array_element_text, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->>(jsonb, integer) is 'get jsonb array element as text';

create operator pg_catalog.->> (procedure = pg_catalog.jsonb_object_field_text, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->>(jsonb, text) is 'get jsonb object field as text';

create operator pg_catalog.-|- (procedure = pg_catalog.range_adjacent, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.-|-, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.-|-(anyrange, anyrange) is 'is adjacent to';

create operator pg_catalog./ (procedure = pg_catalog.int8div, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog./(bigint, bigint) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.int84div, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog./(bigint, integer) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.int82div, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog./(bigint, smallint) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.box_div, leftarg = box, rightarg = point);

comment on operator pg_catalog./(box, point) is 'divide box by point (scale)';

create operator pg_catalog./ (procedure = pg_catalog.circle_div_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog./(circle, point) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.float8div, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog./(double precision, double precision) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.float84div, leftarg = double precision, rightarg = real);

comment on operator pg_catalog./(double precision, real) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.int48div, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog./(integer, bigint) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.int4div, leftarg = integer, rightarg = integer);

comment on operator pg_catalog./(integer, integer) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.int42div, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog./(integer, smallint) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.interval_div, leftarg = interval, rightarg = double precision);

comment on operator pg_catalog./(interval, double precision) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.cash_div_int8, leftarg = money, rightarg = bigint);

comment on operator pg_catalog./(money, bigint) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.cash_div_flt8, leftarg = money, rightarg = double precision);

comment on operator pg_catalog./(money, double precision) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.cash_div_int4, leftarg = money, rightarg = integer);

comment on operator pg_catalog./(money, integer) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.cash_div_cash, leftarg = money, rightarg = money);

comment on operator pg_catalog./(money, money) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.cash_div_flt4, leftarg = money, rightarg = real);

comment on operator pg_catalog./(money, real) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.cash_div_int2, leftarg = money, rightarg = smallint);

comment on operator pg_catalog./(money, smallint) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.numeric_div, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog./(numeric, numeric) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.path_div_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog./(path, point) is 'divide (rotate/scale path)';

create operator pg_catalog./ (procedure = pg_catalog.point_div, leftarg = point, rightarg = point);

comment on operator pg_catalog./(point, point) is 'divide points (scale/rotate)';

create operator pg_catalog./ (procedure = pg_catalog.float48div, leftarg = real, rightarg = double precision);

comment on operator pg_catalog./(real, double precision) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.float4div, leftarg = real, rightarg = real);

comment on operator pg_catalog./(real, real) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.int28div, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog./(smallint, bigint) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.int24div, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog./(smallint, integer) is 'divide';

create operator pg_catalog./ (procedure = pg_catalog.int2div, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog./(smallint, smallint) is 'divide';

create operator pg_catalog.<-> (procedure = pg_catalog.box_distance, leftarg = box, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, box) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_bl, leftarg = box, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, line) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_bs, leftarg = box, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, lseg) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_bp, leftarg = box, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, point) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.circle_distance, leftarg = circle, rightarg = circle, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(circle, circle) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_cpoint, leftarg = circle, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(circle, point) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_cpoly, leftarg = circle, rightarg = polygon, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(circle, polygon) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_lb, leftarg = line, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, box) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.line_distance, leftarg = line, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, line) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_ls, leftarg = line, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, lseg) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_lp, leftarg = line, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, point) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_sb, leftarg = lseg, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, box) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_sl, leftarg = lseg, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, line) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.lseg_distance, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, lseg) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_sp, leftarg = lseg, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, point) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.path_distance, leftarg = path, rightarg = path, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(path, path) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_pathp, leftarg = path, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(path, point) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_pb, leftarg = point, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, box) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_pc, leftarg = point, rightarg = circle, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, circle) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_pl, leftarg = point, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, line) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_ps, leftarg = point, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, lseg) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_ppath, leftarg = point, rightarg = path, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, path) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.point_distance, leftarg = point, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, point) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_ppoly, leftarg = point, rightarg = polygon, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, polygon) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_polyc, leftarg = polygon, rightarg = circle, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(polygon, circle) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.dist_polyp, leftarg = polygon, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(polygon, point) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.poly_distance, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(polygon, polygon) is 'distance between';

create operator pg_catalog.<-> (procedure = pg_catalog.tsquery_phrase, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<->(tsquery, tsquery) is 'phrase-concatenate';

create operator pg_catalog.<< (procedure = pg_catalog.int8shl, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<<(bigint, integer) is 'bitwise shift left';

create operator pg_catalog.<< (procedure = pg_catalog.bitshiftleft, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.<<(bit, integer) is 'bitwise shift left';

create operator pg_catalog.<< (procedure = pg_catalog.box_left, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(box, box) is 'is left of';

create operator pg_catalog.<< (procedure = pg_catalog.circle_left, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(circle, circle) is 'is left of';

create operator pg_catalog.<< (procedure = pg_catalog.int4shl, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<<(integer, integer) is 'bitwise shift left';

create operator pg_catalog.<< (procedure = pg_catalog.point_left, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(point, point) is 'is left of';

create operator pg_catalog.<< (procedure = pg_catalog.poly_left, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(polygon, polygon) is 'is left of';

create operator pg_catalog.<< (procedure = pg_catalog.int2shl, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<<(smallint, integer) is 'bitwise shift left';

create operator pg_catalog.<<| (procedure = pg_catalog.box_below, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<|(box, box) is 'is below';

create operator pg_catalog.<<| (procedure = pg_catalog.circle_below, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<|(circle, circle) is 'is below';

create operator pg_catalog.<<| (procedure = pg_catalog.poly_below, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<|(polygon, polygon) is 'is below';

create operator pg_catalog.<@ (procedure = pg_catalog.on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.<@(lseg, box) is 'is contained by';

create operator pg_catalog.<@ (procedure = pg_catalog.on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.<@(lseg, line) is 'lseg on line';

create operator pg_catalog.<@ (procedure = pg_catalog.on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.<@(point, line) is 'point on line';

create operator pg_catalog.<@ (procedure = pg_catalog.on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.<@(point, lseg) is 'is contained by';

create operator pg_catalog.<^ (procedure = pg_catalog.box_below_eq, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<^(box, box) is 'is below (allows touching)';

create operator pg_catalog.<^ (procedure = pg_catalog.point_below, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<^(point, point) is 'is below';

create operator pg_catalog.>> (procedure = pg_catalog.int8shr, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>>(bigint, integer) is 'bitwise shift right';

create operator pg_catalog.>> (procedure = pg_catalog.bitshiftright, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.>>(bit, integer) is 'bitwise shift right';

create operator pg_catalog.>> (procedure = pg_catalog.box_right, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(box, box) is 'is right of';

create operator pg_catalog.>> (procedure = pg_catalog.circle_right, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(circle, circle) is 'is right of';

create operator pg_catalog.>> (procedure = pg_catalog.int4shr, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>>(integer, integer) is 'bitwise shift right';

create operator pg_catalog.>> (procedure = pg_catalog.point_right, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(point, point) is 'is right of';

create operator pg_catalog.>> (procedure = pg_catalog.poly_right, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(polygon, polygon) is 'is right of';

create operator pg_catalog.>> (procedure = pg_catalog.int2shr, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>>(smallint, integer) is 'bitwise shift right';

create operator pg_catalog.>^ (procedure = pg_catalog.box_above_eq, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>^(box, box) is 'is above (allows touching)';

create operator pg_catalog.>^ (procedure = pg_catalog.point_above, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>^(point, point) is 'is above';

create operator pg_catalog.?# (procedure = pg_catalog.box_overlap, leftarg = box, rightarg = box, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.?#(box, box) is 'deprecated, use && instead';

create operator pg_catalog.?# (procedure = pg_catalog.inter_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.?#(line, box) is 'intersect';

create operator pg_catalog.?# (procedure = pg_catalog.line_intersect, leftarg = line, rightarg = line, commutator = pg_catalog.?#);

comment on operator pg_catalog.?#(line, line) is 'intersect';

create operator pg_catalog.?# (procedure = pg_catalog.inter_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.?#(lseg, box) is 'intersect';

create operator pg_catalog.?# (procedure = pg_catalog.inter_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.?#(lseg, line) is 'intersect';

create operator pg_catalog.?# (procedure = pg_catalog.lseg_intersect, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?#);

comment on operator pg_catalog.?#(lseg, lseg) is 'intersect';

create operator pg_catalog.?# (procedure = pg_catalog.path_inter, leftarg = path, rightarg = path);

comment on operator pg_catalog.?#(path, path) is 'intersect';

create operator pg_catalog.?& (procedure = pg_catalog.jsonb_exists_all, leftarg = jsonb, rightarg = text[], join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.?&(jsonb, text[]) is 'all keys exist';

create operator pg_catalog.? (procedure = pg_catalog.jsonb_exists, leftarg = jsonb, rightarg = text, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.?(jsonb, text) is 'key exists';

create operator pg_catalog.?- (procedure = pg_catalog.point_horiz, leftarg = point, rightarg = point, commutator = pg_catalog.?-);

comment on operator pg_catalog.?-(point, point) is 'horizontally aligned';

create operator pg_catalog.?- (procedure = pg_catalog.line_horizontal, rightarg = line);

comment on operator pg_catalog.?-(none, line) is 'horizontal';

create operator pg_catalog.?- (procedure = pg_catalog.lseg_horizontal, rightarg = lseg);

comment on operator pg_catalog.?-(none, lseg) is 'horizontal';

create operator pg_catalog.?-| (procedure = pg_catalog.line_perp, leftarg = line, rightarg = line, commutator = pg_catalog.?-|);

comment on operator pg_catalog.?-|(line, line) is 'perpendicular';

create operator pg_catalog.?-| (procedure = pg_catalog.lseg_perp, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?-|);

comment on operator pg_catalog.?-|(lseg, lseg) is 'perpendicular';

create operator pg_catalog.?| (procedure = pg_catalog.jsonb_exists_any, leftarg = jsonb, rightarg = text[], join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.?|(jsonb, text[]) is 'any key exists';

create operator pg_catalog.?| (procedure = pg_catalog.point_vert, leftarg = point, rightarg = point, commutator = pg_catalog.?|);

comment on operator pg_catalog.?|(point, point) is 'vertically aligned';

create operator pg_catalog.?| (procedure = pg_catalog.line_vertical, rightarg = line);

comment on operator pg_catalog.?|(none, line) is 'vertical';

create operator pg_catalog.?| (procedure = pg_catalog.lseg_vertical, rightarg = lseg);

comment on operator pg_catalog.?|(none, lseg) is 'vertical';

create operator pg_catalog.?|| (procedure = pg_catalog.line_parallel, leftarg = line, rightarg = line, commutator = pg_catalog.?||);

comment on operator pg_catalog.?||(line, line) is 'parallel';

create operator pg_catalog.?|| (procedure = pg_catalog.lseg_parallel, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?||);

comment on operator pg_catalog.?||(lseg, lseg) is 'parallel';

create operator pg_catalog.@ (procedure = pg_catalog.on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.@(lseg, box) is 'deprecated, use <@ instead';

create operator pg_catalog.@ (procedure = pg_catalog.on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.@(lseg, line) is 'deprecated, use <@ instead';

create operator pg_catalog.@ (procedure = pg_catalog.on_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.@(point, box) is 'deprecated, use <@ instead';

create operator pg_catalog.@ (procedure = pg_catalog.on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.@(point, line) is 'deprecated, use <@ instead';

create operator pg_catalog.@ (procedure = pg_catalog.on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.@(point, lseg) is 'deprecated, use <@ instead';

create operator pg_catalog.@ (procedure = pg_catalog.int8abs, rightarg = bigint);

comment on operator pg_catalog.@(none, bigint) is 'absolute value';

create operator pg_catalog.@ (procedure = pg_catalog.float8abs, rightarg = double precision);

comment on operator pg_catalog.@(none, double precision) is 'absolute value';

create operator pg_catalog.@ (procedure = pg_catalog.int4abs, rightarg = integer);

comment on operator pg_catalog.@(none, integer) is 'absolute value';

create operator pg_catalog.@ (procedure = pg_catalog.numeric_abs, rightarg = numeric);

comment on operator pg_catalog.@(none, numeric) is 'absolute value';

create operator pg_catalog.@ (procedure = pg_catalog.float4abs, rightarg = real);

comment on operator pg_catalog.@(none, real) is 'absolute value';

create operator pg_catalog.@ (procedure = pg_catalog.int2abs, rightarg = smallint);

comment on operator pg_catalog.@(none, smallint) is 'absolute value';

create operator pg_catalog.@-@ (procedure = pg_catalog.lseg_length, rightarg = lseg);

comment on operator pg_catalog.@-@(none, lseg) is 'distance between endpoints';

create operator pg_catalog.@-@ (procedure = pg_catalog.path_length, rightarg = path);

comment on operator pg_catalog.@-@(none, path) is 'sum of path segment lengths';

create operator pg_catalog.@> (procedure = pg_catalog.aclcontains, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.@>(aclitem[], aclitem) is 'contains';

create operator pg_catalog.@? (procedure = pg_catalog.jsonb_path_exists_opr, leftarg = jsonb, rightarg = jsonpath, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@?(jsonb, jsonpath) is 'jsonpath exists';

create operator pg_catalog.@@ (procedure = pg_catalog.jsonb_path_match_opr, leftarg = jsonb, rightarg = jsonpath, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@@(jsonb, jsonpath) is 'jsonpath match';

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_tt, leftarg = text, rightarg = text, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@@(text, text) is 'text search match';

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_tq, leftarg = text, rightarg = tsquery, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@@(text, tsquery) is 'text search match';

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_vq, leftarg = tsvector, rightarg = tsquery, commutator = pg_catalog.@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@(tsvector, tsquery) is 'text search match';

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_qv, leftarg = tsquery, rightarg = tsvector, commutator = pg_catalog.@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@(tsquery, tsvector) is 'text search match';

create operator pg_catalog.@@ (procedure = pg_catalog.box_center, rightarg = box);

comment on operator pg_catalog.@@(none, box) is 'center of';

create operator pg_catalog.@@ (procedure = pg_catalog.circle_center, rightarg = circle);

comment on operator pg_catalog.@@(none, circle) is 'center of';

create operator pg_catalog.@@ (procedure = pg_catalog.lseg_center, rightarg = lseg);

comment on operator pg_catalog.@@(none, lseg) is 'center of';

create operator pg_catalog.@@ (procedure = pg_catalog.path_center, rightarg = path);

comment on operator pg_catalog.@@(none, path) is 'center of';

create operator pg_catalog.@@ (procedure = pg_catalog.poly_center, rightarg = polygon);

comment on operator pg_catalog.@@(none, polygon) is 'center of';

create operator pg_catalog.@@@ (procedure = pg_catalog.ts_match_vq, leftarg = tsvector, rightarg = tsquery, commutator = pg_catalog.@@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@@(tsvector, tsquery) is 'deprecated, use @@ instead';

create operator pg_catalog.@@@ (procedure = pg_catalog.ts_match_qv, leftarg = tsquery, rightarg = tsvector, commutator = pg_catalog.@@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@@(tsquery, tsvector) is 'deprecated, use @@ instead';

create operator pg_catalog.^ (procedure = pg_catalog.dpow, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.^(double precision, double precision) is 'exponentiation';

create operator pg_catalog.^ (procedure = pg_catalog.numeric_power, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.^(numeric, numeric) is 'exponentiation';

create operator pg_catalog.^@ (procedure = pg_catalog.starts_with, leftarg = text, rightarg = text, join = pg_catalog.prefixjoinsel, restrict = pg_catalog.prefixsel);

comment on operator pg_catalog.^@(text, text) is 'starts with';

create operator pg_catalog.|&> (procedure = pg_catalog.box_overabove, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|&>(box, box) is 'overlaps or is above';

create operator pg_catalog.|&> (procedure = pg_catalog.circle_overabove, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|&>(circle, circle) is 'overlaps or is above';

create operator pg_catalog.|&> (procedure = pg_catalog.poly_overabove, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|&>(polygon, polygon) is 'overlaps or is above';

create operator pg_catalog.| (procedure = pg_catalog.int8or, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.|);

comment on operator pg_catalog.|(bigint, bigint) is 'bitwise or';

create operator pg_catalog.| (procedure = pg_catalog.bitor, leftarg = bit, rightarg = bit, commutator = pg_catalog.|);

comment on operator pg_catalog.|(bit, bit) is 'bitwise or';

create operator pg_catalog.| (procedure = pg_catalog.inetor, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.|(inet, inet) is 'bitwise or';

create operator pg_catalog.| (procedure = pg_catalog.int4or, leftarg = integer, rightarg = integer, commutator = pg_catalog.|);

comment on operator pg_catalog.|(integer, integer) is 'bitwise or';

create operator pg_catalog.| (procedure = pg_catalog.macaddr_or, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.|(macaddr, macaddr) is 'bitwise or';

create operator pg_catalog.| (procedure = pg_catalog.macaddr8_or, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.|(macaddr8, macaddr8) is 'bitwise or';

create operator pg_catalog.| (procedure = pg_catalog.int2or, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.|);

comment on operator pg_catalog.|(smallint, smallint) is 'bitwise or';

create operator pg_catalog.|/ (procedure = pg_catalog.dsqrt, rightarg = double precision);

comment on operator pg_catalog.|/(none, double precision) is 'square root';

create operator pg_catalog.|>> (procedure = pg_catalog.box_above, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|>>(box, box) is 'is above';

create operator pg_catalog.|>> (procedure = pg_catalog.circle_above, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|>>(circle, circle) is 'is above';

create operator pg_catalog.|>> (procedure = pg_catalog.poly_above, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|>>(polygon, polygon) is 'is above';

create operator pg_catalog.|| (procedure = pg_catalog.array_cat, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.||(anyarray, anyarray) is 'concatenate';

create operator pg_catalog.|| (procedure = pg_catalog.array_append, leftarg = anyarray, rightarg = anyelement);

comment on operator pg_catalog.||(anyarray, anyelement) is 'append element onto end of array';

create operator pg_catalog.|| (procedure = pg_catalog.array_prepend, leftarg = anyelement, rightarg = anyarray);

comment on operator pg_catalog.||(anyelement, anyarray) is 'prepend element onto front of array';

create operator pg_catalog.|| (procedure = pg_catalog.anytextcat, leftarg = anynonarray, rightarg = text);

comment on operator pg_catalog.||(anynonarray, text) is 'concatenate';

create operator pg_catalog.|| (procedure = pg_catalog.bitcat, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.||(bit varying, bit varying) is 'concatenate';

create operator pg_catalog.|| (procedure = pg_catalog.byteacat, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.||(bytea, bytea) is 'concatenate';

create operator pg_catalog.|| (procedure = pg_catalog.jsonb_concat, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.||(jsonb, jsonb) is 'concatenate';

create operator pg_catalog.|| (procedure = pg_catalog.textanycat, leftarg = text, rightarg = anynonarray);

comment on operator pg_catalog.||(text, anynonarray) is 'concatenate';

create operator pg_catalog.|| (procedure = pg_catalog.textcat, leftarg = text, rightarg = text);

comment on operator pg_catalog.||(text, text) is 'concatenate';

create operator pg_catalog.|| (procedure = pg_catalog.tsquery_or, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.||(tsquery, tsquery) is 'OR-concatenate';

create operator pg_catalog.|| (procedure = pg_catalog.tsvector_concat, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.||(tsvector, tsvector) is 'concatenate';

create operator pg_catalog.||/ (procedure = pg_catalog.dcbrt, rightarg = double precision);

comment on operator pg_catalog.||/(none, double precision) is 'cube root';

create operator pg_catalog.~ (procedure = pg_catalog.aclcontains, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.~(aclitem[], aclitem) is 'deprecated, use @> instead';

create operator pg_catalog.~ (procedure = pg_catalog.int8not, rightarg = bigint);

comment on operator pg_catalog.~(none, bigint) is 'bitwise not';

create operator pg_catalog.~ (procedure = pg_catalog.bitnot, rightarg = bit);

comment on operator pg_catalog.~(none, bit) is 'bitwise not';

create operator pg_catalog.~ (procedure = pg_catalog.inetnot, rightarg = inet);

comment on operator pg_catalog.~(none, inet) is 'bitwise not';

create operator pg_catalog.~ (procedure = pg_catalog.int4not, rightarg = integer);

comment on operator pg_catalog.~(none, integer) is 'bitwise not';

create operator pg_catalog.~ (procedure = pg_catalog.macaddr_not, rightarg = macaddr);

comment on operator pg_catalog.~(none, macaddr) is 'bitwise not';

create operator pg_catalog.~ (procedure = pg_catalog.macaddr8_not, rightarg = macaddr8);

comment on operator pg_catalog.~(none, macaddr8) is 'bitwise not';

create operator pg_catalog.~ (procedure = pg_catalog.int2not, rightarg = smallint);

comment on operator pg_catalog.~(none, smallint) is 'bitwise not';

create operator pg_catalog.~= (procedure = pg_catalog.box_same, leftarg = box, rightarg = box, commutator = pg_catalog.~=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(box, box) is 'same as';

create operator pg_catalog.~= (procedure = pg_catalog.circle_same, leftarg = circle, rightarg = circle, commutator = pg_catalog.~=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(circle, circle) is 'same as';

create operator pg_catalog.~= (procedure = pg_catalog.poly_same, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.~=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(polygon, polygon) is 'same as';

create aggregate st_extent(geometry) (
    sfunc = st_combinebbox,
    stype = box3d,
    finalfunc = box2d,
    combinefunc = st_combinebbox,
    parallel = safe
    );

comment on aggregate st_extent(geometry) is 'args: geomfield - Aggregate function that returns the bounding box of geometries.';

alter aggregate st_extent(geometry) owner to postgres;

create aggregate st_3dextent(geometry) (
    sfunc = st_combinebbox,
    stype = box3d,
    combinefunc = st_combinebbox,
    parallel = safe
    );

comment on aggregate st_3dextent(geometry) is 'args: geomfield - Aggregate function that returns the 3D bounding box of geometries.';

alter aggregate st_3dextent(geometry) owner to postgres;

create aggregate st_memcollect(geometry) (
    sfunc = st_collect,
    stype = geometry,
    combinefunc = st_collect,
    parallel = safe
    );

alter aggregate st_memcollect(geometry) owner to postgres;

create aggregate st_memunion(geometry) (
    sfunc = st_union,
    stype = geometry,
    combinefunc = st_union,
    parallel = safe
    );

comment on aggregate st_memunion(geometry) is 'args: geomfield - Aggregate function which unions geometries in a memory-efficent but slower way';

alter aggregate st_memunion(geometry) owner to postgres;

create aggregate st_union(geometry) (
    sfunc = pgis_geometry_accum_transfn,
    stype = internal,
    finalfunc = pgis_geometry_union_finalfn,
    parallel = safe
    );

comment on aggregate st_union(geometry) is 'args: g1field - Computes a geometry representing the point-set union of the input geometries.';

alter aggregate st_union(geometry) owner to postgres;

create aggregate st_union(geometry, gridsize double precision) (
    sfunc = pgis_geometry_accum_transfn,
    stype = internal,
    finalfunc = pgis_geometry_union_finalfn,
    parallel = safe
    );

comment on aggregate st_union(geometry, double precision) is 'args: g1field, gridSize - Computes a geometry representing the point-set union of the input geometries.';

alter aggregate st_union(geometry, gridsize double precision) owner to postgres;

create aggregate st_collect(geometry) (
    sfunc = pgis_geometry_accum_transfn,
    stype = internal,
    finalfunc = pgis_geometry_collect_finalfn,
    parallel = safe
    );

comment on aggregate st_collect(geometry) is 'args: g1field - Creates a GeometryCollection or Multi* geometry from a set of geometries.';

alter aggregate st_collect(geometry) owner to postgres;

create aggregate st_clusterintersecting(geometry) (
    sfunc = pgis_geometry_accum_transfn,
    stype = internal,
    finalfunc = pgis_geometry_clusterintersecting_finalfn,
    parallel = safe
    );

comment on aggregate st_clusterintersecting(geometry) is 'args: g - Aggregate function that clusters the input geometries into connected sets.';

alter aggregate st_clusterintersecting(geometry) owner to postgres;

create aggregate st_clusterwithin(geometry, double precision) (
    sfunc = pgis_geometry_accum_transfn,
    stype = internal,
    finalfunc = pgis_geometry_clusterwithin_finalfn,
    parallel = safe
    );

comment on aggregate st_clusterwithin(geometry, double precision) is 'args: g, distance - Aggregate function that clusters the input geometries by separation distance.';

alter aggregate st_clusterwithin(geometry, double precision) owner to postgres;

create aggregate st_polygonize(geometry) (
    sfunc = pgis_geometry_accum_transfn,
    stype = internal,
    finalfunc = pgis_geometry_polygonize_finalfn,
    parallel = safe
    );

comment on aggregate st_polygonize(geometry) is 'args: geomfield - Computes a collection of polygons formed from the linework of a set of geometries.';

alter aggregate st_polygonize(geometry) owner to postgres;

create aggregate st_makeline(geometry) (
    sfunc = pgis_geometry_accum_transfn,
    stype = internal,
    finalfunc = pgis_geometry_makeline_finalfn,
    parallel = safe
    );

comment on aggregate st_makeline(geometry) is 'args: geoms - Creates a LineString from Point, MultiPoint, or LineString geometries.';

alter aggregate st_makeline(geometry) owner to postgres;

create aggregate st_asmvt(anyelement) (
    sfunc = pgis_asmvt_transfn,
    stype = internal,
    finalfunc = pgis_asmvt_finalfn,
    combinefunc = pgis_asmvt_combinefn,
    serialfunc = pgis_asmvt_serialfn,
    deserialfunc = pgis_asmvt_deserialfn,
    parallel = safe
    );

alter aggregate st_asmvt(anyelement) owner to postgres;

create aggregate st_asmvt(anyelement, text) (
    sfunc = pgis_asmvt_transfn,
    stype = internal,
    finalfunc = pgis_asmvt_finalfn,
    combinefunc = pgis_asmvt_combinefn,
    serialfunc = pgis_asmvt_serialfn,
    deserialfunc = pgis_asmvt_deserialfn,
    parallel = safe
    );

alter aggregate st_asmvt(anyelement, text) owner to postgres;

create aggregate st_asmvt(anyelement, text, integer) (
    sfunc = pgis_asmvt_transfn,
    stype = internal,
    finalfunc = pgis_asmvt_finalfn,
    combinefunc = pgis_asmvt_combinefn,
    serialfunc = pgis_asmvt_serialfn,
    deserialfunc = pgis_asmvt_deserialfn,
    parallel = safe
    );

alter aggregate st_asmvt(anyelement, text, integer) owner to postgres;

create aggregate st_asmvt(anyelement, text, integer, text) (
    sfunc = pgis_asmvt_transfn,
    stype = internal,
    finalfunc = pgis_asmvt_finalfn,
    combinefunc = pgis_asmvt_combinefn,
    serialfunc = pgis_asmvt_serialfn,
    deserialfunc = pgis_asmvt_deserialfn,
    parallel = safe
    );

alter aggregate st_asmvt(anyelement, text, integer, text) owner to postgres;

create aggregate st_asmvt(anyelement, text, integer, text, text) (
    sfunc = pgis_asmvt_transfn,
    stype = internal,
    finalfunc = pgis_asmvt_finalfn,
    combinefunc = pgis_asmvt_combinefn,
    serialfunc = pgis_asmvt_serialfn,
    deserialfunc = pgis_asmvt_deserialfn,
    parallel = safe
    );

alter aggregate st_asmvt(anyelement, text, integer, text, text) owner to postgres;

create aggregate st_asgeobuf(anyelement) (
    sfunc = pgis_asgeobuf_transfn,
    stype = internal,
    finalfunc = pgis_asgeobuf_finalfn,
    parallel = safe
    );

alter aggregate st_asgeobuf(anyelement) owner to postgres;

create aggregate st_asgeobuf(anyelement, text) (
    sfunc = pgis_asgeobuf_transfn,
    stype = internal,
    finalfunc = pgis_asgeobuf_finalfn,
    parallel = safe
    );

alter aggregate st_asgeobuf(anyelement, text) owner to postgres;

create aggregate st_asflatgeobuf(anyelement) (
    sfunc = pgis_asflatgeobuf_transfn,
    stype = internal,
    finalfunc = pgis_asflatgeobuf_finalfn,
    parallel = safe
    );

alter aggregate st_asflatgeobuf(anyelement) owner to postgres;

create aggregate st_asflatgeobuf(anyelement, boolean) (
    sfunc = pgis_asflatgeobuf_transfn,
    stype = internal,
    finalfunc = pgis_asflatgeobuf_finalfn,
    parallel = safe
    );

alter aggregate st_asflatgeobuf(anyelement, boolean) owner to postgres;

create aggregate st_asflatgeobuf(anyelement, boolean, text) (
    sfunc = pgis_asflatgeobuf_transfn,
    stype = internal,
    finalfunc = pgis_asflatgeobuf_finalfn,
    parallel = safe
    );

alter aggregate st_asflatgeobuf(anyelement, boolean, text) owner to postgres;

create aggregate st_summarystatsagg(raster, integer, boolean, double precision) (
    sfunc = _st_summarystats_transfn,
    stype = internal,
    finalfunc = _st_summarystats_finalfn,
    parallel = safe
    );

comment on aggregate st_summarystatsagg(raster, integer, boolean, double precision) is 'args: rast, nband, exclude_nodata_value, sample_percent - Aggregate. Returns summarystats consisting of count, sum, mean, stddev, min, max for a given raster band of a set of raster. Band 1 is assumed is no band is specified.';

alter aggregate st_summarystatsagg(raster, integer, boolean, double precision) owner to postgres;

create aggregate st_summarystatsagg(raster, boolean, double precision) (
    sfunc = _st_summarystats_transfn,
    stype = internal,
    finalfunc = _st_summarystats_finalfn,
    parallel = safe
    );

comment on aggregate st_summarystatsagg(raster, boolean, double precision) is 'args: rast, exclude_nodata_value, sample_percent - Aggregate. Returns summarystats consisting of count, sum, mean, stddev, min, max for a given raster band of a set of raster. Band 1 is assumed is no band is specified.';

alter aggregate st_summarystatsagg(raster, boolean, double precision) owner to postgres;

create aggregate st_summarystatsagg(raster, integer, boolean) (
    sfunc = _st_summarystats_transfn,
    stype = internal,
    finalfunc = _st_summarystats_finalfn,
    parallel = safe
    );

comment on aggregate st_summarystatsagg(raster, integer, boolean) is 'args: rast, nband, exclude_nodata_value - Aggregate. Returns summarystats consisting of count, sum, mean, stddev, min, max for a given raster band of a set of raster. Band 1 is assumed is no band is specified.';

alter aggregate st_summarystatsagg(raster, integer, boolean) owner to postgres;

create aggregate st_countagg(raster, integer, boolean, double precision) (
    sfunc = _st_countagg_transfn,
    stype = agg_count,
    finalfunc = _st_countagg_finalfn,
    parallel = safe
    );

comment on aggregate st_countagg(raster, integer, boolean, double precision) is 'args: rast, nband, exclude_nodata_value, sample_percent - Aggregate. Returns the number of pixels in a given band of a set of rasters. If no band is specified defaults to band 1. If exclude_nodata_value is set to true, will only count pixels that are not equal to the NODATA value.';

alter aggregate st_countagg(raster, integer, boolean, double precision) owner to postgres;

create aggregate st_countagg(raster, integer, boolean) (
    sfunc = _st_countagg_transfn,
    stype = agg_count,
    finalfunc = _st_countagg_finalfn,
    parallel = safe
    );

comment on aggregate st_countagg(raster, integer, boolean) is 'args: rast, nband, exclude_nodata_value - Aggregate. Returns the number of pixels in a given band of a set of rasters. If no band is specified defaults to band 1. If exclude_nodata_value is set to true, will only count pixels that are not equal to the NODATA value.';

alter aggregate st_countagg(raster, integer, boolean) owner to postgres;

create aggregate st_countagg(raster, boolean) (
    sfunc = _st_countagg_transfn,
    stype = agg_count,
    finalfunc = _st_countagg_finalfn,
    parallel = safe
    );

comment on aggregate st_countagg(raster, boolean) is 'args: rast, exclude_nodata_value - Aggregate. Returns the number of pixels in a given band of a set of rasters. If no band is specified defaults to band 1. If exclude_nodata_value is set to true, will only count pixels that are not equal to the NODATA value.';

alter aggregate st_countagg(raster, boolean) owner to postgres;

create aggregate st_samealignment(raster) (
    sfunc = _st_samealignment_transfn,
    stype = agg_samealignment,
    finalfunc = _st_samealignment_finalfn,
    parallel = safe
    );

comment on aggregate st_samealignment(raster) is 'args: rastfield - Returns true if rasters have same skew, scale, spatial ref, and offset (pixels can be put on same grid without cutting into pixels) and false if they dont with notice detailing issue.';

alter aggregate st_samealignment(raster) owner to postgres;

create aggregate st_union(raster, unionarg[]) (
    sfunc = _st_union_transfn,
    stype = internal,
    finalfunc = _st_union_finalfn,
    parallel = safe
    );

comment on aggregate st_union(raster, unionarg[]) is 'args: rast, unionargset - Returns the union of a set of raster tiles into a single raster composed of 1 or more bands.';

alter aggregate st_union(raster, unionarg[]) owner to postgres;

create aggregate st_union(raster, integer, text) (
    sfunc = _st_union_transfn,
    stype = internal,
    finalfunc = _st_union_finalfn,
    parallel = safe
    );

comment on aggregate st_union(raster, integer, text) is 'args: rast, nband, uniontype - Returns the union of a set of raster tiles into a single raster composed of 1 or more bands.';

alter aggregate st_union(raster, integer, text) owner to postgres;

create aggregate st_union(raster, integer) (
    sfunc = _st_union_transfn,
    stype = internal,
    finalfunc = _st_union_finalfn,
    parallel = safe
    );

comment on aggregate st_union(raster, integer) is 'args: rast, nband - Returns the union of a set of raster tiles into a single raster composed of 1 or more bands.';

alter aggregate st_union(raster, integer) owner to postgres;

create aggregate st_union(raster) (
    sfunc = _st_union_transfn,
    stype = internal,
    finalfunc = _st_union_finalfn,
    parallel = safe
    );

comment on aggregate st_union(raster) is 'args: rast - Returns the union of a set of raster tiles into a single raster composed of 1 or more bands.';

alter aggregate st_union(raster) owner to postgres;

create aggregate st_union(raster, text) (
    sfunc = _st_union_transfn,
    stype = internal,
    finalfunc = _st_union_finalfn,
    parallel = safe
    );

comment on aggregate st_union(raster, text) is 'args: rast, uniontype - Returns the union of a set of raster tiles into a single raster composed of 1 or more bands.';

alter aggregate st_union(raster, text) owner to postgres;

create aggregate pg_catalog.array_agg(anyarray) (
    sfunc = array_agg_array_transfn,
    stype = ???,
finalfunc = array_agg_array_finalfn
);

comment on aggregate pg_catalog.array_agg(anyarray) is 'concatenate aggregate input into an array';

create aggregate pg_catalog.array_agg(anynonarray) (
    sfunc = array_agg_transfn,
    stype = ???,
finalfunc = array_agg_finalfn
);

comment on aggregate pg_catalog.array_agg(anynonarray) is 'concatenate aggregate input into an array';

create aggregate pg_catalog.avg(bigint) (
    sfunc = int8_avg_accum,
    stype = ???,
finalfunc = numeric_poly_avg,
combinefunc = int8_avg_combine,
serialfunc = int8_avg_serialize,
deserialfunc = int8_avg_deserialize,
msfunc = int8_avg_accum,
minvfunc = int8_avg_accum_inv,
mfinalfunc = numeric_poly_avg
);

comment on aggregate pg_catalog.avg(bigint) is 'the average (arithmetic mean) as numeric of all bigint values';

create aggregate pg_catalog.avg(double precision) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_avg,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.avg(double precision) is 'the average (arithmetic mean) as float8 of all float8 values';

create aggregate pg_catalog.avg(integer) (
    sfunc = int4_avg_accum,
    stype = ???,
finalfunc = int8_avg,
combinefunc = int4_avg_combine,
msfunc = int4_avg_accum,
minvfunc = int4_avg_accum_inv,
mfinalfunc = int8_avg
);

comment on aggregate pg_catalog.avg(integer) is 'the average (arithmetic mean) as numeric of all integer values';

create aggregate pg_catalog.avg(interval) (
    sfunc = interval_accum,
    stype = ???,
finalfunc = interval_avg,
combinefunc = interval_combine,
msfunc = interval_accum,
minvfunc = interval_accum_inv,
mfinalfunc = interval_avg
);

comment on aggregate pg_catalog.avg(interval) is 'the average (arithmetic mean) as interval of all interval values';

create aggregate pg_catalog.avg(numeric) (
    sfunc = numeric_avg_accum,
    stype = ???,
finalfunc = numeric_avg,
combinefunc = numeric_avg_combine,
serialfunc = numeric_avg_serialize,
deserialfunc = numeric_avg_deserialize,
msfunc = numeric_avg_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_avg
);

comment on aggregate pg_catalog.avg(numeric) is 'the average (arithmetic mean) as numeric of all numeric values';

create aggregate pg_catalog.avg(real) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_avg,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.avg(real) is 'the average (arithmetic mean) as float8 of all float4 values';

create aggregate pg_catalog.avg(smallint) (
    sfunc = int2_avg_accum,
    stype = ???,
finalfunc = int8_avg,
combinefunc = int4_avg_combine,
msfunc = int2_avg_accum,
minvfunc = int2_avg_accum_inv,
mfinalfunc = int8_avg
);

comment on aggregate pg_catalog.avg(smallint) is 'the average (arithmetic mean) as numeric of all smallint values';

create aggregate pg_catalog.bit_and(bigint) (
    sfunc = int8and,
    stype = ???,
combinefunc = int8and
);

comment on aggregate pg_catalog.bit_and(bigint) is 'bitwise-and bigint aggregate';

create aggregate pg_catalog.bit_and(bit) (
    sfunc = bitand,
    stype = ???,
combinefunc = bitand
);

comment on aggregate pg_catalog.bit_and(bit) is 'bitwise-and bit aggregate';

create aggregate pg_catalog.bit_and(integer) (
    sfunc = int4and,
    stype = ???,
combinefunc = int4and
);

comment on aggregate pg_catalog.bit_and(integer) is 'bitwise-and integer aggregate';

create aggregate pg_catalog.bit_and(smallint) (
    sfunc = int2and,
    stype = ???,
combinefunc = int2and
);

comment on aggregate pg_catalog.bit_and(smallint) is 'bitwise-and smallint aggregate';

create aggregate pg_catalog.bit_or(bigint) (
    sfunc = int8or,
    stype = ???,
combinefunc = int8or
);

comment on aggregate pg_catalog.bit_or(bigint) is 'bitwise-or bigint aggregate';

create aggregate pg_catalog.bit_or(bit) (
    sfunc = bitor,
    stype = ???,
combinefunc = bitor
);

comment on aggregate pg_catalog.bit_or(bit) is 'bitwise-or bit aggregate';

create aggregate pg_catalog.bit_or(integer) (
    sfunc = int4or,
    stype = ???,
combinefunc = int4or
);

comment on aggregate pg_catalog.bit_or(integer) is 'bitwise-or integer aggregate';

create aggregate pg_catalog.bit_or(smallint) (
    sfunc = int2or,
    stype = ???,
combinefunc = int2or
);

comment on aggregate pg_catalog.bit_or(smallint) is 'bitwise-or smallint aggregate';

create aggregate pg_catalog.corr(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_corr,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.corr(double precision, double precision) is 'correlation coefficient';

create aggregate pg_catalog.count("any") (
    sfunc = int8inc_any,
    stype = ???,
combinefunc = int8pl,
msfunc = int8inc_any,
minvfunc = int8dec_any
);

comment on aggregate pg_catalog.count("any") is 'number of input rows for which the input expression is not null';

create aggregate pg_catalog.count() (
    sfunc = int8inc,
    stype = ???,
combinefunc = int8pl,
msfunc = int8inc,
minvfunc = int8dec
);

comment on aggregate pg_catalog.count() is 'number of input rows';

create aggregate pg_catalog.covar_pop(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_covar_pop,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.covar_pop(double precision, double precision) is 'population covariance';

create aggregate pg_catalog.covar_samp(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_covar_samp,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.covar_samp(double precision, double precision) is 'sample covariance';

create aggregate pg_catalog.cume_dist("any") (
    sfunc = ordered_set_transition_multi,
    stype = ???,
finalfunc = cume_dist_final
);

comment on aggregate pg_catalog.cume_dist("any") is 'cumulative distribution of hypothetical row';

create aggregate pg_catalog.dense_rank("any") (
    sfunc = ordered_set_transition_multi,
    stype = ???,
finalfunc = dense_rank_final
);

comment on aggregate pg_catalog.dense_rank("any") is 'rank of hypothetical row without gaps';

create aggregate pg_catalog.json_agg(anyelement) (
    sfunc = json_agg_transfn,
    stype = ???,
finalfunc = json_agg_finalfn
);

comment on aggregate pg_catalog.json_agg(anyelement) is 'aggregate input into json';

create aggregate pg_catalog.json_object_agg("any", "any") (
    sfunc = json_object_agg_transfn,
    stype = ???,
finalfunc = json_object_agg_finalfn
);

comment on aggregate pg_catalog.json_object_agg("any", "any") is 'aggregate input into a json object';

create aggregate pg_catalog.jsonb_agg(anyelement) (
    sfunc = jsonb_agg_transfn,
    stype = ???,
finalfunc = jsonb_agg_finalfn
);

comment on aggregate pg_catalog.jsonb_agg(anyelement) is 'aggregate input into jsonb';

create aggregate pg_catalog.jsonb_object_agg("any", "any") (
    sfunc = jsonb_object_agg_transfn,
    stype = ???,
finalfunc = jsonb_object_agg_finalfn
);

comment on aggregate pg_catalog.jsonb_object_agg("any", "any") is 'aggregate inputs into jsonb object';

create aggregate pg_catalog.mode(anyelement) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = mode_final
);

comment on aggregate pg_catalog.mode(anyelement) is 'most common value';

create aggregate pg_catalog.percent_rank("any") (
    sfunc = ordered_set_transition_multi,
    stype = ???,
finalfunc = percent_rank_final
);

comment on aggregate pg_catalog.percent_rank("any") is 'fractional rank of hypothetical row';

create aggregate pg_catalog.percentile_cont(double precision, double precision) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_cont_float8_final
);

comment on aggregate pg_catalog.percentile_cont(double precision, double precision) is 'continuous distribution percentile';

create aggregate pg_catalog.percentile_cont(double precision, interval) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_cont_interval_final
);

comment on aggregate pg_catalog.percentile_cont(double precision, interval) is 'continuous distribution percentile';

create aggregate pg_catalog.percentile_cont(double precision [], double precision) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_cont_float8_multi_final
);

comment on aggregate pg_catalog.percentile_cont(double precision[], double precision) is 'multiple continuous percentiles';

create aggregate pg_catalog.percentile_cont(double precision [], interval) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_cont_interval_multi_final
);

comment on aggregate pg_catalog.percentile_cont(double precision[], interval) is 'multiple continuous percentiles';

create aggregate pg_catalog.percentile_disc(double precision, anyelement) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_disc_final
);

comment on aggregate pg_catalog.percentile_disc(double precision, anyelement) is 'discrete percentile';

create aggregate pg_catalog.percentile_disc(double precision [], anyelement) (
    sfunc = ordered_set_transition,
    stype = ???,
finalfunc = percentile_disc_multi_final
);

comment on aggregate pg_catalog.percentile_disc(double precision[], anyelement) is 'multiple discrete percentiles';

create aggregate pg_catalog.rank("any") (
    sfunc = ordered_set_transition_multi,
    stype = ???,
finalfunc = rank_final
);

comment on aggregate pg_catalog.rank("any") is 'rank of hypothetical row';

create aggregate pg_catalog.regr_avgx(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_avgx,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_avgx(double precision, double precision) is 'average of the independent variable (sum(X)/N)';

create aggregate pg_catalog.regr_avgy(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_avgy,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_avgy(double precision, double precision) is 'average of the dependent variable (sum(Y)/N)';

create aggregate pg_catalog.regr_count(double precision, double precision) (
    sfunc = int8inc_float8_float8,
    stype = ???,
combinefunc = int8pl
);

comment on aggregate pg_catalog.regr_count(double precision, double precision) is 'number of input rows in which both expressions are not null';

create aggregate pg_catalog.regr_intercept(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_intercept,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_intercept(double precision, double precision) is 'y-intercept of the least-squares-fit linear equation determined by the (X, Y) pairs';

create aggregate pg_catalog.regr_r2(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_r2,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_r2(double precision, double precision) is 'square of the correlation coefficient';

create aggregate pg_catalog.regr_slope(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_slope,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_slope(double precision, double precision) is 'slope of the least-squares-fit linear equation determined by the (X, Y) pairs';

create aggregate pg_catalog.regr_sxx(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_sxx,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_sxx(double precision, double precision) is 'sum of squares of the independent variable (sum(X^2) - sum(X)^2/N)';

create aggregate pg_catalog.regr_sxy(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_sxy,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_sxy(double precision, double precision) is 'sum of products of independent times dependent variable (sum(X*Y) - sum(X) * sum(Y)/N)';

create aggregate pg_catalog.regr_syy(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = ???,
finalfunc = float8_regr_syy,
combinefunc = float8_regr_combine
);

comment on aggregate pg_catalog.regr_syy(double precision, double precision) is 'sum of squares of the dependent variable (sum(Y^2) - sum(Y)^2/N)';

create aggregate pg_catalog.stddev(bigint) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_stddev_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev(bigint) is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev(double precision) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_stddev_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev(double precision) is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev(integer) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev(integer) is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev(numeric) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_stddev_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev(numeric) is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev(real) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_stddev_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev(real) is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev(smallint) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev(smallint) is 'historical alias for stddev_samp';

create aggregate pg_catalog.stddev_pop(bigint) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_stddev_pop,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(bigint) is 'population standard deviation of bigint input values';

create aggregate pg_catalog.stddev_pop(double precision) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_stddev_pop,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev_pop(double precision) is 'population standard deviation of float8 input values';

create aggregate pg_catalog.stddev_pop(integer) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_pop,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(integer) is 'population standard deviation of integer input values';

create aggregate pg_catalog.stddev_pop(numeric) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_stddev_pop,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(numeric) is 'population standard deviation of numeric input values';

create aggregate pg_catalog.stddev_pop(real) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_stddev_pop,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev_pop(real) is 'population standard deviation of float4 input values';

create aggregate pg_catalog.stddev_pop(smallint) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_pop,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_stddev_pop
);

comment on aggregate pg_catalog.stddev_pop(smallint) is 'population standard deviation of smallint input values';

create aggregate pg_catalog.stddev_samp(bigint) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_stddev_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(bigint) is 'sample standard deviation of bigint input values';

create aggregate pg_catalog.stddev_samp(double precision) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_stddev_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev_samp(double precision) is 'sample standard deviation of float8 input values';

create aggregate pg_catalog.stddev_samp(integer) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(integer) is 'sample standard deviation of integer input values';

create aggregate pg_catalog.stddev_samp(numeric) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_stddev_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(numeric) is 'sample standard deviation of numeric input values';

create aggregate pg_catalog.stddev_samp(real) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_stddev_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.stddev_samp(real) is 'sample standard deviation of float4 input values';

create aggregate pg_catalog.stddev_samp(smallint) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_stddev_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_stddev_samp
);

comment on aggregate pg_catalog.stddev_samp(smallint) is 'sample standard deviation of smallint input values';

create aggregate pg_catalog.string_agg(bytea, bytea) (
    sfunc = bytea_string_agg_transfn,
    stype = ???,
finalfunc = bytea_string_agg_finalfn
);

comment on aggregate pg_catalog.string_agg(bytea, bytea) is 'concatenate aggregate input into a bytea';

create aggregate pg_catalog.string_agg(text, text) (
    sfunc = string_agg_transfn,
    stype = ???,
finalfunc = string_agg_finalfn
);

comment on aggregate pg_catalog.string_agg(text, text) is 'concatenate aggregate input into a string';

create aggregate pg_catalog.sum(bigint) (
    sfunc = int8_avg_accum,
    stype = ???,
finalfunc = numeric_poly_sum,
combinefunc = int8_avg_combine,
serialfunc = int8_avg_serialize,
deserialfunc = int8_avg_deserialize,
msfunc = int8_avg_accum,
minvfunc = int8_avg_accum_inv,
mfinalfunc = numeric_poly_sum
);

comment on aggregate pg_catalog.sum(bigint) is 'sum as numeric across all bigint input values';

create aggregate pg_catalog.sum(double precision) (
    sfunc = float8pl,
    stype = ???,
combinefunc = float8pl
);

comment on aggregate pg_catalog.sum(double precision) is 'sum as float8 across all float8 input values';

create aggregate pg_catalog.sum(integer) (
    sfunc = int4_sum,
    stype = ???,
combinefunc = int8pl,
msfunc = int4_avg_accum,
minvfunc = int4_avg_accum_inv,
mfinalfunc = int2int4_sum
);

comment on aggregate pg_catalog.sum(integer) is 'sum as bigint across all integer input values';

create aggregate pg_catalog.sum(interval) (
    sfunc = interval_pl,
    stype = ???,
combinefunc = interval_pl,
msfunc = interval_pl,
minvfunc = interval_mi
);

comment on aggregate pg_catalog.sum(interval) is 'sum as interval across all interval input values';

create aggregate pg_catalog.sum(money) (
    sfunc = cash_pl,
    stype = ???,
combinefunc = cash_pl,
msfunc = cash_pl,
minvfunc = cash_mi
);

comment on aggregate pg_catalog.sum(money) is 'sum as money across all money input values';

create aggregate pg_catalog.sum(numeric) (
    sfunc = numeric_avg_accum,
    stype = ???,
finalfunc = numeric_sum,
combinefunc = numeric_avg_combine,
serialfunc = numeric_avg_serialize,
deserialfunc = numeric_avg_deserialize,
msfunc = numeric_avg_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_sum
);

comment on aggregate pg_catalog.sum(numeric) is 'sum as numeric across all numeric input values';

create aggregate pg_catalog.sum(real) (
    sfunc = float4pl,
    stype = ???,
combinefunc = float4pl
);

comment on aggregate pg_catalog.sum(real) is 'sum as float4 across all float4 input values';

create aggregate pg_catalog.sum(smallint) (
    sfunc = int2_sum,
    stype = ???,
combinefunc = int8pl,
msfunc = int2_avg_accum,
minvfunc = int2_avg_accum_inv,
mfinalfunc = int2int4_sum
);

comment on aggregate pg_catalog.sum(smallint) is 'sum as bigint across all smallint input values';

create aggregate pg_catalog.var_pop(bigint) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_var_pop,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_var_pop
);

comment on aggregate pg_catalog.var_pop(bigint) is 'population variance of bigint input values (square of the population standard deviation)';

create aggregate pg_catalog.var_pop(double precision) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_var_pop,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.var_pop(double precision) is 'population variance of float8 input values (square of the population standard deviation)';

create aggregate pg_catalog.var_pop(integer) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_var_pop,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_var_pop
);

comment on aggregate pg_catalog.var_pop(integer) is 'population variance of integer input values (square of the population standard deviation)';

create aggregate pg_catalog.var_pop(numeric) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_var_pop,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_var_pop
);

comment on aggregate pg_catalog.var_pop(numeric) is 'population variance of numeric input values (square of the population standard deviation)';

create aggregate pg_catalog.var_pop(real) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_var_pop,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.var_pop(real) is 'population variance of float4 input values (square of the population standard deviation)';

create aggregate pg_catalog.var_pop(smallint) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_var_pop,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_var_pop
);

comment on aggregate pg_catalog.var_pop(smallint) is 'population variance of smallint input values (square of the population standard deviation)';

create aggregate pg_catalog.var_samp(bigint) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_var_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_var_samp
);

comment on aggregate pg_catalog.var_samp(bigint) is 'sample variance of bigint input values (square of the sample standard deviation)';

create aggregate pg_catalog.var_samp(double precision) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_var_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.var_samp(double precision) is 'sample variance of float8 input values (square of the sample standard deviation)';

create aggregate pg_catalog.var_samp(integer) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_var_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_var_samp
);

comment on aggregate pg_catalog.var_samp(integer) is 'sample variance of integer input values (square of the sample standard deviation)';

create aggregate pg_catalog.var_samp(numeric) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_var_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_var_samp
);

comment on aggregate pg_catalog.var_samp(numeric) is 'sample variance of numeric input values (square of the sample standard deviation)';

create aggregate pg_catalog.var_samp(real) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_var_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.var_samp(real) is 'sample variance of float4 input values (square of the sample standard deviation)';

create aggregate pg_catalog.var_samp(smallint) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_var_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_var_samp
);

comment on aggregate pg_catalog.var_samp(smallint) is 'sample variance of smallint input values (square of the sample standard deviation)';

create aggregate pg_catalog.variance(bigint) (
    sfunc = int8_accum,
    stype = ???,
finalfunc = numeric_var_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = int8_accum,
minvfunc = int8_accum_inv,
mfinalfunc = numeric_var_samp
);

comment on aggregate pg_catalog.variance(bigint) is 'historical alias for var_samp';

create aggregate pg_catalog.variance(double precision) (
    sfunc = float8_accum,
    stype = ???,
finalfunc = float8_var_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.variance(double precision) is 'historical alias for var_samp';

create aggregate pg_catalog.variance(integer) (
    sfunc = int4_accum,
    stype = ???,
finalfunc = numeric_poly_var_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int4_accum,
minvfunc = int4_accum_inv,
mfinalfunc = numeric_poly_var_samp
);

comment on aggregate pg_catalog.variance(integer) is 'historical alias for var_samp';

create aggregate pg_catalog.variance(numeric) (
    sfunc = numeric_accum,
    stype = ???,
finalfunc = numeric_var_samp,
combinefunc = numeric_combine,
serialfunc = numeric_serialize,
deserialfunc = numeric_deserialize,
msfunc = numeric_accum,
minvfunc = numeric_accum_inv,
mfinalfunc = numeric_var_samp
);

comment on aggregate pg_catalog.variance(numeric) is 'historical alias for var_samp';

create aggregate pg_catalog.variance(real) (
    sfunc = float4_accum,
    stype = ???,
finalfunc = float8_var_samp,
combinefunc = float8_combine
);

comment on aggregate pg_catalog.variance(real) is 'historical alias for var_samp';

create aggregate pg_catalog.variance(smallint) (
    sfunc = int2_accum,
    stype = ???,
finalfunc = numeric_poly_var_samp,
combinefunc = numeric_poly_combine,
serialfunc = numeric_poly_serialize,
deserialfunc = numeric_poly_deserialize,
msfunc = int2_accum,
minvfunc = int2_accum_inv,
mfinalfunc = numeric_poly_var_samp
);

comment on aggregate pg_catalog.variance(smallint) is 'historical alias for var_samp';

create aggregate pg_catalog.xmlagg(xml) (
    sfunc = xmlconcat2,
    stype = ???
);

comment on aggregate pg_catalog.xmlagg(xml) is 'concatenate XML values';

create operator family btree_geometry_ops using btree;

alter operator family btree_geometry_ops using btree add
    operator 1 <(geometry, geometry),
    operator 2 <=(geometry, geometry),
    operator 3 =(geometry, geometry),
    operator 4 >=(geometry, geometry),
    operator 5 >(geometry, geometry),
    function 1(geometry, geometry) geometry_cmp(geom1 geometry, geom2 geometry),
    function 2(geometry, geometry) geometry_sortsupport(internal);

alter operator family btree_geometry_ops using btree owner to postgres;

create operator class btree_geometry_ops default for type geometry using btree as
    operator 1 <(geometry, geometry),
    operator 2 <=(geometry, geometry),
    operator 3 =(geometry, geometry),
    operator 4 >=(geometry, geometry),
    operator 5 >(geometry, geometry),
    function 1(geometry, geometry) geometry_cmp(geom1 geometry, geom2 geometry),
    function 2(geometry, geometry) geometry_sortsupport(internal);

alter operator class btree_geometry_ops using btree owner to postgres;

create operator family hash_geometry_ops using hash;

alter operator family hash_geometry_ops using hash add
    operator 1 =(geometry, geometry),
    function 1(geometry, geometry) geometry_hash(geometry);

alter operator family hash_geometry_ops using hash owner to postgres;

create operator class hash_geometry_ops default for type geometry using hash as
    operator 1 =(geometry, geometry),
    function 1(geometry, geometry) geometry_hash(geometry);

alter operator class hash_geometry_ops using hash owner to postgres;

create operator family gist_geometry_ops_2d using gist;

alter operator family gist_geometry_ops_2d using gist add
    operator 1 <<(geometry, geometry),
    operator 2 &<(geometry, geometry),
    operator 3 &&(geometry, geometry),
    operator 4 &>(geometry, geometry),
    operator 5 >>(geometry, geometry),
    operator 6 ~=(geometry, geometry),
    operator 7 ~(geometry, geometry),
    operator 8 @(geometry, geometry),
    operator 9 &<|(geometry, geometry),
    operator 10 <<|(geometry, geometry),
    operator 11 |>>(geometry, geometry),
    operator 12 |&>(geometry, geometry),
    operator 13 <->(geometry, geometry) for order by float_ops,
    operator 14 <#>(geometry, geometry) for order by float_ops,
    function 8(geometry, geometry) geometry_gist_distance_2d(internal, geometry, integer),
    function 1(geometry, geometry) geometry_gist_consistent_2d(internal, geometry, integer),
    function 2(geometry, geometry) geometry_gist_union_2d(bytea, internal),
    function 3(geometry, geometry) geometry_gist_compress_2d(internal),
    function 4(geometry, geometry) geometry_gist_decompress_2d(internal),
    function 5(geometry, geometry) geometry_gist_penalty_2d(internal, internal, internal),
    function 6(geometry, geometry) geometry_gist_picksplit_2d(internal, internal),
    function 7(geometry, geometry) geometry_gist_same_2d(geom1 geometry, geom2 geometry, internal);

alter operator family gist_geometry_ops_2d using gist owner to postgres;

create operator class gist_geometry_ops_2d default for type geometry using gist as storage box2df operator 1 <<(geometry, geometry),
	operator 2 &<(geometry, geometry),
	operator 3 &&(geometry, geometry),
	operator 4 &>(geometry, geometry),
	operator 5 >>(geometry, geometry),
	operator 6 ~=(geometry, geometry),
	operator 7 ~(geometry, geometry),
	operator 8 @(geometry, geometry),
	operator 9 &<|(geometry, geometry),
	operator 10 <<|(geometry, geometry),
	operator 11 |>>(geometry, geometry),
	operator 12 |&>(geometry, geometry),
	operator 13 <->(geometry, geometry) for order by float_ops,
	operator 14 <#>(geometry, geometry) for order by float_ops,
	function 8(geometry, geometry) geometry_gist_distance_2d(internal, geometry, integer),
	function 1(geometry, geometry) geometry_gist_consistent_2d(internal, geometry, integer),
	function 2(geometry, geometry) geometry_gist_union_2d(bytea, internal),
	function 3(geometry, geometry) geometry_gist_compress_2d(internal),
	function 4(geometry, geometry) geometry_gist_decompress_2d(internal),
	function 5(geometry, geometry) geometry_gist_penalty_2d(internal, internal, internal),
	function 6(geometry, geometry) geometry_gist_picksplit_2d(internal, internal),
	function 7(geometry, geometry) geometry_gist_same_2d(geom1 geometry, geom2 geometry, internal);

alter operator class gist_geometry_ops_2d using gist owner to postgres;

create operator family gist_geometry_ops_nd using gist;

alter operator family gist_geometry_ops_nd using gist add
    operator 3 &&&(geometry, geometry),
    operator 6 ~~=(geometry, geometry),
    operator 7 ~~(geometry, geometry),
    operator 8 @@(geometry, geometry),
    operator 13 <<->>(geometry, geometry) for order by float_ops,
    operator 20 |=|(geometry, geometry) for order by float_ops,
    function 8(geometry, geometry) geometry_gist_distance_nd(internal, geometry, integer),
    function 1(geometry, geometry) geometry_gist_consistent_nd(internal, geometry, integer),
    function 2(geometry, geometry) geometry_gist_union_nd(bytea, internal),
    function 3(geometry, geometry) geometry_gist_compress_nd(internal),
    function 4(geometry, geometry) geometry_gist_decompress_nd(internal),
    function 5(geometry, geometry) geometry_gist_penalty_nd(internal, internal, internal),
    function 6(geometry, geometry) geometry_gist_picksplit_nd(internal, internal),
    function 7(geometry, geometry) geometry_gist_same_nd(geometry, geometry, internal);

alter operator family gist_geometry_ops_nd using gist owner to postgres;

create operator class gist_geometry_ops_nd for type geometry using gist as storage gidx operator 3 &&&(geometry, geometry),
	operator 6 ~~=(geometry, geometry),
	operator 7 ~~(geometry, geometry),
	operator 8 @@(geometry, geometry),
	operator 13 <<->>(geometry, geometry) for order by float_ops,
	operator 20 |=|(geometry, geometry) for order by float_ops,
	function 8(geometry, geometry) geometry_gist_distance_nd(internal, geometry, integer),
	function 1(geometry, geometry) geometry_gist_consistent_nd(internal, geometry, integer),
	function 2(geometry, geometry) geometry_gist_union_nd(bytea, internal),
	function 3(geometry, geometry) geometry_gist_compress_nd(internal),
	function 4(geometry, geometry) geometry_gist_decompress_nd(internal),
	function 5(geometry, geometry) geometry_gist_penalty_nd(internal, internal, internal),
	function 6(geometry, geometry) geometry_gist_picksplit_nd(internal, internal),
	function 7(geometry, geometry) geometry_gist_same_nd(geometry, geometry, internal);

alter operator class gist_geometry_ops_nd using gist owner to postgres;

create operator family gist_geography_ops using gist;

alter operator family gist_geography_ops using gist add
    operator 3 &&(geography, geography),
    operator 13 <->(geography, geography) for order by float_ops,
    function 8(geography, geography) geography_gist_distance(internal, geography, integer),
    function 1(geography, geography) geography_gist_consistent(internal, geography, integer),
    function 2(geography, geography) geography_gist_union(bytea, internal),
    function 3(geography, geography) geography_gist_compress(internal),
    function 4(geography, geography) geography_gist_decompress(internal),
    function 5(geography, geography) geography_gist_penalty(internal, internal, internal),
    function 6(geography, geography) geography_gist_picksplit(internal, internal),
    function 7(geography, geography) geography_gist_same(box2d, box2d, internal);

alter operator family gist_geography_ops using gist owner to postgres;

create operator class gist_geography_ops default for type geography using gist as storage gidx operator 3 &&(geography, geography),
	operator 13 <->(geography, geography) for order by float_ops,
	function 8(geography, geography) geography_gist_distance(internal, geography, integer),
	function 1(geography, geography) geography_gist_consistent(internal, geography, integer),
	function 2(geography, geography) geography_gist_union(bytea, internal),
	function 3(geography, geography) geography_gist_compress(internal),
	function 4(geography, geography) geography_gist_decompress(internal),
	function 5(geography, geography) geography_gist_penalty(internal, internal, internal),
	function 6(geography, geography) geography_gist_picksplit(internal, internal),
	function 7(geography, geography) geography_gist_same(box2d, box2d, internal);

alter operator class gist_geography_ops using gist owner to postgres;

create operator family brin_geography_inclusion_ops using brin;

alter operator family brin_geography_inclusion_ops using brin add
    operator 3 &&(geography, geography),
    operator 3 &&(geography, gidx),
    operator 3 &&(gidx, geography),
    operator 3 &&(gidx, gidx),
    function 2(geography, geography) geog_brin_inclusion_add_value(internal, internal, internal, internal);

alter operator family brin_geography_inclusion_ops using brin owner to postgres;

create operator class brin_geography_inclusion_ops default for type geography using brin as storage gidx operator 3 &&(geography, geography),
	operator 3 &&(geography, gidx),
	operator 3 &&(gidx, geography),
	operator 3 &&(gidx, gidx),
	function 1(geography, geography) brin_inclusion_opcinfo(internal),
	function 2(geography, geography) geog_brin_inclusion_add_value(internal, internal, internal, internal),
	function 3(geography, geography) brin_inclusion_consistent(internal,internal,internal),
	function 4(geography, geography) brin_inclusion_union(internal,internal,internal);

alter operator class brin_geography_inclusion_ops using brin owner to postgres;

create operator family btree_geography_ops using btree;

alter operator family btree_geography_ops using btree add
    operator 1 <(geography, geography),
    operator 2 <=(geography, geography),
    operator 3 =(geography, geography),
    operator 4 >=(geography, geography),
    operator 5 >(geography, geography),
    function 1(geography, geography) geography_cmp(geography, geography);

alter operator family btree_geography_ops using btree owner to postgres;

create operator class btree_geography_ops default for type geography using btree as
    operator 1 <(geography, geography),
    operator 2 <=(geography, geography),
    operator 3 =(geography, geography),
    operator 4 >=(geography, geography),
    operator 5 >(geography, geography),
    function 1(geography, geography) geography_cmp(geography, geography);

alter operator class btree_geography_ops using btree owner to postgres;

create operator family brin_geometry_inclusion_ops_2d using brin;

alter operator family brin_geometry_inclusion_ops_2d using brin add
    operator 3 &&(box2df, box2df),
    operator 3 &&(box2df, geometry),
    operator 3 &&(geometry, box2df),
    operator 3 &&(geometry, geometry),
    operator 7 ~(box2df, box2df),
    operator 7 ~(box2df, geometry),
    operator 7 ~(geometry, box2df),
    operator 7 ~(geometry, geometry),
    operator 8 @(box2df, box2df),
    operator 8 @(box2df, geometry),
    operator 8 @(geometry, box2df),
    operator 8 @(geometry, geometry),
    function 2(geometry, geometry) geom2d_brin_inclusion_add_value(internal, internal, internal, internal);

alter operator family brin_geometry_inclusion_ops_2d using brin owner to postgres;

create operator class brin_geometry_inclusion_ops_2d default for type geometry using brin as storage box2df operator 3 &&(box2df, box2df),
	operator 3 &&(box2df, geometry),
	operator 3 &&(geometry, box2df),
	operator 3 &&(geometry, geometry),
	operator 7 ~(box2df, box2df),
	operator 7 ~(box2df, geometry),
	operator 7 ~(geometry, box2df),
	operator 7 ~(geometry, geometry),
	operator 8 @(box2df, box2df),
	operator 8 @(box2df, geometry),
	operator 8 @(geometry, box2df),
	operator 8 @(geometry, geometry),
	function 1(geometry, geometry) brin_inclusion_opcinfo(internal),
	function 2(geometry, geometry) geom2d_brin_inclusion_add_value(internal, internal, internal, internal),
	function 3(geometry, geometry) brin_inclusion_consistent(internal,internal,internal),
	function 4(geometry, geometry) brin_inclusion_union(internal,internal,internal);

alter operator class brin_geometry_inclusion_ops_2d using brin owner to postgres;

create operator family brin_geometry_inclusion_ops_3d using brin;

alter operator family brin_geometry_inclusion_ops_3d using brin add
    operator 3 &&&(geometry, geometry),
    operator 3 &&&(geometry, gidx),
    operator 3 &&&(gidx, geometry),
    operator 3 &&&(gidx, gidx),
    function 2(geometry, geometry) geom3d_brin_inclusion_add_value(internal, internal, internal, internal);

alter operator family brin_geometry_inclusion_ops_3d using brin owner to postgres;

create operator class brin_geometry_inclusion_ops_3d for type geometry using brin as storage gidx operator 3 &&&(geometry, geometry),
	operator 3 &&&(geometry, gidx),
	operator 3 &&&(gidx, geometry),
	operator 3 &&&(gidx, gidx),
	function 1(geometry, geometry) brin_inclusion_opcinfo(internal),
	function 2(geometry, geometry) geom3d_brin_inclusion_add_value(internal, internal, internal, internal),
	function 3(geometry, geometry) brin_inclusion_consistent(internal,internal,internal),
	function 4(geometry, geometry) brin_inclusion_union(internal,internal,internal);

alter operator class brin_geometry_inclusion_ops_3d using brin owner to postgres;

create operator family brin_geometry_inclusion_ops_4d using brin;

alter operator family brin_geometry_inclusion_ops_4d using brin add
    operator 3 &&&(geometry, geometry),
    operator 3 &&&(geometry, gidx),
    operator 3 &&&(gidx, geometry),
    operator 3 &&&(gidx, gidx),
    function 2(geometry, geometry) geom4d_brin_inclusion_add_value(internal, internal, internal, internal);

alter operator family brin_geometry_inclusion_ops_4d using brin owner to postgres;

create operator class brin_geometry_inclusion_ops_4d for type geometry using brin as storage gidx operator 3 &&&(geometry, geometry),
	operator 3 &&&(geometry, gidx),
	operator 3 &&&(gidx, geometry),
	operator 3 &&&(gidx, gidx),
	function 1(geometry, geometry) brin_inclusion_opcinfo(internal),
	function 2(geometry, geometry) geom4d_brin_inclusion_add_value(internal, internal, internal, internal),
	function 3(geometry, geometry) brin_inclusion_consistent(internal,internal,internal),
	function 4(geometry, geometry) brin_inclusion_union(internal,internal,internal);

alter operator class brin_geometry_inclusion_ops_4d using brin owner to postgres;

create operator family spgist_geometry_ops_2d using spgist;

alter operator family spgist_geometry_ops_2d using spgist add
    operator 1 <<(geometry, geometry),
    operator 2 &<(geometry, geometry),
    operator 3 &&(geometry, geometry),
    operator 4 &>(geometry, geometry),
    operator 5 >>(geometry, geometry),
    operator 6 ~=(geometry, geometry),
    operator 7 ~(geometry, geometry),
    operator 8 @(geometry, geometry),
    operator 9 &<|(geometry, geometry),
    operator 10 <<|(geometry, geometry),
    operator 11 |>>(geometry, geometry),
    operator 12 |&>(geometry, geometry),
    function 1(geometry, geometry) geometry_spgist_config_2d(internal, internal),
    function 2(geometry, geometry) geometry_spgist_choose_2d(internal, internal),
    function 3(geometry, geometry) geometry_spgist_picksplit_2d(internal, internal),
    function 4(geometry, geometry) geometry_spgist_inner_consistent_2d(internal, internal),
    function 5(geometry, geometry) geometry_spgist_leaf_consistent_2d(internal, internal),
    function 6(geometry, geometry) geometry_spgist_compress_2d(internal);

alter operator family spgist_geometry_ops_2d using spgist owner to postgres;

create operator class spgist_geometry_ops_2d default for type geometry using spgist as
    operator 1 <<(geometry, geometry),
    operator 2 &<(geometry, geometry),
    operator 3 &&(geometry, geometry),
    operator 4 &>(geometry, geometry),
    operator 5 >>(geometry, geometry),
    operator 6 ~=(geometry, geometry),
    operator 7 ~(geometry, geometry),
    operator 8 @(geometry, geometry),
    operator 9 &<|(geometry, geometry),
    operator 10 <<|(geometry, geometry),
    operator 11 |>>(geometry, geometry),
    operator 12 |&>(geometry, geometry),
    function 1(geometry, geometry) geometry_spgist_config_2d(internal, internal),
    function 2(geometry, geometry) geometry_spgist_choose_2d(internal, internal),
    function 3(geometry, geometry) geometry_spgist_picksplit_2d(internal, internal),
    function 4(geometry, geometry) geometry_spgist_inner_consistent_2d(internal, internal),
    function 5(geometry, geometry) geometry_spgist_leaf_consistent_2d(internal, internal),
    function 6(geometry, geometry) geometry_spgist_compress_2d(internal);

alter operator class spgist_geometry_ops_2d using spgist owner to postgres;

create operator family spgist_geometry_ops_3d using spgist;

alter operator family spgist_geometry_ops_3d using spgist add
    operator 3 &/&(geometry, geometry),
    operator 6 ~==(geometry, geometry),
    operator 7 @>>(geometry, geometry),
    operator 8 <<@(geometry, geometry),
    function 1(geometry, geometry) geometry_spgist_config_3d(internal, internal),
    function 2(geometry, geometry) geometry_spgist_choose_3d(internal, internal),
    function 3(geometry, geometry) geometry_spgist_picksplit_3d(internal, internal),
    function 4(geometry, geometry) geometry_spgist_inner_consistent_3d(internal, internal),
    function 5(geometry, geometry) geometry_spgist_leaf_consistent_3d(internal, internal),
    function 6(geometry, geometry) geometry_spgist_compress_3d(internal);

alter operator family spgist_geometry_ops_3d using spgist owner to postgres;

create operator class spgist_geometry_ops_3d for type geometry using spgist as
    operator 3 &/&(geometry, geometry),
    operator 6 ~==(geometry, geometry),
    operator 7 @>>(geometry, geometry),
    operator 8 <<@(geometry, geometry),
    function 1(geometry, geometry) geometry_spgist_config_3d(internal, internal),
    function 2(geometry, geometry) geometry_spgist_choose_3d(internal, internal),
    function 3(geometry, geometry) geometry_spgist_picksplit_3d(internal, internal),
    function 4(geometry, geometry) geometry_spgist_inner_consistent_3d(internal, internal),
    function 5(geometry, geometry) geometry_spgist_leaf_consistent_3d(internal, internal),
    function 6(geometry, geometry) geometry_spgist_compress_3d(internal);

alter operator class spgist_geometry_ops_3d using spgist owner to postgres;

create operator family spgist_geometry_ops_nd using spgist;

alter operator family spgist_geometry_ops_nd using spgist add
    operator 3 &&&(geometry, geometry),
    operator 6 ~~=(geometry, geometry),
    operator 7 ~~(geometry, geometry),
    operator 8 @@(geometry, geometry),
    function 1(geometry, geometry) geometry_spgist_config_nd(internal, internal),
    function 2(geometry, geometry) geometry_spgist_choose_nd(internal, internal),
    function 3(geometry, geometry) geometry_spgist_picksplit_nd(internal, internal),
    function 4(geometry, geometry) geometry_spgist_inner_consistent_nd(internal, internal),
    function 5(geometry, geometry) geometry_spgist_leaf_consistent_nd(internal, internal),
    function 6(geometry, geometry) geometry_spgist_compress_nd(internal);

alter operator family spgist_geometry_ops_nd using spgist owner to postgres;

create operator class spgist_geometry_ops_nd for type geometry using spgist as
    operator 3 &&&(geometry, geometry),
    operator 6 ~~=(geometry, geometry),
    operator 7 ~~(geometry, geometry),
    operator 8 @@(geometry, geometry),
    function 1(geometry, geometry) geometry_spgist_config_nd(internal, internal),
    function 2(geometry, geometry) geometry_spgist_choose_nd(internal, internal),
    function 3(geometry, geometry) geometry_spgist_picksplit_nd(internal, internal),
    function 4(geometry, geometry) geometry_spgist_inner_consistent_nd(internal, internal),
    function 5(geometry, geometry) geometry_spgist_leaf_consistent_nd(internal, internal),
    function 6(geometry, geometry) geometry_spgist_compress_nd(internal);

alter operator class spgist_geometry_ops_nd using spgist owner to postgres;

create operator family spgist_geography_ops_nd using spgist;

alter operator family spgist_geography_ops_nd using spgist add
    operator 3 &&(geography, geography),
    function 1(geography, geography) geography_spgist_config_nd(internal, internal),
    function 2(geography, geography) geography_spgist_choose_nd(internal, internal),
    function 3(geography, geography) geography_spgist_picksplit_nd(internal, internal),
    function 4(geography, geography) geography_spgist_inner_consistent_nd(internal, internal),
    function 5(geography, geography) geography_spgist_leaf_consistent_nd(internal, internal),
    function 6(geography, geography) geography_spgist_compress_nd(internal);

alter operator family spgist_geography_ops_nd using spgist owner to postgres;

create operator class spgist_geography_ops_nd default for type geography using spgist as
    operator 3 &&(geography, geography),
    function 1(geography, geography) geography_spgist_config_nd(internal, internal),
    function 2(geography, geography) geography_spgist_choose_nd(internal, internal),
    function 3(geography, geography) geography_spgist_picksplit_nd(internal, internal),
    function 4(geography, geography) geography_spgist_inner_consistent_nd(internal, internal),
    function 5(geography, geography) geography_spgist_leaf_consistent_nd(internal, internal),
    function 6(geography, geography) geography_spgist_compress_nd(internal);

alter operator class spgist_geography_ops_nd using spgist owner to postgres;

create operator family hash_raster_ops using hash;

alter operator family hash_raster_ops using hash add
    operator 1 =(raster, raster),
    function 1(raster, raster) raster_hash(raster);

alter operator family hash_raster_ops using hash owner to postgres;

create operator class hash_raster_ops default for type raster using hash as
    operator 1 =(raster, raster),
    function 1(raster, raster) raster_hash(raster);

alter operator class hash_raster_ops using hash owner to postgres;

create operator family pg_catalog.aclitem_ops using hash;

alter operator family pg_catalog.aclitem_ops using hash add
    function 1(aclitem, aclitem) hash_aclitem(aclitem),
    function 2(aclitem, aclitem) hash_aclitem_extended(aclitem,bigint);

create operator class pg_catalog.aclitem_ops default for type aclitem using hash as
    operator 1 =(aclitem,aclitem);

create operator family pg_catalog.array_ops using btree;

alter operator family pg_catalog.array_ops using btree add
    function 1(anyarray, anyarray) btarraycmp(anyarray,anyarray);

create operator class pg_catalog.array_ops default for type anyarray using btree as
    operator 1 <(anyarray,anyarray),
    operator 2 <=(anyarray,anyarray),
    operator 3 =(anyarray,anyarray),
    operator 4 >=(anyarray,anyarray),
    operator 5 >(anyarray,anyarray);

create operator class pg_catalog.array_ops default for type anyarray using gin as storage anyelement operator 1 <(anyarray,anyarray),
	operator 2 <=(anyarray,anyarray),
	operator 3 =(anyarray,anyarray),
	operator 4 >=(anyarray,anyarray),
	operator 5 >(anyarray,anyarray);

create operator class pg_catalog.array_ops default for type anyarray using hash as
    operator 1 <(anyarray,anyarray),
    operator 2 <=(anyarray,anyarray),
    operator 3 =(anyarray,anyarray),
    operator 4 >=(anyarray,anyarray),
    operator 5 >(anyarray,anyarray);

create operator family pg_catalog.array_ops using gin;

alter operator family pg_catalog.array_ops using gin add
    operator 1 &&(anyarray,anyarray),
    operator 2 @>(anyarray,anyarray),
    operator 3 <@(anyarray,anyarray),
    operator 4 =(anyarray,anyarray),
    function 2(anyarray, anyarray) ginarrayextract(anyarray,internal,internal),
    function 3(anyarray, anyarray) ginqueryarrayextract(anyarray,internal,smallint,internal,internal,internal,internal),
    function 4(anyarray, anyarray) ginarrayconsistent(internal,smallint,anyarray,integer,internal,internal,internal,internal),
    function 6(anyarray, anyarray) ginarraytriconsistent(internal,smallint,anyarray,integer,internal,internal,internal);

create operator family pg_catalog.array_ops using hash;

alter operator family pg_catalog.array_ops using hash add
    operator 1 =(anyarray,anyarray),
    function 1(anyarray, anyarray) hash_array(anyarray),
    function 2(anyarray, anyarray) hash_array_extended(anyarray,bigint);

create operator family pg_catalog.bit_minmax_ops using brin;

alter operator family pg_catalog.bit_minmax_ops using brin add
    function 1(bit, bit) brin_minmax_opcinfo(internal),
    function 2(bit, bit) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(bit, bit) brin_minmax_consistent(internal,internal,internal),
    function 4(bit, bit) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.bit_minmax_ops default for type bit using brin as storage bit operator 1 <(bit,bit),
	operator 2 <=(bit,bit),
	operator 3 =(bit,bit),
	operator 4 >=(bit,bit),
	operator 5 >(bit,bit);

create operator family pg_catalog.bit_ops using btree;

alter operator family pg_catalog.bit_ops using btree add
    function 1(bit, bit) bitcmp(bit,bit),
    function 4(bit, bit) btequalimage(oid);

create operator class pg_catalog.bit_ops default for type bit using btree as
    operator 1 <(bit,bit),
    operator 2 <=(bit,bit),
    operator 3 =(bit,bit),
    operator 4 >=(bit,bit),
    operator 5 >(bit,bit);

create operator family pg_catalog.bool_ops using btree;

alter operator family pg_catalog.bool_ops using btree add
    function 1(boolean, boolean) btboolcmp(boolean,boolean),
    function 4(boolean, boolean) btequalimage(oid);

create operator class pg_catalog.bool_ops default for type boolean using btree as
    operator 1 <(boolean,boolean),
    operator 2 <=(boolean,boolean),
    operator 3 =(boolean,boolean),
    operator 4 >=(boolean,boolean),
    operator 5 >(boolean,boolean);

create operator class pg_catalog.bool_ops default for type boolean using hash as
    operator 1 <(boolean,boolean),
    operator 2 <=(boolean,boolean),
    operator 3 =(boolean,boolean),
    operator 4 >=(boolean,boolean),
    operator 5 >(boolean,boolean);

create operator family pg_catalog.bool_ops using hash;

alter operator family pg_catalog.bool_ops using hash add
    operator 1 =(boolean,boolean),
    function 1(boolean, boolean) hashchar("char"),
    function 2(boolean, boolean) hashcharextended("char",bigint);

create operator family pg_catalog.box_inclusion_ops using brin;

alter operator family pg_catalog.box_inclusion_ops using brin add
    function 11(box, box) bound_box(box,box),
    function 13(box, box) box_contain(box,box),
    function 1(box, box) brin_inclusion_opcinfo(internal),
    function 2(box, box) brin_inclusion_add_value(internal,internal,internal,internal),
    function 3(box, box) brin_inclusion_consistent(internal,internal,internal),
    function 4(box, box) brin_inclusion_union(internal,internal,internal);

create operator class pg_catalog.box_inclusion_ops default for type box using brin as storage box operator 10 <<|(box,box),
	operator 11 |>>(box,box),
	operator 12 |&>(box,box),
	operator 1 <<(box,box),
	operator 2 &<(box,box),
	operator 3 &&(box,box),
	operator 4 &>(box,box),
	operator 5 >>(box,box),
	operator 6 ~=(box,box),
	operator 7 @>(box,box),
	operator 7 @>(box,point),
	operator 8 <@(box,box),
	operator 9 &<|(box,box);

create operator family pg_catalog.box_ops using gist;

alter operator family pg_catalog.box_ops using gist add
    function 1(box, box) gist_box_consistent(internal,box,smallint,oid,internal),
    function 2(box, box) gist_box_union(internal,internal),
    function 5(box, box) gist_box_penalty(internal,internal,internal),
    function 6(box, box) gist_box_picksplit(internal,internal),
    function 7(box, box) gist_box_same(box,box,internal),
    function 8(box, box) gist_box_distance(internal,box,smallint,oid,internal);

create operator class pg_catalog.box_ops default for type box using gist as
    operator 10 <<|(box,box),
    operator 11 |>>(box,box),
    operator 12 |&>(box,box),
    operator 13 ~(box,box),
    operator 14 @(box,box),
    operator 15 <->(box,point),
    operator 1 <<(box,box),
    operator 2 &<(box,box),
    operator 3 &&(box,box),
    operator 4 &>(box,box),
    operator 5 >>(box,box),
    operator 6 ~=(box,box),
    operator 7 @>(box,box),
    operator 8 <@(box,box),
    operator 9 &<|(box,box);

create operator class pg_catalog.box_ops default for type box using spgist as
    operator 10 <<|(box,box),
    operator 11 |>>(box,box),
    operator 12 |&>(box,box),
    operator 13 ~(box,box),
    operator 14 @(box,box),
    operator 15 <->(box,point),
    operator 1 <<(box,box),
    operator 2 &<(box,box),
    operator 3 &&(box,box),
    operator 4 &>(box,box),
    operator 5 >>(box,box),
    operator 6 ~=(box,box),
    operator 7 @>(box,box),
    operator 8 <@(box,box),
    operator 9 &<|(box,box);

create operator family pg_catalog.box_ops using spgist;

alter operator family pg_catalog.box_ops using spgist add
    operator 10 <<|(box,box),
    operator 11 |>>(box,box),
    operator 12 |&>(box,box),
    operator 15 <->(box,point),
    operator 1 <<(box,box),
    operator 2 &<(box,box),
    operator 3 &&(box,box),
    operator 4 &>(box,box),
    operator 5 >>(box,box),
    operator 6 ~=(box,box),
    operator 7 @>(box,box),
    operator 8 <@(box,box),
    operator 9 &<|(box,box),
    function 1(box, box) spg_box_quad_config(internal,internal),
    function 2(box, box) spg_box_quad_choose(internal,internal),
    function 3(box, box) spg_box_quad_picksplit(internal,internal),
    function 4(box, box) spg_box_quad_inner_consistent(internal,internal),
    function 5(box, box) spg_box_quad_leaf_consistent(internal,internal);

create operator family pg_catalog.bpchar_minmax_ops using brin;

alter operator family pg_catalog.bpchar_minmax_ops using brin add
    function 1(character, character) brin_minmax_opcinfo(internal),
    function 2(character, character) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(character, character) brin_minmax_consistent(internal,internal,internal),
    function 4(character, character) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.bpchar_minmax_ops default for type character using brin as storage character operator 1 <(character,character),
	operator 2 <=(character,character),
	operator 3 =(character,character),
	operator 4 >=(character,character),
	operator 5 >(character,character);

create operator family pg_catalog.bpchar_ops using btree;

alter operator family pg_catalog.bpchar_ops using btree add
    function 1(character, character) bpcharcmp(character,character),
    function 2(character, character) bpchar_sortsupport(internal),
    function 4(character, character) btvarstrequalimage(oid);

create operator class pg_catalog.bpchar_ops default for type character using btree as
    operator 1 <(character,character),
    operator 2 <=(character,character),
    operator 3 =(character,character),
    operator 4 >=(character,character),
    operator 5 >(character,character);

create operator class pg_catalog.bpchar_ops default for type character using hash as
    operator 1 <(character,character),
    operator 2 <=(character,character),
    operator 3 =(character,character),
    operator 4 >=(character,character),
    operator 5 >(character,character);

create operator family pg_catalog.bpchar_ops using hash;

alter operator family pg_catalog.bpchar_ops using hash add
    operator 1 =(character,character),
    function 1(character, character) hashbpchar(character),
    function 2(character, character) hashbpcharextended(character,bigint);

create operator family pg_catalog.bpchar_pattern_ops using btree;

alter operator family pg_catalog.bpchar_pattern_ops using btree add
    function 1(character, character) btbpchar_pattern_cmp(character,character),
    function 2(character, character) btbpchar_pattern_sortsupport(internal),
    function 4(character, character) btequalimage(oid);

create operator class pg_catalog.bpchar_pattern_ops for type character using btree as
    operator 1 ~<~(character,character),
    operator 2 ~<=~(character,character),
    operator 3 =(character,character),
    operator 4 ~>=~(character,character),
    operator 5 ~>~(character,character);

create operator class pg_catalog.bpchar_pattern_ops for type character using hash as
    operator 1 ~<~(character,character),
    operator 2 ~<=~(character,character),
    operator 3 =(character,character),
    operator 4 ~>=~(character,character),
    operator 5 ~>~(character,character);

create operator family pg_catalog.bpchar_pattern_ops using hash;

alter operator family pg_catalog.bpchar_pattern_ops using hash add
    operator 1 =(character,character),
    function 1(character, character) hashbpchar(character),
    function 2(character, character) hashbpcharextended(character,bigint);

create operator family pg_catalog.bytea_minmax_ops using brin;

alter operator family pg_catalog.bytea_minmax_ops using brin add
    function 1(bytea, bytea) brin_minmax_opcinfo(internal),
    function 2(bytea, bytea) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(bytea, bytea) brin_minmax_consistent(internal,internal,internal),
    function 4(bytea, bytea) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.bytea_minmax_ops default for type bytea using brin as storage bytea operator 1 <(bytea,bytea),
	operator 2 <=(bytea,bytea),
	operator 3 =(bytea,bytea),
	operator 4 >=(bytea,bytea),
	operator 5 >(bytea,bytea);

create operator family pg_catalog.bytea_ops using btree;

alter operator family pg_catalog.bytea_ops using btree add
    function 1(bytea, bytea) byteacmp(bytea,bytea),
    function 2(bytea, bytea) bytea_sortsupport(internal),
    function 4(bytea, bytea) btequalimage(oid);

create operator class pg_catalog.bytea_ops default for type bytea using btree as
    operator 1 <(bytea,bytea),
    operator 2 <=(bytea,bytea),
    operator 3 =(bytea,bytea),
    operator 4 >=(bytea,bytea),
    operator 5 >(bytea,bytea);

create operator class pg_catalog.bytea_ops default for type bytea using hash as
    operator 1 <(bytea,bytea),
    operator 2 <=(bytea,bytea),
    operator 3 =(bytea,bytea),
    operator 4 >=(bytea,bytea),
    operator 5 >(bytea,bytea);

create operator family pg_catalog.bytea_ops using hash;

alter operator family pg_catalog.bytea_ops using hash add
    operator 1 =(bytea,bytea),
    function 1(bytea, bytea) hashvarlena(internal),
    function 2(bytea, bytea) hashvarlenaextended(internal,bigint);

create operator family pg_catalog.char_minmax_ops using brin;

alter operator family pg_catalog.char_minmax_ops using brin add
    function 1("char", "char") brin_minmax_opcinfo(internal),
    function 2("char", "char") brin_minmax_add_value(internal,internal,internal,internal),
    function 3("char", "char") brin_minmax_consistent(internal,internal,internal),
    function 4("char", "char") brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.char_minmax_ops default for type "char" using brin as storage "char" operator 1 <("char","char"),
	operator 2 <=("char","char"),
	operator 3 =("char","char"),
	operator 4 >=("char","char"),
	operator 5 >("char","char");

create operator family pg_catalog.char_ops using btree;

alter operator family pg_catalog.char_ops using btree add
    function 1("char", "char") btcharcmp("char","char"),
    function 4("char", "char") btequalimage(oid);

create operator class pg_catalog.char_ops default for type "char" using btree as
    operator 1 <("char","char"),
    operator 2 <=("char","char"),
    operator 3 =("char","char"),
    operator 4 >=("char","char"),
    operator 5 >("char","char");

create operator class pg_catalog.char_ops default for type "char" using hash as
    operator 1 <("char","char"),
    operator 2 <=("char","char"),
    operator 3 =("char","char"),
    operator 4 >=("char","char"),
    operator 5 >("char","char");

create operator family pg_catalog.char_ops using hash;

alter operator family pg_catalog.char_ops using hash add
    operator 1 =("char","char"),
    function 1("char", "char") hashchar("char"),
    function 2("char", "char") hashcharextended("char",bigint);

create operator family pg_catalog.cid_ops using hash;

alter operator family pg_catalog.cid_ops using hash add
    function 1(cid, cid) hashint4(integer),
    function 2(cid, cid) hashint4extended(integer,bigint);

create operator class pg_catalog.cid_ops default for type cid using hash as
    operator 1 =(cid,cid);

create operator family pg_catalog.circle_ops using gist;

alter operator family pg_catalog.circle_ops using gist add
    function 1(circle, circle) gist_circle_consistent(internal,circle,smallint,oid,internal),
    function 2(circle, circle) gist_box_union(internal,internal),
    function 3(circle, circle) gist_circle_compress(internal),
    function 5(circle, circle) gist_box_penalty(internal,internal,internal),
    function 6(circle, circle) gist_box_picksplit(internal,internal),
    function 7(circle, circle) gist_box_same(box,box,internal),
    function 8(circle, circle) gist_circle_distance(internal,circle,smallint,oid,internal);

create operator class pg_catalog.circle_ops default for type circle using gist as storage box operator 10 <<|(circle,circle),
	operator 11 |>>(circle,circle),
	operator 12 |&>(circle,circle),
	operator 13 ~(circle,circle),
	operator 14 @(circle,circle),
	operator 15 <->(circle,point),
	operator 1 <<(circle,circle),
	operator 2 &<(circle,circle),
	operator 3 &&(circle,circle),
	operator 4 &>(circle,circle),
	operator 5 >>(circle,circle),
	operator 6 ~=(circle,circle),
	operator 7 @>(circle,circle),
	operator 8 <@(circle,circle),
	operator 9 &<|(circle,circle);

create operator family pg_catalog.date_ops using hash;

alter operator family pg_catalog.date_ops using hash add
    function 1(date, date) hashint4(integer),
    function 2(date, date) hashint4extended(integer,bigint);

create operator class pg_catalog.date_ops default for type date using hash as
    operator 1 =(date,date);

create operator family pg_catalog.datetime_minmax_ops using brin;

alter operator family pg_catalog.datetime_minmax_ops using brin add
    function 1(date, date) brin_minmax_opcinfo(internal),
    function 1(date, timestamp with time zone) brin_minmax_opcinfo(internal),
    function 1(date, timestamp without time zone) brin_minmax_opcinfo(internal),
    function 1(timestamp with time zone, date) brin_minmax_opcinfo(internal),
    function 1(timestamp with time zone, timestamp with time zone) brin_minmax_opcinfo(internal),
    function 1(timestamp with time zone, timestamp without time zone) brin_minmax_opcinfo(internal),
    function 1(timestamp without time zone, date) brin_minmax_opcinfo(internal),
    function 1(timestamp without time zone, timestamp with time zone) brin_minmax_opcinfo(internal),
    function 1(timestamp without time zone, timestamp without time zone) brin_minmax_opcinfo(internal),
    function 2(date, date) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(date, timestamp with time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(date, timestamp without time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(timestamp with time zone, date) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(timestamp with time zone, timestamp with time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(timestamp with time zone, timestamp without time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(timestamp without time zone, date) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(timestamp without time zone, timestamp with time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(timestamp without time zone, timestamp without time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(date, date) brin_minmax_consistent(internal,internal,internal),
    function 3(date, timestamp with time zone) brin_minmax_consistent(internal,internal,internal),
    function 3(date, timestamp without time zone) brin_minmax_consistent(internal,internal,internal),
    function 3(timestamp with time zone, date) brin_minmax_consistent(internal,internal,internal),
    function 3(timestamp with time zone, timestamp with time zone) brin_minmax_consistent(internal,internal,internal),
    function 3(timestamp with time zone, timestamp without time zone) brin_minmax_consistent(internal,internal,internal),
    function 3(timestamp without time zone, date) brin_minmax_consistent(internal,internal,internal),
    function 3(timestamp without time zone, timestamp with time zone) brin_minmax_consistent(internal,internal,internal),
    function 3(timestamp without time zone, timestamp without time zone) brin_minmax_consistent(internal,internal,internal),
    function 4(date, date) brin_minmax_union(internal,internal,internal),
    function 4(date, timestamp with time zone) brin_minmax_union(internal,internal,internal),
    function 4(date, timestamp without time zone) brin_minmax_union(internal,internal,internal),
    function 4(timestamp with time zone, date) brin_minmax_union(internal,internal,internal),
    function 4(timestamp with time zone, timestamp with time zone) brin_minmax_union(internal,internal,internal),
    function 4(timestamp with time zone, timestamp without time zone) brin_minmax_union(internal,internal,internal),
    function 4(timestamp without time zone, date) brin_minmax_union(internal,internal,internal),
    function 4(timestamp without time zone, timestamp with time zone) brin_minmax_union(internal,internal,internal),
    function 4(timestamp without time zone, timestamp without time zone) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.date_minmax_ops default for type date using brin family pg_catalog.datetime_minmax_ops as storage date operator 1 <(date,date),
	operator 1 <(date,timestamp with time zone),
	operator 1 <(date,timestamp without time zone),
	operator 1 <(timestamp with time zone,date),
	operator 1 <(timestamp with time zone,timestamp with time zone),
	operator 1 <(timestamp with time zone,timestamp without time zone),
	operator 1 <(timestamp without time zone,date),
	operator 1 <(timestamp without time zone,timestamp with time zone),
	operator 1 <(timestamp without time zone,timestamp without time zone),
	operator 2 <=(date,date),
	operator 2 <=(date,timestamp with time zone),
	operator 2 <=(date,timestamp without time zone),
	operator 2 <=(timestamp with time zone,date),
	operator 2 <=(timestamp with time zone,timestamp with time zone),
	operator 2 <=(timestamp with time zone,timestamp without time zone),
	operator 2 <=(timestamp without time zone,date),
	operator 2 <=(timestamp without time zone,timestamp with time zone),
	operator 2 <=(timestamp without time zone,timestamp without time zone),
	operator 3 =(date,date),
	operator 3 =(date,timestamp with time zone),
	operator 3 =(date,timestamp without time zone),
	operator 3 =(timestamp with time zone,date),
	operator 3 =(timestamp with time zone,timestamp with time zone),
	operator 3 =(timestamp with time zone,timestamp without time zone),
	operator 3 =(timestamp without time zone,date),
	operator 3 =(timestamp without time zone,timestamp with time zone),
	operator 3 =(timestamp without time zone,timestamp without time zone),
	operator 4 >=(date,date),
	operator 4 >=(date,timestamp with time zone),
	operator 4 >=(date,timestamp without time zone),
	operator 4 >=(timestamp with time zone,date),
	operator 4 >=(timestamp with time zone,timestamp with time zone),
	operator 4 >=(timestamp with time zone,timestamp without time zone),
	operator 4 >=(timestamp without time zone,date),
	operator 4 >=(timestamp without time zone,timestamp with time zone),
	operator 4 >=(timestamp without time zone,timestamp without time zone),
	operator 5 >(date,date),
	operator 5 >(date,timestamp with time zone),
	operator 5 >(date,timestamp without time zone),
	operator 5 >(timestamp with time zone,date),
	operator 5 >(timestamp with time zone,timestamp with time zone),
	operator 5 >(timestamp with time zone,timestamp without time zone),
	operator 5 >(timestamp without time zone,date),
	operator 5 >(timestamp without time zone,timestamp with time zone),
	operator 5 >(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamp_minmax_ops default for type timestamp without time zone using brin family pg_catalog.datetime_minmax_ops as storage timestamp without time zone operator 1 <(date,date),
	operator 1 <(date,timestamp with time zone),
	operator 1 <(date,timestamp without time zone),
	operator 1 <(timestamp with time zone,date),
	operator 1 <(timestamp with time zone,timestamp with time zone),
	operator 1 <(timestamp with time zone,timestamp without time zone),
	operator 1 <(timestamp without time zone,date),
	operator 1 <(timestamp without time zone,timestamp with time zone),
	operator 1 <(timestamp without time zone,timestamp without time zone),
	operator 2 <=(date,date),
	operator 2 <=(date,timestamp with time zone),
	operator 2 <=(date,timestamp without time zone),
	operator 2 <=(timestamp with time zone,date),
	operator 2 <=(timestamp with time zone,timestamp with time zone),
	operator 2 <=(timestamp with time zone,timestamp without time zone),
	operator 2 <=(timestamp without time zone,date),
	operator 2 <=(timestamp without time zone,timestamp with time zone),
	operator 2 <=(timestamp without time zone,timestamp without time zone),
	operator 3 =(date,date),
	operator 3 =(date,timestamp with time zone),
	operator 3 =(date,timestamp without time zone),
	operator 3 =(timestamp with time zone,date),
	operator 3 =(timestamp with time zone,timestamp with time zone),
	operator 3 =(timestamp with time zone,timestamp without time zone),
	operator 3 =(timestamp without time zone,date),
	operator 3 =(timestamp without time zone,timestamp with time zone),
	operator 3 =(timestamp without time zone,timestamp without time zone),
	operator 4 >=(date,date),
	operator 4 >=(date,timestamp with time zone),
	operator 4 >=(date,timestamp without time zone),
	operator 4 >=(timestamp with time zone,date),
	operator 4 >=(timestamp with time zone,timestamp with time zone),
	operator 4 >=(timestamp with time zone,timestamp without time zone),
	operator 4 >=(timestamp without time zone,date),
	operator 4 >=(timestamp without time zone,timestamp with time zone),
	operator 4 >=(timestamp without time zone,timestamp without time zone),
	operator 5 >(date,date),
	operator 5 >(date,timestamp with time zone),
	operator 5 >(date,timestamp without time zone),
	operator 5 >(timestamp with time zone,date),
	operator 5 >(timestamp with time zone,timestamp with time zone),
	operator 5 >(timestamp with time zone,timestamp without time zone),
	operator 5 >(timestamp without time zone,date),
	operator 5 >(timestamp without time zone,timestamp with time zone),
	operator 5 >(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamptz_minmax_ops default for type timestamp with time zone using brin family pg_catalog.datetime_minmax_ops as storage timestamp with time zone operator 1 <(date,date),
	operator 1 <(date,timestamp with time zone),
	operator 1 <(date,timestamp without time zone),
	operator 1 <(timestamp with time zone,date),
	operator 1 <(timestamp with time zone,timestamp with time zone),
	operator 1 <(timestamp with time zone,timestamp without time zone),
	operator 1 <(timestamp without time zone,date),
	operator 1 <(timestamp without time zone,timestamp with time zone),
	operator 1 <(timestamp without time zone,timestamp without time zone),
	operator 2 <=(date,date),
	operator 2 <=(date,timestamp with time zone),
	operator 2 <=(date,timestamp without time zone),
	operator 2 <=(timestamp with time zone,date),
	operator 2 <=(timestamp with time zone,timestamp with time zone),
	operator 2 <=(timestamp with time zone,timestamp without time zone),
	operator 2 <=(timestamp without time zone,date),
	operator 2 <=(timestamp without time zone,timestamp with time zone),
	operator 2 <=(timestamp without time zone,timestamp without time zone),
	operator 3 =(date,date),
	operator 3 =(date,timestamp with time zone),
	operator 3 =(date,timestamp without time zone),
	operator 3 =(timestamp with time zone,date),
	operator 3 =(timestamp with time zone,timestamp with time zone),
	operator 3 =(timestamp with time zone,timestamp without time zone),
	operator 3 =(timestamp without time zone,date),
	operator 3 =(timestamp without time zone,timestamp with time zone),
	operator 3 =(timestamp without time zone,timestamp without time zone),
	operator 4 >=(date,date),
	operator 4 >=(date,timestamp with time zone),
	operator 4 >=(date,timestamp without time zone),
	operator 4 >=(timestamp with time zone,date),
	operator 4 >=(timestamp with time zone,timestamp with time zone),
	operator 4 >=(timestamp with time zone,timestamp without time zone),
	operator 4 >=(timestamp without time zone,date),
	operator 4 >=(timestamp without time zone,timestamp with time zone),
	operator 4 >=(timestamp without time zone,timestamp without time zone),
	operator 5 >(date,date),
	operator 5 >(date,timestamp with time zone),
	operator 5 >(date,timestamp without time zone),
	operator 5 >(timestamp with time zone,date),
	operator 5 >(timestamp with time zone,timestamp with time zone),
	operator 5 >(timestamp with time zone,timestamp without time zone),
	operator 5 >(timestamp without time zone,date),
	operator 5 >(timestamp without time zone,timestamp with time zone),
	operator 5 >(timestamp without time zone,timestamp without time zone);

create operator family pg_catalog.datetime_ops using btree;

alter operator family pg_catalog.datetime_ops using btree add
    function 1(date, date) date_cmp(date,date),
    function 1(date, timestamp with time zone) date_cmp_timestamptz(date,timestamp with time zone),
    function 1(date, timestamp without time zone) date_cmp_timestamp(date,timestamp without time zone),
    function 1(timestamp with time zone, date) timestamptz_cmp_date(timestamp with time zone,date),
    function 1(timestamp with time zone, timestamp with time zone) timestamptz_cmp(timestamp with time zone,timestamp with time zone),
    function 1(timestamp with time zone, timestamp without time zone) timestamptz_cmp_timestamp(timestamp with time zone,timestamp without time zone),
    function 1(timestamp without time zone, date) timestamp_cmp_date(timestamp without time zone,date),
    function 1(timestamp without time zone, timestamp with time zone) timestamp_cmp_timestamptz(timestamp without time zone,timestamp with time zone),
    function 1(timestamp without time zone, timestamp without time zone) timestamp_cmp(timestamp without time zone,timestamp without time zone),
    function 2(date, date) date_sortsupport(internal),
    function 2(timestamp with time zone, timestamp with time zone) timestamp_sortsupport(internal),
    function 2(timestamp without time zone, timestamp without time zone) timestamp_sortsupport(internal),
    function 3(date, interval) in_range(date,date,interval,boolean,boolean),
    function 3(timestamp with time zone, interval) in_range(timestamp with time zone,timestamp with time zone,interval,boolean,boolean),
    function 3(timestamp without time zone, interval) in_range(timestamp without time zone,timestamp without time zone,interval,boolean,boolean),
    function 4(date, date) btequalimage(oid),
    function 4(timestamp with time zone, timestamp with time zone) btequalimage(oid),
    function 4(timestamp without time zone, timestamp without time zone) btequalimage(oid);

create operator class pg_catalog.date_ops default for type date using btree family pg_catalog.datetime_ops as
    operator 1 <(date,date),
    operator 1 <(date,timestamp with time zone),
    operator 1 <(date,timestamp without time zone),
    operator 1 <(timestamp with time zone,date),
    operator 1 <(timestamp with time zone,timestamp with time zone),
    operator 1 <(timestamp with time zone,timestamp without time zone),
    operator 1 <(timestamp without time zone,date),
    operator 1 <(timestamp without time zone,timestamp with time zone),
    operator 1 <(timestamp without time zone,timestamp without time zone),
    operator 2 <=(date,date),
    operator 2 <=(date,timestamp with time zone),
    operator 2 <=(date,timestamp without time zone),
    operator 2 <=(timestamp with time zone,date),
    operator 2 <=(timestamp with time zone,timestamp with time zone),
    operator 2 <=(timestamp with time zone,timestamp without time zone),
    operator 2 <=(timestamp without time zone,date),
    operator 2 <=(timestamp without time zone,timestamp with time zone),
    operator 2 <=(timestamp without time zone,timestamp without time zone),
    operator 3 =(date,date),
    operator 3 =(date,timestamp with time zone),
    operator 3 =(date,timestamp without time zone),
    operator 3 =(timestamp with time zone,date),
    operator 3 =(timestamp with time zone,timestamp with time zone),
    operator 3 =(timestamp with time zone,timestamp without time zone),
    operator 3 =(timestamp without time zone,date),
    operator 3 =(timestamp without time zone,timestamp with time zone),
    operator 3 =(timestamp without time zone,timestamp without time zone),
    operator 4 >=(date,date),
    operator 4 >=(date,timestamp with time zone),
    operator 4 >=(date,timestamp without time zone),
    operator 4 >=(timestamp with time zone,date),
    operator 4 >=(timestamp with time zone,timestamp with time zone),
    operator 4 >=(timestamp with time zone,timestamp without time zone),
    operator 4 >=(timestamp without time zone,date),
    operator 4 >=(timestamp without time zone,timestamp with time zone),
    operator 4 >=(timestamp without time zone,timestamp without time zone),
    operator 5 >(date,date),
    operator 5 >(date,timestamp with time zone),
    operator 5 >(date,timestamp without time zone),
    operator 5 >(timestamp with time zone,date),
    operator 5 >(timestamp with time zone,timestamp with time zone),
    operator 5 >(timestamp with time zone,timestamp without time zone),
    operator 5 >(timestamp without time zone,date),
    operator 5 >(timestamp without time zone,timestamp with time zone),
    operator 5 >(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamp_ops default for type timestamp without time zone using btree family pg_catalog.datetime_ops as
    operator 1 <(date,date),
    operator 1 <(date,timestamp with time zone),
    operator 1 <(date,timestamp without time zone),
    operator 1 <(timestamp with time zone,date),
    operator 1 <(timestamp with time zone,timestamp with time zone),
    operator 1 <(timestamp with time zone,timestamp without time zone),
    operator 1 <(timestamp without time zone,date),
    operator 1 <(timestamp without time zone,timestamp with time zone),
    operator 1 <(timestamp without time zone,timestamp without time zone),
    operator 2 <=(date,date),
    operator 2 <=(date,timestamp with time zone),
    operator 2 <=(date,timestamp without time zone),
    operator 2 <=(timestamp with time zone,date),
    operator 2 <=(timestamp with time zone,timestamp with time zone),
    operator 2 <=(timestamp with time zone,timestamp without time zone),
    operator 2 <=(timestamp without time zone,date),
    operator 2 <=(timestamp without time zone,timestamp with time zone),
    operator 2 <=(timestamp without time zone,timestamp without time zone),
    operator 3 =(date,date),
    operator 3 =(date,timestamp with time zone),
    operator 3 =(date,timestamp without time zone),
    operator 3 =(timestamp with time zone,date),
    operator 3 =(timestamp with time zone,timestamp with time zone),
    operator 3 =(timestamp with time zone,timestamp without time zone),
    operator 3 =(timestamp without time zone,date),
    operator 3 =(timestamp without time zone,timestamp with time zone),
    operator 3 =(timestamp without time zone,timestamp without time zone),
    operator 4 >=(date,date),
    operator 4 >=(date,timestamp with time zone),
    operator 4 >=(date,timestamp without time zone),
    operator 4 >=(timestamp with time zone,date),
    operator 4 >=(timestamp with time zone,timestamp with time zone),
    operator 4 >=(timestamp with time zone,timestamp without time zone),
    operator 4 >=(timestamp without time zone,date),
    operator 4 >=(timestamp without time zone,timestamp with time zone),
    operator 4 >=(timestamp without time zone,timestamp without time zone),
    operator 5 >(date,date),
    operator 5 >(date,timestamp with time zone),
    operator 5 >(date,timestamp without time zone),
    operator 5 >(timestamp with time zone,date),
    operator 5 >(timestamp with time zone,timestamp with time zone),
    operator 5 >(timestamp with time zone,timestamp without time zone),
    operator 5 >(timestamp without time zone,date),
    operator 5 >(timestamp without time zone,timestamp with time zone),
    operator 5 >(timestamp without time zone,timestamp without time zone);

create operator class pg_catalog.timestamptz_ops default for type timestamp with time zone using btree family pg_catalog.datetime_ops as
    operator 1 <(date,date),
    operator 1 <(date,timestamp with time zone),
    operator 1 <(date,timestamp without time zone),
    operator 1 <(timestamp with time zone,date),
    operator 1 <(timestamp with time zone,timestamp with time zone),
    operator 1 <(timestamp with time zone,timestamp without time zone),
    operator 1 <(timestamp without time zone,date),
    operator 1 <(timestamp without time zone,timestamp with time zone),
    operator 1 <(timestamp without time zone,timestamp without time zone),
    operator 2 <=(date,date),
    operator 2 <=(date,timestamp with time zone),
    operator 2 <=(date,timestamp without time zone),
    operator 2 <=(timestamp with time zone,date),
    operator 2 <=(timestamp with time zone,timestamp with time zone),
    operator 2 <=(timestamp with time zone,timestamp without time zone),
    operator 2 <=(timestamp without time zone,date),
    operator 2 <=(timestamp without time zone,timestamp with time zone),
    operator 2 <=(timestamp without time zone,timestamp without time zone),
    operator 3 =(date,date),
    operator 3 =(date,timestamp with time zone),
    operator 3 =(date,timestamp without time zone),
    operator 3 =(timestamp with time zone,date),
    operator 3 =(timestamp with time zone,timestamp with time zone),
    operator 3 =(timestamp with time zone,timestamp without time zone),
    operator 3 =(timestamp without time zone,date),
    operator 3 =(timestamp without time zone,timestamp with time zone),
    operator 3 =(timestamp without time zone,timestamp without time zone),
    operator 4 >=(date,date),
    operator 4 >=(date,timestamp with time zone),
    operator 4 >=(date,timestamp without time zone),
    operator 4 >=(timestamp with time zone,date),
    operator 4 >=(timestamp with time zone,timestamp with time zone),
    operator 4 >=(timestamp with time zone,timestamp without time zone),
    operator 4 >=(timestamp without time zone,date),
    operator 4 >=(timestamp without time zone,timestamp with time zone),
    operator 4 >=(timestamp without time zone,timestamp without time zone),
    operator 5 >(date,date),
    operator 5 >(date,timestamp with time zone),
    operator 5 >(date,timestamp without time zone),
    operator 5 >(timestamp with time zone,date),
    operator 5 >(timestamp with time zone,timestamp with time zone),
    operator 5 >(timestamp with time zone,timestamp without time zone),
    operator 5 >(timestamp without time zone,date),
    operator 5 >(timestamp without time zone,timestamp with time zone),
    operator 5 >(timestamp without time zone,timestamp without time zone);

create operator family pg_catalog.enum_ops using btree;

alter operator family pg_catalog.enum_ops using btree add
    function 1(anyenum, anyenum) enum_cmp(anyenum,anyenum),
    function 4(anyenum, anyenum) btequalimage(oid);

create operator class pg_catalog.enum_ops default for type anyenum using btree as
    operator 1 <(anyenum,anyenum),
    operator 2 <=(anyenum,anyenum),
    operator 3 =(anyenum,anyenum),
    operator 4 >=(anyenum,anyenum),
    operator 5 >(anyenum,anyenum);

create operator class pg_catalog.enum_ops default for type anyenum using hash as
    operator 1 <(anyenum,anyenum),
    operator 2 <=(anyenum,anyenum),
    operator 3 =(anyenum,anyenum),
    operator 4 >=(anyenum,anyenum),
    operator 5 >(anyenum,anyenum);

create operator family pg_catalog.enum_ops using hash;

alter operator family pg_catalog.enum_ops using hash add
    operator 1 =(anyenum,anyenum),
    function 1(anyenum, anyenum) hashenum(anyenum),
    function 2(anyenum, anyenum) hashenumextended(anyenum,bigint);

create operator family pg_catalog.float_minmax_ops using brin;

alter operator family pg_catalog.float_minmax_ops using brin add
    function 1(double precision, double precision) brin_minmax_opcinfo(internal),
    function 1(double precision, real) brin_minmax_opcinfo(internal),
    function 1(real, double precision) brin_minmax_opcinfo(internal),
    function 1(real, real) brin_minmax_opcinfo(internal),
    function 2(double precision, double precision) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(double precision, real) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(real, double precision) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(real, real) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(double precision, double precision) brin_minmax_consistent(internal,internal,internal),
    function 3(double precision, real) brin_minmax_consistent(internal,internal,internal),
    function 3(real, double precision) brin_minmax_consistent(internal,internal,internal),
    function 3(real, real) brin_minmax_consistent(internal,internal,internal),
    function 4(double precision, double precision) brin_minmax_union(internal,internal,internal),
    function 4(double precision, real) brin_minmax_union(internal,internal,internal),
    function 4(real, double precision) brin_minmax_union(internal,internal,internal),
    function 4(real, real) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.float4_minmax_ops default for type real using brin family pg_catalog.float_minmax_ops as storage real operator 1 <(double precision,double precision),
	operator 1 <(double precision,real),
	operator 1 <(real,double precision),
	operator 1 <(real,real),
	operator 2 <=(double precision,double precision),
	operator 2 <=(double precision,real),
	operator 2 <=(real,double precision),
	operator 2 <=(real,real),
	operator 3 =(double precision,double precision),
	operator 3 =(double precision,real),
	operator 3 =(real,double precision),
	operator 3 =(real,real),
	operator 4 >=(double precision,double precision),
	operator 4 >=(double precision,real),
	operator 4 >=(real,double precision),
	operator 4 >=(real,real),
	operator 5 >(double precision,double precision),
	operator 5 >(double precision,real),
	operator 5 >(real,double precision),
	operator 5 >(real,real);

create operator class pg_catalog.float8_minmax_ops default for type double precision using brin family pg_catalog.float_minmax_ops as storage double precision operator 1 <(double precision,double precision),
	operator 1 <(double precision,real),
	operator 1 <(real,double precision),
	operator 1 <(real,real),
	operator 2 <=(double precision,double precision),
	operator 2 <=(double precision,real),
	operator 2 <=(real,double precision),
	operator 2 <=(real,real),
	operator 3 =(double precision,double precision),
	operator 3 =(double precision,real),
	operator 3 =(real,double precision),
	operator 3 =(real,real),
	operator 4 >=(double precision,double precision),
	operator 4 >=(double precision,real),
	operator 4 >=(real,double precision),
	operator 4 >=(real,real),
	operator 5 >(double precision,double precision),
	operator 5 >(double precision,real),
	operator 5 >(real,double precision),
	operator 5 >(real,real);

create operator family pg_catalog.float_ops using btree;

alter operator family pg_catalog.float_ops using btree add
    function 1(double precision, double precision) btfloat8cmp(double precision,double precision),
    function 1(double precision, real) btfloat84cmp(double precision,real),
    function 1(real, double precision) btfloat48cmp(real,double precision),
    function 1(real, real) btfloat4cmp(real,real),
    function 2(double precision, double precision) btfloat8sortsupport(internal),
    function 2(real, real) btfloat4sortsupport(internal),
    function 3(double precision, double precision) in_range(double precision,double precision,double precision,boolean,boolean),
    function 3(real, double precision) in_range(real,real,double precision,boolean,boolean);

create operator class pg_catalog.float4_ops default for type real using btree family pg_catalog.float_ops as
    operator 1 <(double precision,double precision),
    operator 1 <(double precision,real),
    operator 1 <(real,double precision),
    operator 1 <(real,real),
    operator 2 <=(double precision,double precision),
    operator 2 <=(double precision,real),
    operator 2 <=(real,double precision),
    operator 2 <=(real,real),
    operator 3 =(double precision,double precision),
    operator 3 =(double precision,real),
    operator 3 =(real,double precision),
    operator 3 =(real,real),
    operator 4 >=(double precision,double precision),
    operator 4 >=(double precision,real),
    operator 4 >=(real,double precision),
    operator 4 >=(real,real),
    operator 5 >(double precision,double precision),
    operator 5 >(double precision,real),
    operator 5 >(real,double precision),
    operator 5 >(real,real);

create operator class pg_catalog.float4_ops default for type real using hash family pg_catalog.float_ops as
    operator 1 <(double precision,double precision),
    operator 1 <(double precision,real),
    operator 1 <(real,double precision),
    operator 1 <(real,real),
    operator 2 <=(double precision,double precision),
    operator 2 <=(double precision,real),
    operator 2 <=(real,double precision),
    operator 2 <=(real,real),
    operator 3 =(double precision,double precision),
    operator 3 =(double precision,real),
    operator 3 =(real,double precision),
    operator 3 =(real,real),
    operator 4 >=(double precision,double precision),
    operator 4 >=(double precision,real),
    operator 4 >=(real,double precision),
    operator 4 >=(real,real),
    operator 5 >(double precision,double precision),
    operator 5 >(double precision,real),
    operator 5 >(real,double precision),
    operator 5 >(real,real);

create operator class pg_catalog.float8_ops default for type double precision using btree family pg_catalog.float_ops as
    operator 1 <(double precision,double precision),
    operator 1 <(double precision,real),
    operator 1 <(real,double precision),
    operator 1 <(real,real),
    operator 2 <=(double precision,double precision),
    operator 2 <=(double precision,real),
    operator 2 <=(real,double precision),
    operator 2 <=(real,real),
    operator 3 =(double precision,double precision),
    operator 3 =(double precision,real),
    operator 3 =(real,double precision),
    operator 3 =(real,real),
    operator 4 >=(double precision,double precision),
    operator 4 >=(double precision,real),
    operator 4 >=(real,double precision),
    operator 4 >=(real,real),
    operator 5 >(double precision,double precision),
    operator 5 >(double precision,real),
    operator 5 >(real,double precision),
    operator 5 >(real,real);

create operator class pg_catalog.float8_ops default for type double precision using hash family pg_catalog.float_ops as
    operator 1 <(double precision,double precision),
    operator 1 <(double precision,real),
    operator 1 <(real,double precision),
    operator 1 <(real,real),
    operator 2 <=(double precision,double precision),
    operator 2 <=(double precision,real),
    operator 2 <=(real,double precision),
    operator 2 <=(real,real),
    operator 3 =(double precision,double precision),
    operator 3 =(double precision,real),
    operator 3 =(real,double precision),
    operator 3 =(real,real),
    operator 4 >=(double precision,double precision),
    operator 4 >=(double precision,real),
    operator 4 >=(real,double precision),
    operator 4 >=(real,real),
    operator 5 >(double precision,double precision),
    operator 5 >(double precision,real),
    operator 5 >(real,double precision),
    operator 5 >(real,real);

create operator family pg_catalog.float_ops using hash;

alter operator family pg_catalog.float_ops using hash add
    operator 1 =(double precision,double precision),
    operator 1 =(double precision,real),
    operator 1 =(real,double precision),
    operator 1 =(real,real),
    function 1(double precision, double precision) hashfloat8(double precision),
    function 1(real, real) hashfloat4(real),
    function 2(double precision, double precision) hashfloat8extended(double precision,bigint),
    function 2(real, real) hashfloat4extended(real,bigint);

create operator family pg_catalog.integer_minmax_ops using brin;

alter operator family pg_catalog.integer_minmax_ops using brin add
    function 1(bigint, bigint) brin_minmax_opcinfo(internal),
    function 1(bigint, integer) brin_minmax_opcinfo(internal),
    function 1(bigint, smallint) brin_minmax_opcinfo(internal),
    function 1(integer, bigint) brin_minmax_opcinfo(internal),
    function 1(integer, integer) brin_minmax_opcinfo(internal),
    function 1(integer, smallint) brin_minmax_opcinfo(internal),
    function 1(smallint, bigint) brin_minmax_opcinfo(internal),
    function 1(smallint, integer) brin_minmax_opcinfo(internal),
    function 1(smallint, smallint) brin_minmax_opcinfo(internal),
    function 2(bigint, bigint) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(bigint, integer) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(bigint, smallint) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(integer, bigint) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(integer, integer) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(integer, smallint) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(smallint, bigint) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(smallint, integer) brin_minmax_add_value(internal,internal,internal,internal),
    function 2(smallint, smallint) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(bigint, bigint) brin_minmax_consistent(internal,internal,internal),
    function 3(bigint, integer) brin_minmax_consistent(internal,internal,internal),
    function 3(bigint, smallint) brin_minmax_consistent(internal,internal,internal),
    function 3(integer, bigint) brin_minmax_consistent(internal,internal,internal),
    function 3(integer, integer) brin_minmax_consistent(internal,internal,internal),
    function 3(integer, smallint) brin_minmax_consistent(internal,internal,internal),
    function 3(smallint, bigint) brin_minmax_consistent(internal,internal,internal),
    function 3(smallint, integer) brin_minmax_consistent(internal,internal,internal),
    function 3(smallint, smallint) brin_minmax_consistent(internal,internal,internal),
    function 4(bigint, bigint) brin_minmax_union(internal,internal,internal),
    function 4(bigint, integer) brin_minmax_union(internal,internal,internal),
    function 4(bigint, smallint) brin_minmax_union(internal,internal,internal),
    function 4(integer, bigint) brin_minmax_union(internal,internal,internal),
    function 4(integer, integer) brin_minmax_union(internal,internal,internal),
    function 4(integer, smallint) brin_minmax_union(internal,internal,internal),
    function 4(smallint, bigint) brin_minmax_union(internal,internal,internal),
    function 4(smallint, integer) brin_minmax_union(internal,internal,internal),
    function 4(smallint, smallint) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.int2_minmax_ops default for type smallint using brin family pg_catalog.integer_minmax_ops as storage smallint operator 1 <(bigint,bigint),
	operator 1 <(bigint,integer),
	operator 1 <(bigint,smallint),
	operator 1 <(integer,bigint),
	operator 1 <(integer,integer),
	operator 1 <(integer,smallint),
	operator 1 <(smallint,bigint),
	operator 1 <(smallint,integer),
	operator 1 <(smallint,smallint),
	operator 2 <=(bigint,bigint),
	operator 2 <=(bigint,integer),
	operator 2 <=(bigint,smallint),
	operator 2 <=(integer,bigint),
	operator 2 <=(integer,integer),
	operator 2 <=(integer,smallint),
	operator 2 <=(smallint,bigint),
	operator 2 <=(smallint,integer),
	operator 2 <=(smallint,smallint),
	operator 3 =(bigint,bigint),
	operator 3 =(bigint,integer),
	operator 3 =(bigint,smallint),
	operator 3 =(integer,bigint),
	operator 3 =(integer,integer),
	operator 3 =(integer,smallint),
	operator 3 =(smallint,bigint),
	operator 3 =(smallint,integer),
	operator 3 =(smallint,smallint),
	operator 4 >=(bigint,bigint),
	operator 4 >=(bigint,integer),
	operator 4 >=(bigint,smallint),
	operator 4 >=(integer,bigint),
	operator 4 >=(integer,integer),
	operator 4 >=(integer,smallint),
	operator 4 >=(smallint,bigint),
	operator 4 >=(smallint,integer),
	operator 4 >=(smallint,smallint),
	operator 5 >(bigint,bigint),
	operator 5 >(bigint,integer),
	operator 5 >(bigint,smallint),
	operator 5 >(integer,bigint),
	operator 5 >(integer,integer),
	operator 5 >(integer,smallint),
	operator 5 >(smallint,bigint),
	operator 5 >(smallint,integer),
	operator 5 >(smallint,smallint);

create operator class pg_catalog.int4_minmax_ops default for type integer using brin family pg_catalog.integer_minmax_ops as storage integer operator 1 <(bigint,bigint),
	operator 1 <(bigint,integer),
	operator 1 <(bigint,smallint),
	operator 1 <(integer,bigint),
	operator 1 <(integer,integer),
	operator 1 <(integer,smallint),
	operator 1 <(smallint,bigint),
	operator 1 <(smallint,integer),
	operator 1 <(smallint,smallint),
	operator 2 <=(bigint,bigint),
	operator 2 <=(bigint,integer),
	operator 2 <=(bigint,smallint),
	operator 2 <=(integer,bigint),
	operator 2 <=(integer,integer),
	operator 2 <=(integer,smallint),
	operator 2 <=(smallint,bigint),
	operator 2 <=(smallint,integer),
	operator 2 <=(smallint,smallint),
	operator 3 =(bigint,bigint),
	operator 3 =(bigint,integer),
	operator 3 =(bigint,smallint),
	operator 3 =(integer,bigint),
	operator 3 =(integer,integer),
	operator 3 =(integer,smallint),
	operator 3 =(smallint,bigint),
	operator 3 =(smallint,integer),
	operator 3 =(smallint,smallint),
	operator 4 >=(bigint,bigint),
	operator 4 >=(bigint,integer),
	operator 4 >=(bigint,smallint),
	operator 4 >=(integer,bigint),
	operator 4 >=(integer,integer),
	operator 4 >=(integer,smallint),
	operator 4 >=(smallint,bigint),
	operator 4 >=(smallint,integer),
	operator 4 >=(smallint,smallint),
	operator 5 >(bigint,bigint),
	operator 5 >(bigint,integer),
	operator 5 >(bigint,smallint),
	operator 5 >(integer,bigint),
	operator 5 >(integer,integer),
	operator 5 >(integer,smallint),
	operator 5 >(smallint,bigint),
	operator 5 >(smallint,integer),
	operator 5 >(smallint,smallint);

create operator class pg_catalog.int8_minmax_ops default for type bigint using brin family pg_catalog.integer_minmax_ops as storage bigint operator 1 <(bigint,bigint),
	operator 1 <(bigint,integer),
	operator 1 <(bigint,smallint),
	operator 1 <(integer,bigint),
	operator 1 <(integer,integer),
	operator 1 <(integer,smallint),
	operator 1 <(smallint,bigint),
	operator 1 <(smallint,integer),
	operator 1 <(smallint,smallint),
	operator 2 <=(bigint,bigint),
	operator 2 <=(bigint,integer),
	operator 2 <=(bigint,smallint),
	operator 2 <=(integer,bigint),
	operator 2 <=(integer,integer),
	operator 2 <=(integer,smallint),
	operator 2 <=(smallint,bigint),
	operator 2 <=(smallint,integer),
	operator 2 <=(smallint,smallint),
	operator 3 =(bigint,bigint),
	operator 3 =(bigint,integer),
	operator 3 =(bigint,smallint),
	operator 3 =(integer,bigint),
	operator 3 =(integer,integer),
	operator 3 =(integer,smallint),
	operator 3 =(smallint,bigint),
	operator 3 =(smallint,integer),
	operator 3 =(smallint,smallint),
	operator 4 >=(bigint,bigint),
	operator 4 >=(bigint,integer),
	operator 4 >=(bigint,smallint),
	operator 4 >=(integer,bigint),
	operator 4 >=(integer,integer),
	operator 4 >=(integer,smallint),
	operator 4 >=(smallint,bigint),
	operator 4 >=(smallint,integer),
	operator 4 >=(smallint,smallint),
	operator 5 >(bigint,bigint),
	operator 5 >(bigint,integer),
	operator 5 >(bigint,smallint),
	operator 5 >(integer,bigint),
	operator 5 >(integer,integer),
	operator 5 >(integer,smallint),
	operator 5 >(smallint,bigint),
	operator 5 >(smallint,integer),
	operator 5 >(smallint,smallint);

create operator family pg_catalog.integer_ops using btree;

alter operator family pg_catalog.integer_ops using btree add
    function 1(bigint, bigint) btint8cmp(bigint,bigint),
    function 1(bigint, integer) btint84cmp(bigint,integer),
    function 1(bigint, smallint) btint82cmp(bigint,smallint),
    function 1(integer, bigint) btint48cmp(integer,bigint),
    function 1(integer, integer) btint4cmp(integer,integer),
    function 1(integer, smallint) btint42cmp(integer,smallint),
    function 1(smallint, bigint) btint28cmp(smallint,bigint),
    function 1(smallint, integer) btint24cmp(smallint,integer),
    function 1(smallint, smallint) btint2cmp(smallint,smallint),
    function 2(bigint, bigint) btint8sortsupport(internal),
    function 2(integer, integer) btint4sortsupport(internal),
    function 2(smallint, smallint) btint2sortsupport(internal),
    function 3(bigint, bigint) in_range(bigint,bigint,bigint,boolean,boolean),
    function 3(integer, bigint) in_range(integer,integer,bigint,boolean,boolean),
    function 3(integer, integer) in_range(integer,integer,integer,boolean,boolean),
    function 3(integer, smallint) in_range(integer,integer,smallint,boolean,boolean),
    function 3(smallint, bigint) in_range(smallint,smallint,bigint,boolean,boolean),
    function 3(smallint, integer) in_range(smallint,smallint,integer,boolean,boolean),
    function 3(smallint, smallint) in_range(smallint,smallint,smallint,boolean,boolean),
    function 4(bigint, bigint) btequalimage(oid),
    function 4(integer, integer) btequalimage(oid),
    function 4(smallint, smallint) btequalimage(oid);

create operator class pg_catalog.int2_ops default for type smallint using btree family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator class pg_catalog.int2_ops default for type smallint using hash family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator class pg_catalog.int4_ops default for type integer using btree family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator class pg_catalog.int4_ops default for type integer using hash family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator class pg_catalog.int8_ops default for type bigint using btree family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator class pg_catalog.int8_ops default for type bigint using hash family pg_catalog.integer_ops as
    operator 1 <(bigint,bigint),
    operator 1 <(bigint,integer),
    operator 1 <(bigint,smallint),
    operator 1 <(integer,bigint),
    operator 1 <(integer,integer),
    operator 1 <(integer,smallint),
    operator 1 <(smallint,bigint),
    operator 1 <(smallint,integer),
    operator 1 <(smallint,smallint),
    operator 2 <=(bigint,bigint),
    operator 2 <=(bigint,integer),
    operator 2 <=(bigint,smallint),
    operator 2 <=(integer,bigint),
    operator 2 <=(integer,integer),
    operator 2 <=(integer,smallint),
    operator 2 <=(smallint,bigint),
    operator 2 <=(smallint,integer),
    operator 2 <=(smallint,smallint),
    operator 3 =(bigint,bigint),
    operator 3 =(bigint,integer),
    operator 3 =(bigint,smallint),
    operator 3 =(integer,bigint),
    operator 3 =(integer,integer),
    operator 3 =(integer,smallint),
    operator 3 =(smallint,bigint),
    operator 3 =(smallint,integer),
    operator 3 =(smallint,smallint),
    operator 4 >=(bigint,bigint),
    operator 4 >=(bigint,integer),
    operator 4 >=(bigint,smallint),
    operator 4 >=(integer,bigint),
    operator 4 >=(integer,integer),
    operator 4 >=(integer,smallint),
    operator 4 >=(smallint,bigint),
    operator 4 >=(smallint,integer),
    operator 4 >=(smallint,smallint),
    operator 5 >(bigint,bigint),
    operator 5 >(bigint,integer),
    operator 5 >(bigint,smallint),
    operator 5 >(integer,bigint),
    operator 5 >(integer,integer),
    operator 5 >(integer,smallint),
    operator 5 >(smallint,bigint),
    operator 5 >(smallint,integer),
    operator 5 >(smallint,smallint);

create operator family pg_catalog.integer_ops using hash;

alter operator family pg_catalog.integer_ops using hash add
    operator 1 =(bigint,bigint),
    operator 1 =(bigint,integer),
    operator 1 =(bigint,smallint),
    operator 1 =(integer,bigint),
    operator 1 =(integer,integer),
    operator 1 =(integer,smallint),
    operator 1 =(smallint,bigint),
    operator 1 =(smallint,integer),
    operator 1 =(smallint,smallint),
    function 1(bigint, bigint) hashint8(bigint),
    function 1(integer, integer) hashint4(integer),
    function 1(smallint, smallint) hashint2(smallint),
    function 2(bigint, bigint) hashint8extended(bigint,bigint),
    function 2(integer, integer) hashint4extended(integer,bigint),
    function 2(smallint, smallint) hashint2extended(smallint,bigint);

create operator family pg_catalog.interval_minmax_ops using brin;

alter operator family pg_catalog.interval_minmax_ops using brin add
    function 1(interval, interval) brin_minmax_opcinfo(internal),
    function 2(interval, interval) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(interval, interval) brin_minmax_consistent(internal,internal,internal),
    function 4(interval, interval) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.interval_minmax_ops default for type interval using brin as storage interval operator 1 <(interval,interval),
	operator 2 <=(interval,interval),
	operator 3 =(interval,interval),
	operator 4 >=(interval,interval),
	operator 5 >(interval,interval);

create operator family pg_catalog.interval_ops using btree;

alter operator family pg_catalog.interval_ops using btree add
    function 1(interval, interval) interval_cmp(interval,interval),
    function 3(interval, interval) in_range(interval,interval,interval,boolean,boolean),
    function 4(interval, interval) btequalimage(oid);

create operator class pg_catalog.interval_ops default for type interval using btree as
    operator 1 <(interval,interval),
    operator 2 <=(interval,interval),
    operator 3 =(interval,interval),
    operator 4 >=(interval,interval),
    operator 5 >(interval,interval);

create operator class pg_catalog.interval_ops default for type interval using hash as
    operator 1 <(interval,interval),
    operator 2 <=(interval,interval),
    operator 3 =(interval,interval),
    operator 4 >=(interval,interval),
    operator 5 >(interval,interval);

create operator family pg_catalog.interval_ops using hash;

alter operator family pg_catalog.interval_ops using hash add
    operator 1 =(interval,interval),
    function 1(interval, interval) interval_hash(interval),
    function 2(interval, interval) interval_hash_extended(interval,bigint);

create operator family pg_catalog.jsonb_ops using btree;

alter operator family pg_catalog.jsonb_ops using btree add
    function 1(jsonb, jsonb) jsonb_cmp(jsonb,jsonb);

create operator class pg_catalog.jsonb_ops default for type jsonb using btree as
    operator 1 <(jsonb,jsonb),
    operator 2 <=(jsonb,jsonb),
    operator 3 =(jsonb,jsonb),
    operator 4 >=(jsonb,jsonb),
    operator 5 >(jsonb,jsonb);

create operator class pg_catalog.jsonb_ops default for type jsonb using gin as storage text operator 1 <(jsonb,jsonb),
	operator 2 <=(jsonb,jsonb),
	operator 3 =(jsonb,jsonb),
	operator 4 >=(jsonb,jsonb),
	operator 5 >(jsonb,jsonb);

create operator class pg_catalog.jsonb_ops default for type jsonb using hash as
    operator 1 <(jsonb,jsonb),
    operator 2 <=(jsonb,jsonb),
    operator 3 =(jsonb,jsonb),
    operator 4 >=(jsonb,jsonb),
    operator 5 >(jsonb,jsonb);

create operator family pg_catalog.jsonb_ops using gin;

alter operator family pg_catalog.jsonb_ops using gin add
    operator 10 ?|(jsonb,text[]),
    operator 11 ?&(jsonb,text[]),
    operator 15 @?(jsonb,jsonpath),
    operator 16 @@(jsonb,jsonpath),
    operator 7 @>(jsonb,jsonb),
    operator 9 ?(jsonb,text),
    function 1(jsonb, jsonb) gin_compare_jsonb(text,text),
    function 2(jsonb, jsonb) gin_extract_jsonb(jsonb,internal,internal),
    function 3(jsonb, jsonb) gin_extract_jsonb_query(jsonb,internal,smallint,internal,internal,internal,internal),
    function 4(jsonb, jsonb) gin_consistent_jsonb(internal,smallint,jsonb,integer,internal,internal,internal,internal),
    function 6(jsonb, jsonb) gin_triconsistent_jsonb(internal,smallint,jsonb,integer,internal,internal,internal);

create operator family pg_catalog.jsonb_ops using hash;

alter operator family pg_catalog.jsonb_ops using hash add
    operator 1 =(jsonb,jsonb),
    function 1(jsonb, jsonb) jsonb_hash(jsonb),
    function 2(jsonb, jsonb) jsonb_hash_extended(jsonb,bigint);

create operator family pg_catalog.jsonb_path_ops using gin;

alter operator family pg_catalog.jsonb_path_ops using gin add
    function 1(jsonb, jsonb) btint4cmp(integer,integer),
    function 2(jsonb, jsonb) gin_extract_jsonb_path(jsonb,internal,internal),
    function 3(jsonb, jsonb) gin_extract_jsonb_query_path(jsonb,internal,smallint,internal,internal,internal,internal),
    function 4(jsonb, jsonb) gin_consistent_jsonb_path(internal,smallint,jsonb,integer,internal,internal,internal,internal),
    function 6(jsonb, jsonb) gin_triconsistent_jsonb_path(internal,smallint,jsonb,integer,internal,internal,internal);

create operator class pg_catalog.jsonb_path_ops for type jsonb using gin as storage integer operator 15 @?(jsonb,jsonpath),
	operator 16 @@(jsonb,jsonpath),
	operator 7 @>(jsonb,jsonb);

create operator family pg_catalog.kd_point_ops using spgist;

alter operator family pg_catalog.kd_point_ops using spgist add
    function 1(point, point) spg_kd_config(internal,internal),
    function 2(point, point) spg_kd_choose(internal,internal),
    function 3(point, point) spg_kd_picksplit(internal,internal),
    function 4(point, point) spg_kd_inner_consistent(internal,internal),
    function 5(point, point) spg_quad_leaf_consistent(internal,internal);

create operator class pg_catalog.kd_point_ops for type point using spgist as
    operator 10 <^(point,point),
    operator 11 >^(point,point),
    operator 15 <->(point,point),
    operator 1 <<(point,point),
    operator 5 >>(point,point),
    operator 6 ~=(point,point),
    operator 8 <@(point,box);

create operator family pg_catalog.macaddr8_minmax_ops using brin;

alter operator family pg_catalog.macaddr8_minmax_ops using brin add
    function 1(macaddr8, macaddr8) brin_minmax_opcinfo(internal),
    function 2(macaddr8, macaddr8) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(macaddr8, macaddr8) brin_minmax_consistent(internal,internal,internal),
    function 4(macaddr8, macaddr8) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.macaddr8_minmax_ops default for type macaddr8 using brin as storage macaddr8 operator 1 <(macaddr8,macaddr8),
	operator 2 <=(macaddr8,macaddr8),
	operator 3 =(macaddr8,macaddr8),
	operator 4 >=(macaddr8,macaddr8),
	operator 5 >(macaddr8,macaddr8);

create operator family pg_catalog.macaddr8_ops using btree;

alter operator family pg_catalog.macaddr8_ops using btree add
    function 1(macaddr8, macaddr8) macaddr8_cmp(macaddr8,macaddr8),
    function 4(macaddr8, macaddr8) btequalimage(oid);

create operator class pg_catalog.macaddr8_ops default for type macaddr8 using btree as
    operator 1 <(macaddr8,macaddr8),
    operator 2 <=(macaddr8,macaddr8),
    operator 3 =(macaddr8,macaddr8),
    operator 4 >=(macaddr8,macaddr8),
    operator 5 >(macaddr8,macaddr8);

create operator class pg_catalog.macaddr8_ops default for type macaddr8 using hash as
    operator 1 <(macaddr8,macaddr8),
    operator 2 <=(macaddr8,macaddr8),
    operator 3 =(macaddr8,macaddr8),
    operator 4 >=(macaddr8,macaddr8),
    operator 5 >(macaddr8,macaddr8);

create operator family pg_catalog.macaddr8_ops using hash;

alter operator family pg_catalog.macaddr8_ops using hash add
    operator 1 =(macaddr8,macaddr8),
    function 1(macaddr8, macaddr8) hashmacaddr8(macaddr8),
    function 2(macaddr8, macaddr8) hashmacaddr8extended(macaddr8,bigint);

create operator family pg_catalog.macaddr_minmax_ops using brin;

alter operator family pg_catalog.macaddr_minmax_ops using brin add
    function 1(macaddr, macaddr) brin_minmax_opcinfo(internal),
    function 2(macaddr, macaddr) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(macaddr, macaddr) brin_minmax_consistent(internal,internal,internal),
    function 4(macaddr, macaddr) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.macaddr_minmax_ops default for type macaddr using brin as storage macaddr operator 1 <(macaddr,macaddr),
	operator 2 <=(macaddr,macaddr),
	operator 3 =(macaddr,macaddr),
	operator 4 >=(macaddr,macaddr),
	operator 5 >(macaddr,macaddr);

create operator family pg_catalog.macaddr_ops using btree;

alter operator family pg_catalog.macaddr_ops using btree add
    function 1(macaddr, macaddr) macaddr_cmp(macaddr,macaddr),
    function 2(macaddr, macaddr) macaddr_sortsupport(internal),
    function 4(macaddr, macaddr) btequalimage(oid);

create operator class pg_catalog.macaddr_ops default for type macaddr using btree as
    operator 1 <(macaddr,macaddr),
    operator 2 <=(macaddr,macaddr),
    operator 3 =(macaddr,macaddr),
    operator 4 >=(macaddr,macaddr),
    operator 5 >(macaddr,macaddr);

create operator class pg_catalog.macaddr_ops default for type macaddr using hash as
    operator 1 <(macaddr,macaddr),
    operator 2 <=(macaddr,macaddr),
    operator 3 =(macaddr,macaddr),
    operator 4 >=(macaddr,macaddr),
    operator 5 >(macaddr,macaddr);

create operator family pg_catalog.macaddr_ops using hash;

alter operator family pg_catalog.macaddr_ops using hash add
    operator 1 =(macaddr,macaddr),
    function 1(macaddr, macaddr) hashmacaddr(macaddr),
    function 2(macaddr, macaddr) hashmacaddrextended(macaddr,bigint);

create operator family pg_catalog.money_ops using btree;

alter operator family pg_catalog.money_ops using btree add
    function 1(money, money) cash_cmp(money,money),
    function 4(money, money) btequalimage(oid);

create operator class pg_catalog.money_ops default for type money using btree as
    operator 1 <(money,money),
    operator 2 <=(money,money),
    operator 3 =(money,money),
    operator 4 >=(money,money),
    operator 5 >(money,money);

create operator family pg_catalog.name_minmax_ops using brin;

alter operator family pg_catalog.name_minmax_ops using brin add
    function 1(name, name) brin_minmax_opcinfo(internal),
    function 2(name, name) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(name, name) brin_minmax_consistent(internal,internal,internal),
    function 4(name, name) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.name_minmax_ops default for type name using brin as storage name operator 1 <(name,name),
	operator 2 <=(name,name),
	operator 3 =(name,name),
	operator 4 >=(name,name),
	operator 5 >(name,name);

create operator family pg_catalog.network_inclusion_ops using brin;

alter operator family pg_catalog.network_inclusion_ops using brin add
    function 11(inet, inet) inet_merge(inet,inet),
    function 12(inet, inet) inet_same_family(inet,inet),
    function 13(inet, inet) network_supeq(inet,inet),
    function 1(inet, inet) brin_inclusion_opcinfo(internal),
    function 2(inet, inet) brin_inclusion_add_value(internal,internal,internal,internal),
    function 3(inet, inet) brin_inclusion_consistent(internal,internal,internal),
    function 4(inet, inet) brin_inclusion_union(internal,internal,internal);

create operator class pg_catalog.inet_inclusion_ops default for type inet using brin family pg_catalog.network_inclusion_ops as storage inet operator 18 =(inet,inet),
	operator 24 >>(inet,inet),
	operator 26 <<(inet,inet),
	operator 3 &&(inet,inet),
	operator 7 >>=(inet,inet),
	operator 8 <<=(inet,inet);

create operator family pg_catalog.network_minmax_ops using brin;

alter operator family pg_catalog.network_minmax_ops using brin add
    function 1(inet, inet) brin_minmax_opcinfo(internal),
    function 2(inet, inet) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(inet, inet) brin_minmax_consistent(internal,internal,internal),
    function 4(inet, inet) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.inet_minmax_ops for type inet using brin family pg_catalog.network_minmax_ops as storage inet operator 1 <(inet,inet),
	operator 2 <=(inet,inet),
	operator 3 =(inet,inet),
	operator 4 >=(inet,inet),
	operator 5 >(inet,inet);

create operator family pg_catalog.network_ops using btree;

alter operator family pg_catalog.network_ops using btree add
    function 1(inet, inet) network_cmp(inet,inet),
    function 2(inet, inet) network_sortsupport(internal),
    function 4(inet, inet) btequalimage(oid);

create operator class pg_catalog.cidr_ops for type inet using btree family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator class pg_catalog.cidr_ops for type inet using hash family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator class pg_catalog.inet_ops default for type inet using btree family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator class pg_catalog.inet_ops for type inet using gist family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator class pg_catalog.inet_ops default for type inet using hash family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator class pg_catalog.inet_ops default for type inet using spgist family pg_catalog.network_ops as
    operator 1 <(inet,inet),
    operator 2 <=(inet,inet),
    operator 3 =(inet,inet),
    operator 4 >=(inet,inet),
    operator 5 >(inet,inet);

create operator family pg_catalog.network_ops using gist;

alter operator family pg_catalog.network_ops using gist add
    operator 18 =(inet,inet),
    operator 19 <>(inet,inet),
    operator 20 <(inet,inet),
    operator 21 <=(inet,inet),
    operator 22 >(inet,inet),
    operator 23 >=(inet,inet),
    operator 24 <<(inet,inet),
    operator 25 <<=(inet,inet),
    operator 26 >>(inet,inet),
    operator 27 >>=(inet,inet),
    operator 3 &&(inet,inet),
    function 1(inet, inet) inet_gist_consistent(internal,inet,smallint,oid,internal),
    function 2(inet, inet) inet_gist_union(internal,internal),
    function 3(inet, inet) inet_gist_compress(internal),
    function 5(inet, inet) inet_gist_penalty(internal,internal,internal),
    function 6(inet, inet) inet_gist_picksplit(internal,internal),
    function 7(inet, inet) inet_gist_same(inet,inet,internal),
    function 9(inet, inet) inet_gist_fetch(internal);

create operator family pg_catalog.network_ops using hash;

alter operator family pg_catalog.network_ops using hash add
    operator 1 =(inet,inet),
    function 1(inet, inet) hashinet(inet),
    function 2(inet, inet) hashinetextended(inet,bigint);

create operator family pg_catalog.network_ops using spgist;

alter operator family pg_catalog.network_ops using spgist add
    operator 18 =(inet,inet),
    operator 19 <>(inet,inet),
    operator 20 <(inet,inet),
    operator 21 <=(inet,inet),
    operator 22 >(inet,inet),
    operator 23 >=(inet,inet),
    operator 24 <<(inet,inet),
    operator 25 <<=(inet,inet),
    operator 26 >>(inet,inet),
    operator 27 >>=(inet,inet),
    operator 3 &&(inet,inet),
    function 1(inet, inet) inet_spg_config(internal,internal),
    function 2(inet, inet) inet_spg_choose(internal,internal),
    function 3(inet, inet) inet_spg_picksplit(internal,internal),
    function 4(inet, inet) inet_spg_inner_consistent(internal,internal),
    function 5(inet, inet) inet_spg_leaf_consistent(internal,internal);

create operator family pg_catalog.numeric_minmax_ops using brin;

alter operator family pg_catalog.numeric_minmax_ops using brin add
    function 1(numeric, numeric) brin_minmax_opcinfo(internal),
    function 2(numeric, numeric) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(numeric, numeric) brin_minmax_consistent(internal,internal,internal),
    function 4(numeric, numeric) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.numeric_minmax_ops default for type numeric using brin as storage numeric operator 1 <(numeric,numeric),
	operator 2 <=(numeric,numeric),
	operator 3 =(numeric,numeric),
	operator 4 >=(numeric,numeric),
	operator 5 >(numeric,numeric);

create operator family pg_catalog.numeric_ops using btree;

alter operator family pg_catalog.numeric_ops using btree add
    function 1(numeric, numeric) numeric_cmp(numeric,numeric),
    function 2(numeric, numeric) numeric_sortsupport(internal),
    function 3(numeric, numeric) in_range(numeric,numeric,numeric,boolean,boolean);

create operator class pg_catalog.numeric_ops default for type numeric using btree as
    operator 1 <(numeric,numeric),
    operator 2 <=(numeric,numeric),
    operator 3 =(numeric,numeric),
    operator 4 >=(numeric,numeric),
    operator 5 >(numeric,numeric);

create operator class pg_catalog.numeric_ops default for type numeric using hash as
    operator 1 <(numeric,numeric),
    operator 2 <=(numeric,numeric),
    operator 3 =(numeric,numeric),
    operator 4 >=(numeric,numeric),
    operator 5 >(numeric,numeric);

create operator family pg_catalog.numeric_ops using hash;

alter operator family pg_catalog.numeric_ops using hash add
    operator 1 =(numeric,numeric),
    function 1(numeric, numeric) hash_numeric(numeric),
    function 2(numeric, numeric) hash_numeric_extended(numeric,bigint);

create operator family pg_catalog.oid_minmax_ops using brin;

alter operator family pg_catalog.oid_minmax_ops using brin add
    function 1(oid, oid) brin_minmax_opcinfo(internal),
    function 2(oid, oid) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(oid, oid) brin_minmax_consistent(internal,internal,internal),
    function 4(oid, oid) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.oid_minmax_ops default for type oid using brin as storage oid operator 1 <(oid,oid),
	operator 2 <=(oid,oid),
	operator 3 =(oid,oid),
	operator 4 >=(oid,oid),
	operator 5 >(oid,oid);

create operator family pg_catalog.oid_ops using btree;

alter operator family pg_catalog.oid_ops using btree add
    function 1(oid, oid) btoidcmp(oid,oid),
    function 2(oid, oid) btoidsortsupport(internal),
    function 4(oid, oid) btequalimage(oid);

create operator class pg_catalog.oid_ops default for type oid using btree as
    operator 1 <(oid,oid),
    operator 2 <=(oid,oid),
    operator 3 =(oid,oid),
    operator 4 >=(oid,oid),
    operator 5 >(oid,oid);

create operator class pg_catalog.oid_ops default for type oid using hash as
    operator 1 <(oid,oid),
    operator 2 <=(oid,oid),
    operator 3 =(oid,oid),
    operator 4 >=(oid,oid),
    operator 5 >(oid,oid);

create operator family pg_catalog.oid_ops using hash;

alter operator family pg_catalog.oid_ops using hash add
    operator 1 =(oid,oid),
    function 1(oid, oid) hashoid(oid),
    function 2(oid, oid) hashoidextended(oid,bigint);

create operator family pg_catalog.oidvector_ops using btree;

alter operator family pg_catalog.oidvector_ops using btree add
    function 1(oidvector, oidvector) btoidvectorcmp(oidvector,oidvector),
    function 4(oidvector, oidvector) btequalimage(oid);

create operator class pg_catalog.oidvector_ops default for type oidvector using btree as
    operator 1 <(oidvector,oidvector),
    operator 2 <=(oidvector,oidvector),
    operator 3 =(oidvector,oidvector),
    operator 4 >=(oidvector,oidvector),
    operator 5 >(oidvector,oidvector);

create operator class pg_catalog.oidvector_ops default for type oidvector using hash as
    operator 1 <(oidvector,oidvector),
    operator 2 <=(oidvector,oidvector),
    operator 3 =(oidvector,oidvector),
    operator 4 >=(oidvector,oidvector),
    operator 5 >(oidvector,oidvector);

create operator family pg_catalog.oidvector_ops using hash;

alter operator family pg_catalog.oidvector_ops using hash add
    operator 1 =(oidvector,oidvector),
    function 1(oidvector, oidvector) hashoidvector(oidvector),
    function 2(oidvector, oidvector) hashoidvectorextended(oidvector,bigint);

create operator family pg_catalog.pg_lsn_minmax_ops using brin;

alter operator family pg_catalog.pg_lsn_minmax_ops using brin add
    function 1(pg_lsn, pg_lsn) brin_minmax_opcinfo(internal),
    function 2(pg_lsn, pg_lsn) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(pg_lsn, pg_lsn) brin_minmax_consistent(internal,internal,internal),
    function 4(pg_lsn, pg_lsn) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.pg_lsn_minmax_ops default for type pg_lsn using brin as storage pg_lsn operator 1 <(pg_lsn,pg_lsn),
	operator 2 <=(pg_lsn,pg_lsn),
	operator 3 =(pg_lsn,pg_lsn),
	operator 4 >=(pg_lsn,pg_lsn),
	operator 5 >(pg_lsn,pg_lsn);

create operator family pg_catalog.pg_lsn_ops using btree;

alter operator family pg_catalog.pg_lsn_ops using btree add
    function 1(pg_lsn, pg_lsn) pg_lsn_cmp(pg_lsn,pg_lsn),
    function 4(pg_lsn, pg_lsn) btequalimage(oid);

create operator class pg_catalog.pg_lsn_ops default for type pg_lsn using btree as
    operator 1 <(pg_lsn,pg_lsn),
    operator 2 <=(pg_lsn,pg_lsn),
    operator 3 =(pg_lsn,pg_lsn),
    operator 4 >=(pg_lsn,pg_lsn),
    operator 5 >(pg_lsn,pg_lsn);

create operator class pg_catalog.pg_lsn_ops default for type pg_lsn using hash as
    operator 1 <(pg_lsn,pg_lsn),
    operator 2 <=(pg_lsn,pg_lsn),
    operator 3 =(pg_lsn,pg_lsn),
    operator 4 >=(pg_lsn,pg_lsn),
    operator 5 >(pg_lsn,pg_lsn);

create operator family pg_catalog.pg_lsn_ops using hash;

alter operator family pg_catalog.pg_lsn_ops using hash add
    operator 1 =(pg_lsn,pg_lsn),
    function 1(pg_lsn, pg_lsn) pg_lsn_hash(pg_lsn),
    function 2(pg_lsn, pg_lsn) pg_lsn_hash_extended(pg_lsn,bigint);

create operator family pg_catalog.point_ops using gist;

alter operator family pg_catalog.point_ops using gist add
    function 1(point, point) gist_point_consistent(internal,point,smallint,oid,internal),
    function 2(point, point) gist_box_union(internal,internal),
    function 3(point, point) gist_point_compress(internal),
    function 5(point, point) gist_box_penalty(internal,internal,internal),
    function 6(point, point) gist_box_picksplit(internal,internal),
    function 7(point, point) gist_box_same(box,box,internal),
    function 8(point, point) gist_point_distance(internal,point,smallint,oid,internal),
    function 9(point, point) gist_point_fetch(internal);

create operator class pg_catalog.point_ops default for type point using gist as storage box operator 10 <^(point,point),
	operator 11 >^(point,point),
	operator 15 <->(point,point),
	operator 1 <<(point,point),
	operator 28 <@(point,box),
	operator 48 <@(point,polygon),
	operator 5 >>(point,point),
	operator 68 <@(point,circle),
	operator 6 ~=(point,point);

create operator family pg_catalog.poly_ops using gist;

alter operator family pg_catalog.poly_ops using gist add
    function 1(polygon, polygon) gist_poly_consistent(internal,polygon,smallint,oid,internal),
    function 2(polygon, polygon) gist_box_union(internal,internal),
    function 3(polygon, polygon) gist_poly_compress(internal),
    function 5(polygon, polygon) gist_box_penalty(internal,internal,internal),
    function 6(polygon, polygon) gist_box_picksplit(internal,internal),
    function 7(polygon, polygon) gist_box_same(box,box,internal),
    function 8(polygon, polygon) gist_poly_distance(internal,polygon,smallint,oid,internal);

create operator class pg_catalog.poly_ops default for type polygon using gist as storage box operator 10 <<|(polygon,polygon),
	operator 11 |>>(polygon,polygon),
	operator 12 |&>(polygon,polygon),
	operator 13 ~(polygon,polygon),
	operator 14 @(polygon,polygon),
	operator 15 <->(polygon,point),
	operator 1 <<(polygon,polygon),
	operator 2 &<(polygon,polygon),
	operator 3 &&(polygon,polygon),
	operator 4 &>(polygon,polygon),
	operator 5 >>(polygon,polygon),
	operator 6 ~=(polygon,polygon),
	operator 7 @>(polygon,polygon),
	operator 8 <@(polygon,polygon),
	operator 9 &<|(polygon,polygon);

create operator class pg_catalog.poly_ops default for type polygon using spgist as storage box operator 10 <<|(polygon,polygon),
	operator 11 |>>(polygon,polygon),
	operator 12 |&>(polygon,polygon),
	operator 13 ~(polygon,polygon),
	operator 14 @(polygon,polygon),
	operator 15 <->(polygon,point),
	operator 1 <<(polygon,polygon),
	operator 2 &<(polygon,polygon),
	operator 3 &&(polygon,polygon),
	operator 4 &>(polygon,polygon),
	operator 5 >>(polygon,polygon),
	operator 6 ~=(polygon,polygon),
	operator 7 @>(polygon,polygon),
	operator 8 <@(polygon,polygon),
	operator 9 &<|(polygon,polygon);

create operator family pg_catalog.poly_ops using spgist;

alter operator family pg_catalog.poly_ops using spgist add
    operator 10 <<|(polygon,polygon),
    operator 11 |>>(polygon,polygon),
    operator 12 |&>(polygon,polygon),
    operator 15 <->(polygon,point),
    operator 1 <<(polygon,polygon),
    operator 2 &<(polygon,polygon),
    operator 3 &&(polygon,polygon),
    operator 4 &>(polygon,polygon),
    operator 5 >>(polygon,polygon),
    operator 6 ~=(polygon,polygon),
    operator 7 @>(polygon,polygon),
    operator 8 <@(polygon,polygon),
    operator 9 &<|(polygon,polygon),
    function 1(polygon, polygon) spg_bbox_quad_config(internal,internal),
    function 2(polygon, polygon) spg_box_quad_choose(internal,internal),
    function 3(polygon, polygon) spg_box_quad_picksplit(internal,internal),
    function 4(polygon, polygon) spg_box_quad_inner_consistent(internal,internal),
    function 5(polygon, polygon) spg_box_quad_leaf_consistent(internal,internal),
    function 6(polygon, polygon) spg_poly_quad_compress(polygon);

create operator family pg_catalog.quad_point_ops using spgist;

alter operator family pg_catalog.quad_point_ops using spgist add
    function 1(point, point) spg_quad_config(internal,internal),
    function 2(point, point) spg_quad_choose(internal,internal),
    function 3(point, point) spg_quad_picksplit(internal,internal),
    function 4(point, point) spg_quad_inner_consistent(internal,internal),
    function 5(point, point) spg_quad_leaf_consistent(internal,internal);

create operator class pg_catalog.quad_point_ops default for type point using spgist as
    operator 10 <^(point,point),
    operator 11 >^(point,point),
    operator 15 <->(point,point),
    operator 1 <<(point,point),
    operator 5 >>(point,point),
    operator 6 ~=(point,point),
    operator 8 <@(point,box);

create operator family pg_catalog.range_inclusion_ops using brin;

alter operator family pg_catalog.range_inclusion_ops using brin add
    function 11(anyrange, anyrange) range_merge(anyrange,anyrange),
    function 13(anyrange, anyrange) range_contains(anyrange,anyrange),
    function 14(anyrange, anyrange) isempty(anyrange),
    function 1(anyrange, anyrange) brin_inclusion_opcinfo(internal),
    function 2(anyrange, anyrange) brin_inclusion_add_value(internal,internal,internal,internal),
    function 3(anyrange, anyrange) brin_inclusion_consistent(internal,internal,internal),
    function 4(anyrange, anyrange) brin_inclusion_union(internal,internal,internal);

create operator class pg_catalog.range_inclusion_ops default for type anyrange using brin as storage anyrange operator 16 @>(anyrange,anyelement),
	operator 17 -|-(anyrange,anyrange),
	operator 18 =(anyrange,anyrange),
	operator 1 <<(anyrange,anyrange),
	operator 20 <(anyrange,anyrange),
	operator 21 <=(anyrange,anyrange),
	operator 22 >(anyrange,anyrange),
	operator 23 >=(anyrange,anyrange),
	operator 2 &<(anyrange,anyrange),
	operator 3 &&(anyrange,anyrange),
	operator 4 &>(anyrange,anyrange),
	operator 5 >>(anyrange,anyrange),
	operator 7 @>(anyrange,anyrange),
	operator 8 <@(anyrange,anyrange);

create operator family pg_catalog.range_ops using btree;

alter operator family pg_catalog.range_ops using btree add
    function 1(anyrange, anyrange) range_cmp(anyrange,anyrange);

create operator class pg_catalog.range_ops default for type anyrange using btree as
    operator 1 <(anyrange,anyrange),
    operator 2 <=(anyrange,anyrange),
    operator 3 =(anyrange,anyrange),
    operator 4 >=(anyrange,anyrange),
    operator 5 >(anyrange,anyrange);

create operator class pg_catalog.range_ops default for type anyrange using gist as
    operator 1 <(anyrange,anyrange),
    operator 2 <=(anyrange,anyrange),
    operator 3 =(anyrange,anyrange),
    operator 4 >=(anyrange,anyrange),
    operator 5 >(anyrange,anyrange);

create operator class pg_catalog.range_ops default for type anyrange using hash as
    operator 1 <(anyrange,anyrange),
    operator 2 <=(anyrange,anyrange),
    operator 3 =(anyrange,anyrange),
    operator 4 >=(anyrange,anyrange),
    operator 5 >(anyrange,anyrange);

create operator class pg_catalog.range_ops default for type anyrange using spgist as
    operator 1 <(anyrange,anyrange),
    operator 2 <=(anyrange,anyrange),
    operator 3 =(anyrange,anyrange),
    operator 4 >=(anyrange,anyrange),
    operator 5 >(anyrange,anyrange);

create operator family pg_catalog.range_ops using gist;

alter operator family pg_catalog.range_ops using gist add
    operator 16 @>(anyrange,anyelement),
    operator 18 =(anyrange,anyrange),
    operator 1 <<(anyrange,anyrange),
    operator 2 &<(anyrange,anyrange),
    operator 3 &&(anyrange,anyrange),
    operator 4 &>(anyrange,anyrange),
    operator 5 >>(anyrange,anyrange),
    operator 6 -|-(anyrange,anyrange),
    operator 7 @>(anyrange,anyrange),
    operator 8 <@(anyrange,anyrange),
    function 1(anyrange, anyrange) range_gist_consistent(internal,anyrange,smallint,oid,internal),
    function 2(anyrange, anyrange) range_gist_union(internal,internal),
    function 5(anyrange, anyrange) range_gist_penalty(internal,internal,internal),
    function 6(anyrange, anyrange) range_gist_picksplit(internal,internal),
    function 7(anyrange, anyrange) range_gist_same(anyrange,anyrange,internal);

create operator family pg_catalog.range_ops using hash;

alter operator family pg_catalog.range_ops using hash add
    operator 1 =(anyrange,anyrange),
    function 1(anyrange, anyrange) hash_range(anyrange),
    function 2(anyrange, anyrange) hash_range_extended(anyrange,bigint);

create operator family pg_catalog.range_ops using spgist;

alter operator family pg_catalog.range_ops using spgist add
    operator 16 @>(anyrange,anyelement),
    operator 18 =(anyrange,anyrange),
    operator 1 <<(anyrange,anyrange),
    operator 2 &<(anyrange,anyrange),
    operator 3 &&(anyrange,anyrange),
    operator 4 &>(anyrange,anyrange),
    operator 5 >>(anyrange,anyrange),
    operator 6 -|-(anyrange,anyrange),
    operator 7 @>(anyrange,anyrange),
    operator 8 <@(anyrange,anyrange),
    function 1(anyrange, anyrange) spg_range_quad_config(internal,internal),
    function 2(anyrange, anyrange) spg_range_quad_choose(internal,internal),
    function 3(anyrange, anyrange) spg_range_quad_picksplit(internal,internal),
    function 4(anyrange, anyrange) spg_range_quad_inner_consistent(internal,internal),
    function 5(anyrange, anyrange) spg_range_quad_leaf_consistent(internal,internal);

create operator family pg_catalog.record_image_ops using btree;

alter operator family pg_catalog.record_image_ops using btree add
    function 1(record, record) btrecordimagecmp(record,record);

create operator class pg_catalog.record_image_ops for type record using btree as
    operator 1 *<(record,record),
    operator 2 *<=(record,record),
    operator 3 *=(record,record),
    operator 4 *>=(record,record),
    operator 5 *>(record,record);

create operator family pg_catalog.record_ops using btree;

alter operator family pg_catalog.record_ops using btree add
    function 1(record, record) btrecordcmp(record,record);

create operator class pg_catalog.record_ops default for type record using btree as
    operator 1 <(record,record),
    operator 2 <=(record,record),
    operator 3 =(record,record),
    operator 4 >=(record,record),
    operator 5 >(record,record);

create operator family pg_catalog.text_minmax_ops using brin;

alter operator family pg_catalog.text_minmax_ops using brin add
    function 1(text, text) brin_minmax_opcinfo(internal),
    function 2(text, text) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(text, text) brin_minmax_consistent(internal,internal,internal),
    function 4(text, text) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.text_minmax_ops default for type text using brin as storage text operator 1 <(text,text),
	operator 2 <=(text,text),
	operator 3 =(text,text),
	operator 4 >=(text,text),
	operator 5 >(text,text);

create operator family pg_catalog.text_ops using btree;

alter operator family pg_catalog.text_ops using btree add
    function 1(name, name) btnamecmp(name,name),
    function 1(name, text) btnametextcmp(name,text),
    function 1(text, name) bttextnamecmp(text,name),
    function 1(text, text) bttextcmp(text,text),
    function 2(name, name) btnamesortsupport(internal),
    function 2(text, text) bttextsortsupport(internal),
    function 4(name, name) btvarstrequalimage(oid),
    function 4(text, text) btvarstrequalimage(oid);

create operator class pg_catalog.name_ops default for type name using btree family pg_catalog.text_ops as storage cstring operator 1 <(name,name),
	operator 1 <(name,text),
	operator 1 <(text,name),
	operator 1 <(text,text),
	operator 2 <=(name,name),
	operator 2 <=(name,text),
	operator 2 <=(text,name),
	operator 2 <=(text,text),
	operator 3 =(name,name),
	operator 3 =(name,text),
	operator 3 =(text,name),
	operator 3 =(text,text),
	operator 4 >=(name,name),
	operator 4 >=(name,text),
	operator 4 >=(text,name),
	operator 4 >=(text,text),
	operator 5 >(name,name),
	operator 5 >(name,text),
	operator 5 >(text,name),
	operator 5 >(text,text);

create operator class pg_catalog.name_ops default for type name using hash family pg_catalog.text_ops as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator class pg_catalog.text_ops default for type text using btree as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator class pg_catalog.text_ops default for type text using hash as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator class pg_catalog.text_ops default for type text using spgist as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator class pg_catalog.varchar_ops for type text using btree family pg_catalog.text_ops as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator class pg_catalog.varchar_ops for type text using hash family pg_catalog.text_ops as
    operator 1 <(name,name),
    operator 1 <(name,text),
    operator 1 <(text,name),
    operator 1 <(text,text),
    operator 2 <=(name,name),
    operator 2 <=(name,text),
    operator 2 <=(text,name),
    operator 2 <=(text,text),
    operator 3 =(name,name),
    operator 3 =(name,text),
    operator 3 =(text,name),
    operator 3 =(text,text),
    operator 4 >=(name,name),
    operator 4 >=(name,text),
    operator 4 >=(text,name),
    operator 4 >=(text,text),
    operator 5 >(name,name),
    operator 5 >(name,text),
    operator 5 >(text,name),
    operator 5 >(text,text);

create operator family pg_catalog.text_ops using hash;

alter operator family pg_catalog.text_ops using hash add
    operator 1 =(name,name),
    operator 1 =(name,text),
    operator 1 =(text,name),
    operator 1 =(text,text),
    function 1(name, name) hashname(name),
    function 1(text, text) hashtext(text),
    function 2(name, name) hashnameextended(name,bigint),
    function 2(text, text) hashtextextended(text,bigint);

create operator family pg_catalog.text_ops using spgist;

alter operator family pg_catalog.text_ops using spgist add
    operator 11 <(text,text),
    operator 12 <=(text,text),
    operator 14 >=(text,text),
    operator 15 >(text,text),
    operator 1 ~<~(text,text),
    operator 28 ^@(text,text),
    operator 2 ~<=~(text,text),
    operator 3 =(text,text),
    operator 4 ~>=~(text,text),
    operator 5 ~>~(text,text),
    function 1(text, text) spg_text_config(internal,internal),
    function 2(text, text) spg_text_choose(internal,internal),
    function 3(text, text) spg_text_picksplit(internal,internal),
    function 4(text, text) spg_text_inner_consistent(internal,internal),
    function 5(text, text) spg_text_leaf_consistent(internal,internal);

create operator family pg_catalog.text_pattern_ops using btree;

alter operator family pg_catalog.text_pattern_ops using btree add
    function 1(text, text) bttext_pattern_cmp(text,text),
    function 2(text, text) bttext_pattern_sortsupport(internal),
    function 4(text, text) btequalimage(oid);

create operator class pg_catalog.text_pattern_ops for type text using btree as
    operator 1 ~<~(text,text),
    operator 2 ~<=~(text,text),
    operator 3 =(text,text),
    operator 4 ~>=~(text,text),
    operator 5 ~>~(text,text);

create operator class pg_catalog.text_pattern_ops for type text using hash as
    operator 1 ~<~(text,text),
    operator 2 ~<=~(text,text),
    operator 3 =(text,text),
    operator 4 ~>=~(text,text),
    operator 5 ~>~(text,text);

create operator class pg_catalog.varchar_pattern_ops for type text using btree family pg_catalog.text_pattern_ops as
    operator 1 ~<~(text,text),
    operator 2 ~<=~(text,text),
    operator 3 =(text,text),
    operator 4 ~>=~(text,text),
    operator 5 ~>~(text,text);

create operator class pg_catalog.varchar_pattern_ops for type text using hash family pg_catalog.text_pattern_ops as
    operator 1 ~<~(text,text),
    operator 2 ~<=~(text,text),
    operator 3 =(text,text),
    operator 4 ~>=~(text,text),
    operator 5 ~>~(text,text);

create operator family pg_catalog.text_pattern_ops using hash;

alter operator family pg_catalog.text_pattern_ops using hash add
    operator 1 =(text,text),
    function 1(text, text) hashtext(text),
    function 2(text, text) hashtextextended(text,bigint);

create operator family pg_catalog.tid_minmax_ops using brin;

alter operator family pg_catalog.tid_minmax_ops using brin add
    function 1(tid, tid) brin_minmax_opcinfo(internal),
    function 2(tid, tid) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(tid, tid) brin_minmax_consistent(internal,internal,internal),
    function 4(tid, tid) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.tid_minmax_ops default for type tid using brin as storage tid operator 1 <(tid,tid),
	operator 2 <=(tid,tid),
	operator 3 =(tid,tid),
	operator 4 >=(tid,tid),
	operator 5 >(tid,tid);

create operator family pg_catalog.tid_ops using btree;

alter operator family pg_catalog.tid_ops using btree add
    function 1(tid, tid) bttidcmp(tid,tid),
    function 4(tid, tid) btequalimage(oid);

create operator class pg_catalog.tid_ops default for type tid using btree as
    operator 1 <(tid,tid),
    operator 2 <=(tid,tid),
    operator 3 =(tid,tid),
    operator 4 >=(tid,tid),
    operator 5 >(tid,tid);

create operator class pg_catalog.tid_ops default for type tid using hash as
    operator 1 <(tid,tid),
    operator 2 <=(tid,tid),
    operator 3 =(tid,tid),
    operator 4 >=(tid,tid),
    operator 5 >(tid,tid);

create operator family pg_catalog.tid_ops using hash;

alter operator family pg_catalog.tid_ops using hash add
    operator 1 =(tid,tid),
    function 1(tid, tid) hashtid(tid),
    function 2(tid, tid) hashtidextended(tid,bigint);

create operator family pg_catalog.time_minmax_ops using brin;

alter operator family pg_catalog.time_minmax_ops using brin add
    function 1(time without time zone, time without time zone) brin_minmax_opcinfo(internal),
    function 2(time without time zone, time without time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(time without time zone, time without time zone) brin_minmax_consistent(internal,internal,internal),
    function 4(time without time zone, time without time zone) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.time_minmax_ops default for type time without time zone using brin as storage time without time zone operator 1 <(time without time zone,time without time zone),
	operator 2 <=(time without time zone,time without time zone),
	operator 3 =(time without time zone,time without time zone),
	operator 4 >=(time without time zone,time without time zone),
	operator 5 >(time without time zone,time without time zone);

create operator family pg_catalog.time_ops using btree;

alter operator family pg_catalog.time_ops using btree add
    function 1(time without time zone, time without time zone) time_cmp(time without time zone,time without time zone),
    function 3(time without time zone, interval) in_range(time without time zone,time without time zone,interval,boolean,boolean),
    function 4(time without time zone, time without time zone) btequalimage(oid);

create operator class pg_catalog.time_ops default for type time without time zone using btree as
    operator 1 <(time without time zone,time without time zone),
    operator 2 <=(time without time zone,time without time zone),
    operator 3 =(time without time zone,time without time zone),
    operator 4 >=(time without time zone,time without time zone),
    operator 5 >(time without time zone,time without time zone);

create operator class pg_catalog.time_ops default for type time without time zone using hash as
    operator 1 <(time without time zone,time without time zone),
    operator 2 <=(time without time zone,time without time zone),
    operator 3 =(time without time zone,time without time zone),
    operator 4 >=(time without time zone,time without time zone),
    operator 5 >(time without time zone,time without time zone);

create operator family pg_catalog.time_ops using hash;

alter operator family pg_catalog.time_ops using hash add
    operator 1 =(time without time zone,time without time zone),
    function 1(time without time zone, time without time zone) time_hash(time without time zone),
    function 2(time without time zone, time without time zone) time_hash_extended(time without time zone,bigint);

create operator family pg_catalog.timestamp_ops using hash;

alter operator family pg_catalog.timestamp_ops using hash add
    function 1(timestamp without time zone, timestamp without time zone) timestamp_hash(timestamp without time zone),
    function 2(timestamp without time zone, timestamp without time zone) timestamp_hash_extended(timestamp without time zone,bigint);

create operator class pg_catalog.timestamp_ops default for type timestamp without time zone using hash as
    operator 1 =(timestamp without time zone,timestamp without time zone);

create operator family pg_catalog.timestamptz_ops using hash;

alter operator family pg_catalog.timestamptz_ops using hash add
    function 1(timestamp with time zone, timestamp with time zone) timestamp_hash(timestamp without time zone),
    function 2(timestamp with time zone, timestamp with time zone) timestamp_hash_extended(timestamp without time zone,bigint);

create operator class pg_catalog.timestamptz_ops default for type timestamp with time zone using hash as
    operator 1 =(timestamp with time zone,timestamp with time zone);

create operator family pg_catalog.timetz_minmax_ops using brin;

alter operator family pg_catalog.timetz_minmax_ops using brin add
    function 1(time with time zone, time with time zone) brin_minmax_opcinfo(internal),
    function 2(time with time zone, time with time zone) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(time with time zone, time with time zone) brin_minmax_consistent(internal,internal,internal),
    function 4(time with time zone, time with time zone) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.timetz_minmax_ops default for type time with time zone using brin as storage time with time zone operator 1 <(time with time zone,time with time zone),
	operator 2 <=(time with time zone,time with time zone),
	operator 3 =(time with time zone,time with time zone),
	operator 4 >=(time with time zone,time with time zone),
	operator 5 >(time with time zone,time with time zone);

create operator family pg_catalog.timetz_ops using btree;

alter operator family pg_catalog.timetz_ops using btree add
    function 1(time with time zone, time with time zone) timetz_cmp(time with time zone,time with time zone),
    function 3(time with time zone, interval) in_range(time with time zone,time with time zone,interval,boolean,boolean),
    function 4(time with time zone, time with time zone) btequalimage(oid);

create operator class pg_catalog.timetz_ops default for type time with time zone using btree as
    operator 1 <(time with time zone,time with time zone),
    operator 2 <=(time with time zone,time with time zone),
    operator 3 =(time with time zone,time with time zone),
    operator 4 >=(time with time zone,time with time zone),
    operator 5 >(time with time zone,time with time zone);

create operator class pg_catalog.timetz_ops default for type time with time zone using hash as
    operator 1 <(time with time zone,time with time zone),
    operator 2 <=(time with time zone,time with time zone),
    operator 3 =(time with time zone,time with time zone),
    operator 4 >=(time with time zone,time with time zone),
    operator 5 >(time with time zone,time with time zone);

create operator family pg_catalog.timetz_ops using hash;

alter operator family pg_catalog.timetz_ops using hash add
    operator 1 =(time with time zone,time with time zone),
    function 1(time with time zone, time with time zone) timetz_hash(time with time zone),
    function 2(time with time zone, time with time zone) timetz_hash_extended(time with time zone,bigint);

create operator family pg_catalog.tsquery_ops using btree;

alter operator family pg_catalog.tsquery_ops using btree add
    function 1(tsquery, tsquery) tsquery_cmp(tsquery,tsquery);

create operator class pg_catalog.tsquery_ops default for type tsquery using btree as
    operator 1 <(tsquery,tsquery),
    operator 2 <=(tsquery,tsquery),
    operator 3 =(tsquery,tsquery),
    operator 4 >=(tsquery,tsquery),
    operator 5 >(tsquery,tsquery);

create operator class pg_catalog.tsquery_ops default for type tsquery using gist as storage bigint operator 1 <(tsquery,tsquery),
	operator 2 <=(tsquery,tsquery),
	operator 3 =(tsquery,tsquery),
	operator 4 >=(tsquery,tsquery),
	operator 5 >(tsquery,tsquery);

create operator family pg_catalog.tsquery_ops using gist;

alter operator family pg_catalog.tsquery_ops using gist add
    operator 7 @>(tsquery,tsquery),
    operator 8 <@(tsquery,tsquery),
    function 1(tsquery, tsquery) gtsquery_consistent(internal,tsquery,smallint,oid,internal),
    function 2(tsquery, tsquery) gtsquery_union(internal,internal),
    function 3(tsquery, tsquery) gtsquery_compress(internal),
    function 5(tsquery, tsquery) gtsquery_penalty(internal,internal,internal),
    function 6(tsquery, tsquery) gtsquery_picksplit(internal,internal),
    function 7(tsquery, tsquery) gtsquery_same(bigint,bigint,internal);

create operator family pg_catalog.tsvector_ops using btree;

alter operator family pg_catalog.tsvector_ops using btree add
    function 1(tsvector, tsvector) tsvector_cmp(tsvector,tsvector);

create operator class pg_catalog.tsvector_ops default for type tsvector using btree as
    operator 1 <(tsvector,tsvector),
    operator 2 <=(tsvector,tsvector),
    operator 3 =(tsvector,tsvector),
    operator 4 >=(tsvector,tsvector),
    operator 5 >(tsvector,tsvector);

create operator class pg_catalog.tsvector_ops default for type tsvector using gin as storage text operator 1 <(tsvector,tsvector),
	operator 2 <=(tsvector,tsvector),
	operator 3 =(tsvector,tsvector),
	operator 4 >=(tsvector,tsvector),
	operator 5 >(tsvector,tsvector);

create operator class pg_catalog.tsvector_ops default for type tsvector using gist as storage gtsvector operator 1 <(tsvector,tsvector),
	operator 2 <=(tsvector,tsvector),
	operator 3 =(tsvector,tsvector),
	operator 4 >=(tsvector,tsvector),
	operator 5 >(tsvector,tsvector);

create operator family pg_catalog.tsvector_ops using gin;

alter operator family pg_catalog.tsvector_ops using gin add
    operator 1 @@(tsvector,tsquery),
    operator 2 @@@(tsvector,tsquery),
    function 1(tsvector, tsvector) gin_cmp_tslexeme(text,text),
    function 2(tsvector, tsvector) gin_extract_tsvector(tsvector,internal,internal),
    function 3(tsvector, tsvector) gin_extract_tsquery(tsvector,internal,smallint,internal,internal,internal,internal),
    function 4(tsvector, tsvector) gin_tsquery_consistent(internal,smallint,tsvector,integer,internal,internal,internal,internal),
    function 5(tsvector, tsvector) gin_cmp_prefix(text,text,smallint,internal),
    function 6(tsvector, tsvector) gin_tsquery_triconsistent(internal,smallint,tsvector,integer,internal,internal,internal);

create operator family pg_catalog.tsvector_ops using gist;

alter operator family pg_catalog.tsvector_ops using gist add
    operator 1 @@(tsvector,tsquery),
    function 10(tsvector, tsvector) gtsvector_options(internal),
    function 1(tsvector, tsvector) gtsvector_consistent(internal,tsvector,smallint,oid,internal),
    function 2(tsvector, tsvector) gtsvector_union(internal,internal),
    function 3(tsvector, tsvector) gtsvector_compress(internal),
    function 4(tsvector, tsvector) gtsvector_decompress(internal),
    function 5(tsvector, tsvector) gtsvector_penalty(internal,internal,internal),
    function 6(tsvector, tsvector) gtsvector_picksplit(internal,internal),
    function 7(tsvector, tsvector) gtsvector_same(gtsvector,gtsvector,internal);

create operator family pg_catalog.uuid_minmax_ops using brin;

alter operator family pg_catalog.uuid_minmax_ops using brin add
    function 1(uuid, uuid) brin_minmax_opcinfo(internal),
    function 2(uuid, uuid) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(uuid, uuid) brin_minmax_consistent(internal,internal,internal),
    function 4(uuid, uuid) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.uuid_minmax_ops default for type uuid using brin as storage uuid operator 1 <(uuid,uuid),
	operator 2 <=(uuid,uuid),
	operator 3 =(uuid,uuid),
	operator 4 >=(uuid,uuid),
	operator 5 >(uuid,uuid);

create operator family pg_catalog.uuid_ops using btree;

alter operator family pg_catalog.uuid_ops using btree add
    function 1(uuid, uuid) uuid_cmp(uuid,uuid),
    function 2(uuid, uuid) uuid_sortsupport(internal),
    function 4(uuid, uuid) btequalimage(oid);

create operator class pg_catalog.uuid_ops default for type uuid using btree as
    operator 1 <(uuid,uuid),
    operator 2 <=(uuid,uuid),
    operator 3 =(uuid,uuid),
    operator 4 >=(uuid,uuid),
    operator 5 >(uuid,uuid);

create operator class pg_catalog.uuid_ops default for type uuid using hash as
    operator 1 <(uuid,uuid),
    operator 2 <=(uuid,uuid),
    operator 3 =(uuid,uuid),
    operator 4 >=(uuid,uuid),
    operator 5 >(uuid,uuid);

create operator family pg_catalog.uuid_ops using hash;

alter operator family pg_catalog.uuid_ops using hash add
    operator 1 =(uuid,uuid),
    function 1(uuid, uuid) uuid_hash(uuid),
    function 2(uuid, uuid) uuid_hash_extended(uuid,bigint);

create operator family pg_catalog.varbit_minmax_ops using brin;

alter operator family pg_catalog.varbit_minmax_ops using brin add
    function 1(bit varying, bit varying) brin_minmax_opcinfo(internal),
    function 2(bit varying, bit varying) brin_minmax_add_value(internal,internal,internal,internal),
    function 3(bit varying, bit varying) brin_minmax_consistent(internal,internal,internal),
    function 4(bit varying, bit varying) brin_minmax_union(internal,internal,internal);

create operator class pg_catalog.varbit_minmax_ops default for type bit varying using brin as storage bit varying operator 1 <(bit varying,bit varying),
	operator 2 <=(bit varying,bit varying),
	operator 3 =(bit varying,bit varying),
	operator 4 >=(bit varying,bit varying),
	operator 5 >(bit varying,bit varying);

create operator family pg_catalog.varbit_ops using btree;

alter operator family pg_catalog.varbit_ops using btree add
    function 1(bit varying, bit varying) varbitcmp(bit varying,bit varying),
    function 4(bit varying, bit varying) btequalimage(oid);

create operator class pg_catalog.varbit_ops default for type bit varying using btree as
    operator 1 <(bit varying,bit varying),
    operator 2 <=(bit varying,bit varying),
    operator 3 =(bit varying,bit varying),
    operator 4 >=(bit varying,bit varying),
    operator 5 >(bit varying,bit varying);

create operator family pg_catalog.xid8_ops using btree;

alter operator family pg_catalog.xid8_ops using btree add
    operator 1 <(xid8,xid8),
    operator 2 <=(xid8,xid8),
    operator 3 =(xid8,xid8),
    operator 4 >=(xid8,xid8),
    operator 5 >(xid8,xid8),
    function 1(xid8, xid8) xid8cmp(xid8,xid8),
    function 4(xid8, xid8) btequalimage(oid);

create operator family pg_catalog.xid8_ops using hash;

alter operator family pg_catalog.xid8_ops using hash add
    function 1(xid8, xid8) hashint8(bigint),
    function 2(xid8, xid8) hashint8extended(bigint,bigint);

create operator class pg_catalog.xid8_ops default for type xid8 using btree as
    operator 1 =(xid8,xid8);

create operator class pg_catalog.xid8_ops default for type xid8 using hash as
    operator 1 =(xid8,xid8);

create operator family pg_catalog.xid_ops using hash;

alter operator family pg_catalog.xid_ops using hash add
    function 1(xid, xid) hashint4(integer),
    function 2(xid, xid) hashint4extended(integer,bigint);

create operator class pg_catalog.xid_ops default for type xid using hash as
    operator 1 =(xid,xid);

-- Cyclic dependencies found

create aggregate pg_catalog.bool_and(boolean) (
    sfunc = booland_statefunc,
    stype = ???,
combinefunc = booland_statefunc,
msfunc = bool_accum,
minvfunc = bool_accum_inv,
mfinalfunc = bool_alltrue,
sortop = operator(<)
);

comment on aggregate pg_catalog.bool_and(boolean) is 'boolean-and aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.bool_or(boolean) (
    sfunc = boolor_statefunc,
    stype = ???,
combinefunc = boolor_statefunc,
msfunc = bool_accum,
minvfunc = bool_accum_inv,
mfinalfunc = bool_anytrue,
sortop = operator(>)
);

comment on aggregate pg_catalog.bool_or(boolean) is 'boolean-or aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.every(boolean) (
    sfunc = booland_statefunc,
    stype = ???,
combinefunc = booland_statefunc,
msfunc = bool_accum,
minvfunc = bool_accum_inv,
mfinalfunc = bool_alltrue,
sortop = operator(<)
);

comment on aggregate pg_catalog.every(boolean) is 'boolean-and aggregate';

-- Cyclic dependencies found

create aggregate pg_catalog.max(anyarray) (
    sfunc = array_larger,
    stype = ???,
combinefunc = array_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(anyarray) is 'maximum value of all anyarray input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(bigint) (
    sfunc = int8larger,
    stype = ???,
combinefunc = int8larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(bigint) is 'maximum value of all bigint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(char) (
    sfunc = bpchar_larger,
    stype = ???,
combinefunc = bpchar_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(char) is 'maximum value of all bpchar input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(date) (
    sfunc = date_larger,
    stype = ???,
combinefunc = date_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(date) is 'maximum value of all date input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(anyenum) (
    sfunc = enum_larger,
    stype = ???,
combinefunc = enum_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(anyenum) is 'maximum value of all enum input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(real) (
    sfunc = float4larger,
    stype = ???,
combinefunc = float4larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(real) is 'maximum value of all float4 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(double precision) (
    sfunc = float8larger,
    stype = ???,
combinefunc = float8larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(double precision) is 'maximum value of all float8 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(inet) (
    sfunc = network_larger,
    stype = ???,
combinefunc = network_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(inet) is 'maximum value of all inet input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(integer) (
    sfunc = int4larger,
    stype = ???,
combinefunc = int4larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(integer) is 'maximum value of all integer input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(interval) (
    sfunc = interval_larger,
    stype = ???,
combinefunc = interval_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(interval) is 'maximum value of all interval input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(money) (
    sfunc = cashlarger,
    stype = ???,
combinefunc = cashlarger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(money) is 'maximum value of all money input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(numeric) (
    sfunc = numeric_larger,
    stype = ???,
combinefunc = numeric_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(numeric) is 'maximum value of all numeric input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(oid) (
    sfunc = oidlarger,
    stype = ???,
combinefunc = oidlarger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(oid) is 'maximum value of all oid input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(smallint) (
    sfunc = int2larger,
    stype = ???,
combinefunc = int2larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(smallint) is 'maximum value of all smallint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(text) (
    sfunc = text_larger,
    stype = ???,
combinefunc = text_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(text) is 'maximum value of all text input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(tid) (
    sfunc = tidlarger,
    stype = ???,
combinefunc = tidlarger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(tid) is 'maximum value of all tid input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(time) (
    sfunc = time_larger,
    stype = ???,
combinefunc = time_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(time) is 'maximum value of all time input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(time with time zone) (
    sfunc = timetz_larger,
    stype = ???,
combinefunc = timetz_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(time with time zone) is 'maximum value of all time with time zone input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(timestamp) (
    sfunc = timestamp_larger,
    stype = ???,
combinefunc = timestamp_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(timestamp) is 'maximum value of all timestamp input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(timestamp with time zone) (
    sfunc = timestamptz_larger,
    stype = ???,
combinefunc = timestamptz_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(timestamp with time zone) is 'maximum value of all timestamp with time zone input values';

-- Cyclic dependencies found

create aggregate pg_catalog.max(pg_lsn) (
    sfunc = pg_lsn_larger,
    stype = ???,
combinefunc = pg_lsn_larger,
sortop = operator(>)
);

comment on aggregate pg_catalog.max(pg_lsn) is 'maximum value of all pg_lsn input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(anyarray) (
    sfunc = array_smaller,
    stype = ???,
combinefunc = array_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(anyarray) is 'minimum value of all anyarray input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(bigint) (
    sfunc = int8smaller,
    stype = ???,
combinefunc = int8smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(bigint) is 'minimum value of all bigint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(char) (
    sfunc = bpchar_smaller,
    stype = ???,
combinefunc = bpchar_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(char) is 'minimum value of all bpchar input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(date) (
    sfunc = date_smaller,
    stype = ???,
combinefunc = date_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(date) is 'minimum value of all date input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(anyenum) (
    sfunc = enum_smaller,
    stype = ???,
combinefunc = enum_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(anyenum) is 'minimum value of all enum input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(real) (
    sfunc = float4smaller,
    stype = ???,
combinefunc = float4smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(real) is 'minimum value of all float4 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(double precision) (
    sfunc = float8smaller,
    stype = ???,
combinefunc = float8smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(double precision) is 'minimum value of all float8 input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(inet) (
    sfunc = network_smaller,
    stype = ???,
combinefunc = network_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(inet) is 'minimum value of all inet input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(integer) (
    sfunc = int4smaller,
    stype = ???,
combinefunc = int4smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(integer) is 'minimum value of all integer input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(interval) (
    sfunc = interval_smaller,
    stype = ???,
combinefunc = interval_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(interval) is 'minimum value of all interval input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(money) (
    sfunc = cashsmaller,
    stype = ???,
combinefunc = cashsmaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(money) is 'minimum value of all money input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(numeric) (
    sfunc = numeric_smaller,
    stype = ???,
combinefunc = numeric_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(numeric) is 'minimum value of all numeric input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(oid) (
    sfunc = oidsmaller,
    stype = ???,
combinefunc = oidsmaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(oid) is 'minimum value of all oid input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(smallint) (
    sfunc = int2smaller,
    stype = ???,
combinefunc = int2smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(smallint) is 'minimum value of all smallint input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(text) (
    sfunc = text_smaller,
    stype = ???,
combinefunc = text_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(text) is 'minimum value of all text values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(tid) (
    sfunc = tidsmaller,
    stype = ???,
combinefunc = tidsmaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(tid) is 'minimum value of all tid input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(time) (
    sfunc = time_smaller,
    stype = ???,
combinefunc = time_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(time) is 'minimum value of all time input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(time with time zone) (
    sfunc = timetz_smaller,
    stype = ???,
combinefunc = timetz_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(time with time zone) is 'minimum value of all time with time zone input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(timestamp) (
    sfunc = timestamp_smaller,
    stype = ???,
combinefunc = timestamp_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(timestamp) is 'minimum value of all timestamp input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(timestamp with time zone) (
    sfunc = timestamptz_smaller,
    stype = ???,
combinefunc = timestamptz_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(timestamp with time zone) is 'minimum value of all timestamp with time zone input values';

-- Cyclic dependencies found

create aggregate pg_catalog.min(pg_lsn) (
    sfunc = pg_lsn_smaller,
    stype = ???,
combinefunc = pg_lsn_smaller,
sortop = operator(<)
);

comment on aggregate pg_catalog.min(pg_lsn) is 'minimum value of all pg_lsn input values';

-- Cyclic dependencies found

create operator pg_catalog.!~ (procedure = pg_catalog.bpcharregexne, leftarg = char, rightarg = text, negator = pg_catalog.~, join = pg_catalog.regexnejoinsel, restrict = pg_catalog.regexnesel);

comment on operator pg_catalog.!~(char, text) is 'does not match regular expression, case-sensitive';

create operator pg_catalog.~ (procedure = pg_catalog.bpcharregexeq, leftarg = char, rightarg = text, negator = pg_catalog.!~, join = pg_catalog.regexeqjoinsel, restrict = pg_catalog.regexeqsel);

comment on operator pg_catalog.~(char, text) is 'matches regular expression, case-sensitive';

create operator pg_catalog.!~ (procedure = pg_catalog.nameregexne, leftarg = name, rightarg = text, negator = pg_catalog.~, join = pg_catalog.regexnejoinsel, restrict = pg_catalog.regexnesel);

comment on operator pg_catalog.!~(name, text) is 'does not match regular expression, case-sensitive';

create operator pg_catalog.!~ (procedure = pg_catalog.textregexne, leftarg = text, rightarg = text, negator = pg_catalog.~, join = pg_catalog.regexnejoinsel, restrict = pg_catalog.regexnesel);

comment on operator pg_catalog.!~(text, text) is 'does not match regular expression, case-sensitive';

create operator pg_catalog.~ (procedure = pg_catalog.nameregexeq, leftarg = name, rightarg = text, negator = pg_catalog.!~, join = pg_catalog.regexeqjoinsel, restrict = pg_catalog.regexeqsel);

comment on operator pg_catalog.~(name, text) is 'matches regular expression, case-sensitive';

create operator pg_catalog.~ (procedure = pg_catalog.textregexeq, leftarg = text, rightarg = text, negator = pg_catalog.!~, join = pg_catalog.regexeqjoinsel, restrict = pg_catalog.regexeqsel);

comment on operator pg_catalog.~(text, text) is 'matches regular expression, case-sensitive';

-- Cyclic dependencies found

create operator pg_catalog.!~* (procedure = pg_catalog.bpcharicregexne, leftarg = char, rightarg = text, negator = pg_catalog.~*, join = pg_catalog.icregexnejoinsel, restrict = pg_catalog.icregexnesel);

comment on operator pg_catalog.!~*(char, text) is 'does not match regular expression, case-insensitive';

create operator pg_catalog.~* (procedure = pg_catalog.bpcharicregexeq, leftarg = char, rightarg = text, negator = pg_catalog.!~*, join = pg_catalog.icregexeqjoinsel, restrict = pg_catalog.icregexeqsel);

comment on operator pg_catalog.~*(char, text) is 'matches regular expression, case-insensitive';

create operator pg_catalog.!~* (procedure = pg_catalog.nameicregexne, leftarg = name, rightarg = text, negator = pg_catalog.~*, join = pg_catalog.icregexnejoinsel, restrict = pg_catalog.icregexnesel);

comment on operator pg_catalog.!~*(name, text) is 'does not match regular expression, case-insensitive';

create operator pg_catalog.!~* (procedure = pg_catalog.texticregexne, leftarg = text, rightarg = text, negator = pg_catalog.~*, join = pg_catalog.icregexnejoinsel, restrict = pg_catalog.icregexnesel);

comment on operator pg_catalog.!~*(text, text) is 'does not match regular expression, case-insensitive';

create operator pg_catalog.~* (procedure = pg_catalog.nameicregexeq, leftarg = name, rightarg = text, negator = pg_catalog.!~*, join = pg_catalog.icregexeqjoinsel, restrict = pg_catalog.icregexeqsel);

comment on operator pg_catalog.~*(name, text) is 'matches regular expression, case-insensitive';

create operator pg_catalog.~* (procedure = pg_catalog.texticregexeq, leftarg = text, rightarg = text, negator = pg_catalog.!~*, join = pg_catalog.icregexeqjoinsel, restrict = pg_catalog.icregexeqsel);

comment on operator pg_catalog.~*(text, text) is 'matches regular expression, case-insensitive';

-- Cyclic dependencies found

create operator pg_catalog.!~~ (procedure = pg_catalog.byteanlike, leftarg = bytea, rightarg = bytea, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(bytea, bytea) is 'does not match LIKE expression';

create operator pg_catalog.~~ (procedure = pg_catalog.bytealike, leftarg = bytea, rightarg = bytea, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(bytea, bytea) is 'matches LIKE expression';

create operator pg_catalog.!~~ (procedure = pg_catalog.bpcharnlike, leftarg = char, rightarg = text, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(char, text) is 'does not match LIKE expression';

create operator pg_catalog.!~~ (procedure = pg_catalog.namenlike, leftarg = name, rightarg = text, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(name, text) is 'does not match LIKE expression';

create operator pg_catalog.!~~ (procedure = pg_catalog.textnlike, leftarg = text, rightarg = text, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(text, text) is 'does not match LIKE expression';

create operator pg_catalog.~~ (procedure = pg_catalog.bpcharlike, leftarg = char, rightarg = text, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(char, text) is 'matches LIKE expression';

create operator pg_catalog.~~ (procedure = pg_catalog.namelike, leftarg = name, rightarg = text, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(name, text) is 'matches LIKE expression';

create operator pg_catalog.~~ (procedure = pg_catalog.textlike, leftarg = text, rightarg = text, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(text, text) is 'matches LIKE expression';

-- Cyclic dependencies found

create operator pg_catalog.!~~* (procedure = pg_catalog.bpcharicnlike, leftarg = char, rightarg = text, negator = pg_catalog.~~*, join = pg_catalog.icnlikejoinsel, restrict = pg_catalog.icnlikesel);

comment on operator pg_catalog.!~~*(char, text) is 'does not match LIKE expression, case-insensitive';

create operator pg_catalog.~~* (procedure = pg_catalog.bpchariclike, leftarg = char, rightarg = text, negator = pg_catalog.!~~*, join = pg_catalog.iclikejoinsel, restrict = pg_catalog.iclikesel);

comment on operator pg_catalog.~~*(char, text) is 'matches LIKE expression, case-insensitive';

create operator pg_catalog.!~~* (procedure = pg_catalog.nameicnlike, leftarg = name, rightarg = text, negator = pg_catalog.~~*, join = pg_catalog.icnlikejoinsel, restrict = pg_catalog.icnlikesel);

comment on operator pg_catalog.!~~*(name, text) is 'does not match LIKE expression, case-insensitive';

create operator pg_catalog.!~~* (procedure = pg_catalog.texticnlike, leftarg = text, rightarg = text, negator = pg_catalog.~~*, join = pg_catalog.icnlikejoinsel, restrict = pg_catalog.icnlikesel);

comment on operator pg_catalog.!~~*(text, text) is 'does not match LIKE expression, case-insensitive';

create operator pg_catalog.~~* (procedure = pg_catalog.nameiclike, leftarg = name, rightarg = text, negator = pg_catalog.!~~*, join = pg_catalog.iclikejoinsel, restrict = pg_catalog.iclikesel);

comment on operator pg_catalog.~~*(name, text) is 'matches LIKE expression, case-insensitive';

create operator pg_catalog.~~* (procedure = pg_catalog.texticlike, leftarg = text, rightarg = text, negator = pg_catalog.!~~*, join = pg_catalog.iclikejoinsel, restrict = pg_catalog.iclikesel);

comment on operator pg_catalog.~~*(text, text) is 'matches LIKE expression, case-insensitive';

-- Cyclic dependencies found

create operator pg_catalog.*<> (procedure = pg_catalog.record_image_ne, leftarg = record, rightarg = record, commutator = pg_catalog.*<>, negator = pg_catalog.*=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.*<>(record, record) is 'not identical';

create operator pg_catalog.*= (procedure = pg_catalog.record_image_eq, leftarg = record, rightarg = record, commutator = pg_catalog.*=, negator = pg_catalog.*<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.*=(record, record) is 'identical';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.path_n_lt, leftarg = path, rightarg = path, commutator = pg_catalog.>);

comment on operator pg_catalog.<(path, path) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.<< (procedure = pg_catalog.range_before, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>>, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<<(anyrange, anyrange) is 'is left of';

create operator pg_catalog.>> (procedure = pg_catalog.range_after, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<<, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.>>(anyrange, anyrange) is 'is right of';

-- Cyclic dependencies found

create operator pg_catalog.<< (procedure = pg_catalog.network_sub, leftarg = inet, rightarg = inet, commutator = pg_catalog.>>, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.<<(inet, inet) is 'is subnet';

create operator pg_catalog.>> (procedure = pg_catalog.network_sup, leftarg = inet, rightarg = inet, commutator = pg_catalog.<<, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.>>(inet, inet) is 'is supernet';

-- Cyclic dependencies found

create operator pg_catalog.<<= (procedure = pg_catalog.network_subeq, leftarg = inet, rightarg = inet, commutator = pg_catalog.>>=, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.<<=(inet, inet) is 'is subnet or equal';

create operator pg_catalog.>>= (procedure = pg_catalog.network_supeq, leftarg = inet, rightarg = inet, commutator = pg_catalog.<<=, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.>>=(inet, inet) is 'is supernet or equal';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.path_n_le, leftarg = path, rightarg = path, commutator = pg_catalog.>=);

comment on operator pg_catalog.<=(path, path) is 'less than or equal';

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.charne, leftarg = "char", rightarg = "char", commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>("char", "char") is 'not equal';

create operator pg_catalog.= (procedure = pg_catalog.chareq, leftarg = "char", rightarg = "char", commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=("char", "char") is 'equal';

create operator pg_catalog.<> (procedure = pg_catalog.array_ne, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(anyarray, anyarray) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.enum_ne, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(anyenum, anyenum) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.range_ne, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(anyrange, anyrange) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.int8ne, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bigint, bigint) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.int84ne, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bigint, integer) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.int82ne, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bigint, smallint) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.varbitne, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bit varying, bit varying) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.bitne, leftarg = bit, rightarg = bit, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bit, bit) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.boolne, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(boolean, boolean) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.byteane, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bytea, bytea) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.bpcharne, leftarg = char, rightarg = char, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(char, char) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.circle_ne, leftarg = circle, rightarg = circle, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(circle, circle) is 'not equal by area';

create operator pg_catalog.<> (procedure = pg_catalog.date_ne, leftarg = date, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(date, date) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.date_ne_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(date, timestamp with time zone) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.date_ne_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(date, timestamp) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.float8ne, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(double precision, double precision) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.float84ne, leftarg = double precision, rightarg = real, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(double precision, real) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.network_ne, leftarg = inet, rightarg = inet, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(inet, inet) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.int48ne, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(integer, bigint) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.int4ne, leftarg = integer, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(integer, integer) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.int42ne, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(integer, smallint) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.interval_ne, leftarg = interval, rightarg = interval, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(interval, interval) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.jsonb_ne, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(jsonb, jsonb) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.lseg_ne, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(lseg, lseg) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.macaddr_ne, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(macaddr, macaddr) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.macaddr8_ne, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(macaddr8, macaddr8) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.cash_ne, leftarg = money, rightarg = money, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(money, money) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.namene, leftarg = name, rightarg = name, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(name, name) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.namenetext, leftarg = name, rightarg = text, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(name, text) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.numeric_ne, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(numeric, numeric) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.oidne, leftarg = oid, rightarg = oid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(oid, oid) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.oidvectorne, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(oidvector, oidvector) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.pg_lsn_ne, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(pg_lsn, pg_lsn) is 'not equal';

create operator pg_catalog.= (procedure = pg_catalog.aclitemeq, leftarg = aclitem, rightarg = aclitem, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes);

comment on operator pg_catalog.=(aclitem, aclitem) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.array_eq, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(anyarray, anyarray) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.enum_eq, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(anyenum, anyenum) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.range_eq, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(anyrange, anyrange) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.int8eq, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, bigint) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.int84eq, leftarg = bigint, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, integer) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.int82eq, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, smallint) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.varbiteq, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(bit varying, bit varying) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.biteq, leftarg = bit, rightarg = bit, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(bit, bit) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.booleq, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(boolean, boolean) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.box_eq, leftarg = box, rightarg = box, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(box, box) is 'equal by area';

create operator pg_catalog.= (procedure = pg_catalog.byteaeq, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bytea, bytea) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.bpchareq, leftarg = char, rightarg = char, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(char, char) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.cideq, leftarg = cid, rightarg = cid, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes);

comment on operator pg_catalog.=(cid, cid) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.circle_eq, leftarg = circle, rightarg = circle, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(circle, circle) is 'equal by area';

create operator pg_catalog.= (procedure = pg_catalog.date_eq, leftarg = date, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(date, date) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.date_eq_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(date, timestamp with time zone) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.date_eq_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(date, timestamp) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.float8eq, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(double precision, double precision) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.float84eq, leftarg = double precision, rightarg = real, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(double precision, real) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.network_eq, leftarg = inet, rightarg = inet, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(inet, inet) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.int48eq, leftarg = integer, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, bigint) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.int4eq, leftarg = integer, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, integer) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.int42eq, leftarg = integer, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, smallint) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.interval_eq, leftarg = interval, rightarg = interval, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(interval, interval) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.jsonb_eq, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(jsonb, jsonb) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.line_eq, leftarg = line, rightarg = line, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(line, line) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.lseg_eq, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(lseg, lseg) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.macaddr_eq, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(macaddr, macaddr) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.macaddr8_eq, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(macaddr8, macaddr8) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.cash_eq, leftarg = money, rightarg = money, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(money, money) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.nameeq, leftarg = name, rightarg = name, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(name, name) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.nameeqtext, leftarg = name, rightarg = text, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(name, text) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.numeric_eq, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(numeric, numeric) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.oideq, leftarg = oid, rightarg = oid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(oid, oid) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.oidvectoreq, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(oidvector, oidvector) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.path_n_eq, leftarg = path, rightarg = path, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(path, path) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.pg_lsn_eq, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(pg_lsn, pg_lsn) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.float48eq, leftarg = real, rightarg = double precision, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(real, double precision) is 'equal';

create operator pg_catalog.<> (procedure = pg_catalog.float48ne, leftarg = real, rightarg = double precision, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(real, double precision) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.float4ne, leftarg = real, rightarg = real, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(real, real) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.record_ne, leftarg = record, rightarg = record, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(record, record) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.int28ne, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(smallint, bigint) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.int24ne, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(smallint, integer) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.int2ne, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(smallint, smallint) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.textnename, leftarg = text, rightarg = name, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(text, name) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.textne, leftarg = text, rightarg = text, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(text, text) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.tidne, leftarg = tid, rightarg = tid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(tid, tid) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.timetz_ne, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(time with time zone, time with time zone) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.time_ne, leftarg = time, rightarg = time, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(time, time) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.timestamptz_ne_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, date) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.timestamptz_ne, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp with time zone) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.timestamptz_ne_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.timestamp_ne_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp, date) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.timestamp_ne_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp, timestamp with time zone) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.timestamp_ne, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp, timestamp) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.tsquery_ne, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(tsquery, tsquery) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.tsvector_ne, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(tsvector, tsvector) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.uuid_ne, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(uuid, uuid) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.xidneqint4, leftarg = xid, rightarg = integer, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(xid, integer) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.xidneq, leftarg = xid, rightarg = xid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(xid, xid) is 'not equal';

create operator pg_catalog.<> (procedure = pg_catalog.xid8ne, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(xid8, xid8) is 'not equal';

create operator pg_catalog.= (procedure = pg_catalog.float4eq, leftarg = real, rightarg = real, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(real, real) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.record_eq, leftarg = record, rightarg = record, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(record, record) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.int28eq, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, bigint) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.int24eq, leftarg = smallint, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, integer) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.int2eq, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, smallint) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.texteqname, leftarg = text, rightarg = name, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(text, name) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.texteq, leftarg = text, rightarg = text, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(text, text) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.tideq, leftarg = tid, rightarg = tid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(tid, tid) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.timetz_eq, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(time with time zone, time with time zone) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.time_eq, leftarg = time, rightarg = time, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(time, time) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.timestamptz_eq_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp with time zone, date) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.timestamptz_eq, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(timestamp with time zone, timestamp with time zone) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.timestamptz_eq_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp with time zone, timestamp) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.timestamp_eq_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp, date) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.timestamp_eq_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp, timestamp with time zone) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.timestamp_eq, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(timestamp, timestamp) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.tsquery_eq, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(tsquery, tsquery) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.tsvector_eq, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(tsvector, tsvector) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.uuid_eq, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(uuid, uuid) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.xideqint4, leftarg = xid, rightarg = integer, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(xid, integer) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.xideq, leftarg = xid, rightarg = xid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes);

comment on operator pg_catalog.=(xid, xid) is 'equal';

create operator pg_catalog.= (procedure = pg_catalog.xid8eq, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(xid8, xid8) is 'equal';

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.point_ne, leftarg = point, rightarg = point, commutator = pg_catalog.<>, negator = pg_catalog.~=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(point, point) is 'not equal';

create operator pg_catalog.~= (procedure = pg_catalog.point_eq, leftarg = point, rightarg = point, commutator = pg_catalog.~=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(point, point) is 'same as';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.box_contained, leftarg = box, rightarg = box, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(box, box) is 'is contained by';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.circle_contained, leftarg = circle, rightarg = circle, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(circle, circle) is 'is contained by';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.pt_contained_circle, leftarg = point, rightarg = circle, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(point, circle) is 'is contained by';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.pt_contained_poly, leftarg = point, rightarg = polygon, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(point, polygon) is 'is contained by';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.poly_contained, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(polygon, polygon) is 'is contained by';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.on_pb, leftarg = point, rightarg = box, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(point, box) is 'point inside box';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.on_ppath, leftarg = point, rightarg = path, commutator = pg_catalog.@>);

comment on operator pg_catalog.<@(point, path) is 'point within closed path, or point on open path';

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.arraycontained, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.@>, join = pg_catalog.arraycontjoinsel, restrict = pg_catalog.arraycontsel);

comment on operator pg_catalog.<@(anyarray, anyarray) is 'is contained by';

create operator pg_catalog.@> (procedure = pg_catalog.arraycontains, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<@, join = pg_catalog.arraycontjoinsel, restrict = pg_catalog.arraycontsel);

comment on operator pg_catalog.@>(anyarray, anyarray) is 'contains';

create operator pg_catalog.<@ (procedure = pg_catalog.elem_contained_by_range, leftarg = anyelement, rightarg = anyrange, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<@(anyelement, anyrange) is 'is contained by';

create operator pg_catalog.<@ (procedure = pg_catalog.range_contained_by, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<@(anyrange, anyrange) is 'is contained by';

create operator pg_catalog.<@ (procedure = pg_catalog.jsonb_contained, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.@>, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.<@(jsonb, jsonb) is 'is contained by';

create operator pg_catalog.@> (procedure = pg_catalog.range_contains_elem, leftarg = anyrange, rightarg = anyelement, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.@>(anyrange, anyelement) is 'contains';

create operator pg_catalog.@> (procedure = pg_catalog.range_contains, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.@>(anyrange, anyrange) is 'contains';

create operator pg_catalog.@> (procedure = pg_catalog.box_contain, leftarg = box, rightarg = box, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(box, box) is 'contains';

create operator pg_catalog.@> (procedure = pg_catalog.box_contain_pt, leftarg = box, rightarg = point, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(box, point) is 'contains';

create operator pg_catalog.@> (procedure = pg_catalog.circle_contain, leftarg = circle, rightarg = circle, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(circle, circle) is 'contains';

create operator pg_catalog.@> (procedure = pg_catalog.circle_contain_pt, leftarg = circle, rightarg = point, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(circle, point) is 'contains';

create operator pg_catalog.@> (procedure = pg_catalog.jsonb_contains, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<@, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@>(jsonb, jsonb) is 'contains';

create operator pg_catalog.@> (procedure = pg_catalog.path_contain_pt, leftarg = path, rightarg = point, commutator = pg_catalog.<@);

comment on operator pg_catalog.@>(path, point) is 'contains';

create operator pg_catalog.<@ (procedure = pg_catalog.tsq_mcontained, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.@>, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.<@(tsquery, tsquery) is 'is contained by';

create operator pg_catalog.@> (procedure = pg_catalog.poly_contain_pt, leftarg = polygon, rightarg = point, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(polygon, point) is 'contains';

create operator pg_catalog.@> (procedure = pg_catalog.poly_contain, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(polygon, polygon) is 'contains';

create operator pg_catalog.@> (procedure = pg_catalog.tsq_mcontains, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<@, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@>(tsquery, tsquery) is 'contains';

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.path_n_gt, leftarg = path, rightarg = path, commutator = pg_catalog.<);

comment on operator pg_catalog.>(path, path) is 'greater than';

-- Cyclic dependencies found

create operator pg_catalog.>= (procedure = pg_catalog.path_n_ge, leftarg = path, rightarg = path, commutator = pg_catalog.<=);

comment on operator pg_catalog.>=(path, path) is 'greater than or equal';

-- Cyclic dependencies found

create operator pg_catalog.@ (procedure = pg_catalog.box_contained, leftarg = box, rightarg = box, commutator = pg_catalog.~, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@(box, box) is 'deprecated, use <@ instead';

create operator pg_catalog.~ (procedure = pg_catalog.box_contain, leftarg = box, rightarg = box, commutator = pg_catalog.@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.~(box, box) is 'deprecated, use @> instead';

create operator pg_catalog.@ (procedure = pg_catalog.circle_contained, leftarg = circle, rightarg = circle, commutator = pg_catalog.~, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@(circle, circle) is 'deprecated, use <@ instead';

create operator pg_catalog.~ (procedure = pg_catalog.circle_contain, leftarg = circle, rightarg = circle, commutator = pg_catalog.@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.~(circle, circle) is 'deprecated, use @> instead';

create operator pg_catalog.~ (procedure = pg_catalog.circle_contain_pt, leftarg = circle, rightarg = point, commutator = pg_catalog.@);

comment on operator pg_catalog.~(circle, point) is 'deprecated, use @> instead';

create operator pg_catalog.@ (procedure = pg_catalog.pt_contained_circle, leftarg = point, rightarg = circle, commutator = pg_catalog.~);

comment on operator pg_catalog.@(point, circle) is 'deprecated, use <@ instead';

-- Cyclic dependencies found

create operator pg_catalog.@ (procedure = pg_catalog.on_ppath, leftarg = point, rightarg = path, commutator = pg_catalog.~);

comment on operator pg_catalog.@(point, path) is 'deprecated, use <@ instead';

create operator pg_catalog.~ (procedure = pg_catalog.path_contain_pt, leftarg = path, rightarg = point, commutator = pg_catalog.@);

comment on operator pg_catalog.~(path, point) is 'deprecated, use @> instead';

create operator pg_catalog.@ (procedure = pg_catalog.pt_contained_poly, leftarg = point, rightarg = polygon, commutator = pg_catalog.~);

comment on operator pg_catalog.@(point, polygon) is 'deprecated, use <@ instead';

create operator pg_catalog.@ (procedure = pg_catalog.poly_contained, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.~, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@(polygon, polygon) is 'deprecated, use <@ instead';

create operator pg_catalog.~ (procedure = pg_catalog.poly_contain_pt, leftarg = polygon, rightarg = point, commutator = pg_catalog.@);

comment on operator pg_catalog.~(polygon, point) is 'deprecated, use @> instead';

create operator pg_catalog.~ (procedure = pg_catalog.poly_contain, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.~(polygon, polygon) is 'deprecated, use @> instead';

-- Cyclic dependencies found

create operator &&& (procedure = overlaps_nd, leftarg = geometry, rightarg = gidx, commutator = &&&);

alter operator &&&(geometry, gidx) owner to postgres;

create operator &&& (procedure = overlaps_nd, leftarg = gidx, rightarg = geometry, commutator = &&&);

alter operator &&&(gidx, geometry) owner to postgres;

-- Cyclic dependencies found

create operator && (procedure = overlaps_2d, leftarg = box2df, rightarg = geometry, commutator = &&);

alter operator &&(box2df, geometry) owner to postgres;

create operator && (procedure = overlaps_2d, leftarg = geometry, rightarg = box2df, commutator = &&);

alter operator &&(geometry, box2df) owner to postgres;

-- Cyclic dependencies found

create operator && (procedure = overlaps_geog, leftarg = geography, rightarg = gidx, commutator = &&);

alter operator &&(geography, gidx) owner to postgres;

create operator && (procedure = overlaps_geog, leftarg = gidx, rightarg = geography, commutator = &&);

alter operator &&(gidx, geography) owner to postgres;

-- Cyclic dependencies found

create operator && (procedure = geometry_raster_overlap, leftarg = geometry, rightarg = raster, commutator = &&, join = contjoinsel, restrict = contsel);

alter operator &&(geometry, raster) owner to postgres;

create operator && (procedure = raster_geometry_overlap, leftarg = raster, rightarg = geometry, commutator = &&, join = contjoinsel, restrict = contsel);

alter operator &&(raster, geometry) owner to postgres;

-- Cyclic dependencies found

create operator &< (procedure = raster_overleft, leftarg = raster, rightarg = raster, commutator = &>, join = positionjoinsel, restrict = positionsel);

alter operator &<(raster, raster) owner to postgres;

create operator &> (procedure = raster_overright, leftarg = raster, rightarg = raster, commutator = &<, join = positionjoinsel, restrict = positionsel);

alter operator &>(raster, raster) owner to postgres;

-- Cyclic dependencies found

create operator &<| (procedure = raster_overbelow, leftarg = raster, rightarg = raster, commutator = |&>, join = positionjoinsel, restrict = positionsel);

alter operator &<|(raster, raster) owner to postgres;

create operator |&> (procedure = raster_overabove, leftarg = raster, rightarg = raster, commutator = &<|, join = positionjoinsel, restrict = positionsel);

alter operator |&>(raster, raster) owner to postgres;

-- Cyclic dependencies found

create operator << (procedure = geometry_left, leftarg = geometry, rightarg = geometry, commutator = >>, join = positionjoinsel, restrict = positionsel);

alter operator <<(geometry, geometry) owner to postgres;

create operator >> (procedure = geometry_right, leftarg = geometry, rightarg = geometry, commutator = <<, join = positionjoinsel, restrict = positionsel);

alter operator >>(geometry, geometry) owner to postgres;

-- Cyclic dependencies found

create operator << (procedure = raster_left, leftarg = raster, rightarg = raster, commutator = >>, join = positionjoinsel, restrict = positionsel);

alter operator <<(raster, raster) owner to postgres;

create operator >> (procedure = raster_right, leftarg = raster, rightarg = raster, commutator = <<, join = positionjoinsel, restrict = positionsel);

alter operator >>(raster, raster) owner to postgres;

-- Cyclic dependencies found

create operator <<@ (procedure = geometry_contained_3d, leftarg = geometry, rightarg = geometry, commutator = @>>, join = gserialized_gist_joinsel_nd, restrict = gserialized_gist_sel_nd);

alter operator <<@(geometry, geometry) owner to postgres;

create operator @>> (procedure = geometry_contains_3d, leftarg = geometry, rightarg = geometry, commutator = <<@, join = gserialized_gist_joinsel_nd, restrict = gserialized_gist_sel_nd);

alter operator @>>(geometry, geometry) owner to postgres;

-- Cyclic dependencies found

create operator <<| (procedure = geometry_below, leftarg = geometry, rightarg = geometry, commutator = |>>, join = positionjoinsel, restrict = positionsel);

alter operator <<|(geometry, geometry) owner to postgres;

create operator |>> (procedure = geometry_above, leftarg = geometry, rightarg = geometry, commutator = <<|, join = positionjoinsel, restrict = positionsel);

alter operator |>>(geometry, geometry) owner to postgres;

-- Cyclic dependencies found

create operator <<| (procedure = raster_below, leftarg = raster, rightarg = raster, commutator = |>>, join = positionjoinsel, restrict = positionsel);

alter operator <<|(raster, raster) owner to postgres;

create operator |>> (procedure = raster_above, leftarg = raster, rightarg = raster, commutator = <<|, join = positionjoinsel, restrict = positionsel);

alter operator |>>(raster, raster) owner to postgres;

-- Cyclic dependencies found

create operator @ (procedure = is_contained_2d, leftarg = box2df, rightarg = box2df, commutator = ~);

alter operator @(box2df, box2df) owner to postgres;

create operator ~ (procedure = contains_2d, leftarg = box2df, rightarg = box2df, commutator = @);

alter operator ~(box2df, box2df) owner to postgres;

-- Cyclic dependencies found

create operator @ (procedure = is_contained_2d, leftarg = box2df, rightarg = geometry, commutator = ~);

alter operator @(box2df, geometry) owner to postgres;

create operator ~ (procedure = contains_2d, leftarg = geometry, rightarg = box2df, commutator = @);

alter operator ~(geometry, box2df) owner to postgres;

-- Cyclic dependencies found

create operator @ (procedure = is_contained_2d, leftarg = geometry, rightarg = box2df, commutator = ~);

alter operator @(geometry, box2df) owner to postgres;

create operator ~ (procedure = contains_2d, leftarg = box2df, rightarg = geometry, commutator = @);

alter operator ~(box2df, geometry) owner to postgres;

-- Cyclic dependencies found

create operator @ (procedure = geometry_within, leftarg = geometry, rightarg = geometry, commutator = ~, join = contjoinsel, restrict = contsel);

alter operator @(geometry, geometry) owner to postgres;

create operator ~ (procedure = geometry_contains, leftarg = geometry, rightarg = geometry, commutator = @, join = contjoinsel, restrict = contsel);

alter operator ~(geometry, geometry) owner to postgres;

-- Cyclic dependencies found

create operator @ (procedure = geometry_contained_by_raster, leftarg = geometry, rightarg = raster, commutator = ~, join = contjoinsel, restrict = contsel);

alter operator @(geometry, raster) owner to postgres;

create operator ~ (procedure = raster_geometry_contain, leftarg = raster, rightarg = geometry, commutator = @, join = contjoinsel, restrict = contsel);

alter operator ~(raster, geometry) owner to postgres;

-- Cyclic dependencies found

create operator @ (procedure = raster_contained, leftarg = raster, rightarg = raster, commutator = ~, join = contjoinsel, restrict = contsel);

alter operator @(raster, raster) owner to postgres;

create operator ~ (procedure = raster_contain, leftarg = raster, rightarg = raster, commutator = @, join = contjoinsel, restrict = contsel);

alter operator ~(raster, raster) owner to postgres;

-- Cyclic dependencies found

create operator @@ (procedure = geometry_within_nd, leftarg = geometry, rightarg = geometry, commutator = ~~, join = gserialized_gist_joinsel_nd, restrict = gserialized_gist_sel_nd);

alter operator @@(geometry, geometry) owner to postgres;

create operator ~~ (procedure = geometry_contains_nd, leftarg = geometry, rightarg = geometry, commutator = @@, join = gserialized_gist_joinsel_nd, restrict = gserialized_gist_sel_nd);

alter operator ~~(geometry, geometry) owner to postgres;

-- Cyclic dependencies found

create operator pg_catalog.*< (procedure = pg_catalog.record_image_lt, leftarg = record, rightarg = record, commutator = pg_catalog.*>, negator = pg_catalog.*>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.*<(record, record) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.*> (procedure = pg_catalog.record_image_gt, leftarg = record, rightarg = record, commutator = pg_catalog.*<, negator = pg_catalog.*<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.*>(record, record) is 'greater than';

-- Cyclic dependencies found

create operator pg_catalog.*<= (procedure = pg_catalog.record_image_le, leftarg = record, rightarg = record, commutator = pg_catalog.*>=, negator = pg_catalog.*>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.*<=(record, record) is 'less than or equal';

create operator pg_catalog.*>= (procedure = pg_catalog.record_image_ge, leftarg = record, rightarg = record, commutator = pg_catalog.*<=, negator = pg_catalog.*<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.*>=(record, record) is 'greater than or equal';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.charlt, leftarg = "char", rightarg = "char", commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<("char", "char") is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.chargt, leftarg = "char", rightarg = "char", commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>("char", "char") is 'greater than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.array_lt, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(anyarray, anyarray) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.enum_lt, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(anyenum, anyenum) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int8lt, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bigint, bigint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int84lt, leftarg = bigint, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bigint, integer) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int82lt, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bigint, smallint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.varbitlt, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bit varying, bit varying) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.bitlt, leftarg = bit, rightarg = bit, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bit, bit) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.boollt, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(boolean, boolean) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.bytealt, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bytea, bytea) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.bpcharlt, leftarg = char, rightarg = char, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(char, char) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.date_lt, leftarg = date, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(date, date) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.date_lt_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(date, timestamp with time zone) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.date_lt_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(date, timestamp) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float8lt, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(double precision, double precision) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float84lt, leftarg = double precision, rightarg = real, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(double precision, real) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.network_lt, leftarg = inet, rightarg = inet, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(inet, inet) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int48lt, leftarg = integer, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(integer, bigint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int4lt, leftarg = integer, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(integer, integer) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int42lt, leftarg = integer, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(integer, smallint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.interval_lt, leftarg = interval, rightarg = interval, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(interval, interval) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.macaddr_lt, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(macaddr, macaddr) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.cash_lt, leftarg = money, rightarg = money, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(money, money) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.namelt, leftarg = name, rightarg = name, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(name, name) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.numeric_lt, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(numeric, numeric) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.oidvectorlt, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(oidvector, oidvector) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.oidlt, leftarg = oid, rightarg = oid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(oid, oid) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.range_lt, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<(anyrange, anyrange) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.jsonb_lt, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(jsonb, jsonb) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.box_lt, leftarg = box, rightarg = box, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<(box, box) is 'less than by area';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.circle_lt, leftarg = circle, rightarg = circle, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<(circle, circle) is 'less than by area';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.lseg_lt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.>, negator = pg_catalog.>=);

comment on operator pg_catalog.<(lseg, lseg) is 'less than by length';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.macaddr8_lt, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(macaddr8, macaddr8) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.namelttext, leftarg = name, rightarg = text, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(name, text) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.pg_lsn_lt, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(pg_lsn, pg_lsn) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float48lt, leftarg = real, rightarg = double precision, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(real, double precision) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float4lt, leftarg = real, rightarg = real, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(real, real) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.record_lt, leftarg = record, rightarg = record, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(record, record) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int28lt, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(smallint, bigint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int24lt, leftarg = smallint, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(smallint, integer) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int2lt, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(smallint, smallint) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.textltname, leftarg = text, rightarg = name, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(text, name) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.text_lt, leftarg = text, rightarg = text, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(text, text) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.tidlt, leftarg = tid, rightarg = tid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(tid, tid) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timetz_lt, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(time with time zone, time with time zone) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamptz_lt_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, date) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamptz_lt, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, timestamp with time zone) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamptz_lt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, timestamp) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamp_lt_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp, date) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamp_lt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp, timestamp with time zone) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamp_lt, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp, timestamp) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.time_lt, leftarg = time, rightarg = time, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(time, time) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.tsquery_lt, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(tsquery, tsquery) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.tsvector_lt, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(tsvector, tsvector) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.uuid_lt, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(uuid, uuid) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.xid8lt, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(xid8, xid8) is 'less than';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.box_le, leftarg = box, rightarg = box, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<=(box, box) is 'less than or equal by area';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.circle_le, leftarg = circle, rightarg = circle, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<=(circle, circle) is 'less than or equal by area';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.lseg_le, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.>=, negator = pg_catalog.>);

comment on operator pg_catalog.<=(lseg, lseg) is 'less than or equal by length';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.charle, leftarg = "char", rightarg = "char", commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=("char", "char") is 'less than or equal';

create operator pg_catalog.> (procedure = pg_catalog.array_gt, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(anyarray, anyarray) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.enum_gt, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(anyenum, anyenum) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.range_gt, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.>(anyrange, anyrange) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.int8gt, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bigint, bigint) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.int84gt, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bigint, integer) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.int82gt, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bigint, smallint) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.varbitgt, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bit varying, bit varying) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.bitgt, leftarg = bit, rightarg = bit, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bit, bit) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.boolgt, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(boolean, boolean) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.box_gt, leftarg = box, rightarg = box, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>(box, box) is 'greater than by area';

create operator pg_catalog.> (procedure = pg_catalog.byteagt, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bytea, bytea) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.bpchargt, leftarg = char, rightarg = char, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(char, char) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.circle_gt, leftarg = circle, rightarg = circle, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>(circle, circle) is 'greater than by area';

create operator pg_catalog.> (procedure = pg_catalog.date_gt, leftarg = date, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(date, date) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.date_gt_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(date, timestamp with time zone) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.date_gt_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(date, timestamp) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.float8gt, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(double precision, double precision) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.float84gt, leftarg = double precision, rightarg = real, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(double precision, real) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.network_gt, leftarg = inet, rightarg = inet, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(inet, inet) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.int48gt, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(integer, bigint) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.int4gt, leftarg = integer, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(integer, integer) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.int42gt, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(integer, smallint) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.interval_gt, leftarg = interval, rightarg = interval, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(interval, interval) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.jsonb_gt, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(jsonb, jsonb) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.lseg_gt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<, negator = pg_catalog.<=);

comment on operator pg_catalog.>(lseg, lseg) is 'greater than by length';

create operator pg_catalog.> (procedure = pg_catalog.macaddr_gt, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(macaddr, macaddr) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.macaddr8_gt, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(macaddr8, macaddr8) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.cash_gt, leftarg = money, rightarg = money, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(money, money) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.namegt, leftarg = name, rightarg = name, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(name, name) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.namegttext, leftarg = name, rightarg = text, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(name, text) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.numeric_gt, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(numeric, numeric) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.oidgt, leftarg = oid, rightarg = oid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(oid, oid) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.oidvectorgt, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(oidvector, oidvector) is 'greater than';

create operator pg_catalog.>= (procedure = pg_catalog.charge, leftarg = "char", rightarg = "char", commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=("char", "char") is 'greater than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.array_le, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(anyarray, anyarray) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.enum_le, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(anyenum, anyenum) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.range_le, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<=(anyrange, anyrange) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.int8le, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bigint, bigint) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.int84le, leftarg = bigint, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bigint, integer) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.int82le, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bigint, smallint) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.varbitle, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bit varying, bit varying) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.bitle, leftarg = bit, rightarg = bit, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bit, bit) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.boolle, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(boolean, boolean) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.byteale, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bytea, bytea) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.bpcharle, leftarg = char, rightarg = char, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(char, char) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.date_le, leftarg = date, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(date, date) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.date_le_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(date, timestamp with time zone) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.date_le_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(date, timestamp) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.float8le, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(double precision, double precision) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.float84le, leftarg = double precision, rightarg = real, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(double precision, real) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.network_le, leftarg = inet, rightarg = inet, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(inet, inet) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.int48le, leftarg = integer, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(integer, bigint) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.int4le, leftarg = integer, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(integer, integer) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.int42le, leftarg = integer, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(integer, smallint) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.interval_le, leftarg = interval, rightarg = interval, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(interval, interval) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.jsonb_le, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(jsonb, jsonb) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.macaddr_le, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(macaddr, macaddr) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.macaddr8_le, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(macaddr8, macaddr8) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.cash_le, leftarg = money, rightarg = money, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(money, money) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.namele, leftarg = name, rightarg = name, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(name, name) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.nameletext, leftarg = name, rightarg = text, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(name, text) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.numeric_le, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(numeric, numeric) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.oidle, leftarg = oid, rightarg = oid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(oid, oid) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.oidvectorle, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(oidvector, oidvector) is 'less than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.array_ge, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(anyarray, anyarray) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.enum_ge, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(anyenum, anyenum) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.range_ge, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.>=(anyrange, anyrange) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.int8ge, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bigint, bigint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.int84ge, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bigint, integer) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.int82ge, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bigint, smallint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.varbitge, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bit varying, bit varying) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.bitge, leftarg = bit, rightarg = bit, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bit, bit) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.boolge, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(boolean, boolean) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.box_ge, leftarg = box, rightarg = box, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>=(box, box) is 'greater than or equal by area';

create operator pg_catalog.>= (procedure = pg_catalog.byteage, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bytea, bytea) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.bpcharge, leftarg = char, rightarg = char, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(char, char) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.circle_ge, leftarg = circle, rightarg = circle, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>=(circle, circle) is 'greater than or equal by area';

create operator pg_catalog.>= (procedure = pg_catalog.date_ge, leftarg = date, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(date, date) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.date_ge_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(date, timestamp with time zone) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.date_ge_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(date, timestamp) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.float8ge, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(double precision, double precision) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.float84ge, leftarg = double precision, rightarg = real, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(double precision, real) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.network_ge, leftarg = inet, rightarg = inet, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(inet, inet) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.int48ge, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(integer, bigint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.int4ge, leftarg = integer, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(integer, integer) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.int42ge, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(integer, smallint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.interval_ge, leftarg = interval, rightarg = interval, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(interval, interval) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.jsonb_ge, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(jsonb, jsonb) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.lseg_ge, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<=, negator = pg_catalog.<);

comment on operator pg_catalog.>=(lseg, lseg) is 'greater than or equal by length';

create operator pg_catalog.>= (procedure = pg_catalog.macaddr_ge, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(macaddr, macaddr) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.macaddr8_ge, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(macaddr8, macaddr8) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.cash_ge, leftarg = money, rightarg = money, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(money, money) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.namege, leftarg = name, rightarg = name, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(name, name) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.namegetext, leftarg = name, rightarg = text, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(name, text) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.numeric_ge, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(numeric, numeric) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.oidge, leftarg = oid, rightarg = oid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(oid, oid) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.oidvectorge, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(oidvector, oidvector) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.pg_lsn_ge, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(pg_lsn, pg_lsn) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.float48ge, leftarg = real, rightarg = double precision, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(real, double precision) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.float4ge, leftarg = real, rightarg = real, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(real, real) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.record_ge, leftarg = record, rightarg = record, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(record, record) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.int28ge, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(smallint, bigint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.int24ge, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(smallint, integer) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.int2ge, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(smallint, smallint) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.textgename, leftarg = text, rightarg = name, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(text, name) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.text_ge, leftarg = text, rightarg = text, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(text, text) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.tidge, leftarg = tid, rightarg = tid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(tid, tid) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.timetz_ge, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(time with time zone, time with time zone) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.time_ge, leftarg = time, rightarg = time, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(time, time) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.timestamptz_ge_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, date) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.timestamptz_ge, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp with time zone) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.timestamptz_ge_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.timestamp_ge_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp, date) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.timestamp_ge_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp, timestamp with time zone) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.timestamp_ge, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp, timestamp) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.tsquery_ge, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(tsquery, tsquery) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.tsvector_ge, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(tsvector, tsvector) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.uuid_ge, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(uuid, uuid) is 'greater than or equal';

create operator pg_catalog.>= (procedure = pg_catalog.xid8ge, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(xid8, xid8) is 'greater than or equal';

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.pg_lsn_le, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(pg_lsn, pg_lsn) is 'less than or equal';

create operator pg_catalog.> (procedure = pg_catalog.pg_lsn_gt, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(pg_lsn, pg_lsn) is 'greater than';

create operator pg_catalog.<= (procedure = pg_catalog.float48le, leftarg = real, rightarg = double precision, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(real, double precision) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.float4le, leftarg = real, rightarg = real, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(real, real) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.record_le, leftarg = record, rightarg = record, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(record, record) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.int28le, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(smallint, bigint) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.int24le, leftarg = smallint, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(smallint, integer) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.int2le, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(smallint, smallint) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.textlename, leftarg = text, rightarg = name, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(text, name) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.text_le, leftarg = text, rightarg = text, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(text, text) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.tidle, leftarg = tid, rightarg = tid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(tid, tid) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.timetz_le, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(time with time zone, time with time zone) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.time_le, leftarg = time, rightarg = time, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(time, time) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.timestamptz_le_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, date) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.timestamptz_le, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp with time zone) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.timestamptz_le_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.timestamp_le_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp, date) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.timestamp_le_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp, timestamp with time zone) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.timestamp_le, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp, timestamp) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.tsquery_le, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(tsquery, tsquery) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.tsvector_le, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(tsvector, tsvector) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.uuid_le, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(uuid, uuid) is 'less than or equal';

create operator pg_catalog.<= (procedure = pg_catalog.xid8le, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(xid8, xid8) is 'less than or equal';

create operator pg_catalog.> (procedure = pg_catalog.float48gt, leftarg = real, rightarg = double precision, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(real, double precision) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.float4gt, leftarg = real, rightarg = real, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(real, real) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.record_gt, leftarg = record, rightarg = record, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(record, record) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.int28gt, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(smallint, bigint) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.int24gt, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(smallint, integer) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.int2gt, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(smallint, smallint) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.textgtname, leftarg = text, rightarg = name, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(text, name) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.text_gt, leftarg = text, rightarg = text, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(text, text) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.tidgt, leftarg = tid, rightarg = tid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(tid, tid) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.timetz_gt, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(time with time zone, time with time zone) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.time_gt, leftarg = time, rightarg = time, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(time, time) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.timestamptz_gt_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, date) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.timestamptz_gt, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, timestamp with time zone) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.timestamptz_gt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, timestamp) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.timestamp_gt_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp, date) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.timestamp_gt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp, timestamp with time zone) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.timestamp_gt, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp, timestamp) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.tsquery_gt, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(tsquery, tsquery) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.tsvector_gt, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(tsvector, tsvector) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.uuid_gt, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(uuid, uuid) is 'greater than';

create operator pg_catalog.> (procedure = pg_catalog.xid8gt, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(xid8, xid8) is 'greater than';

-- Cyclic dependencies found

create operator pg_catalog.~<=~ (procedure = pg_catalog.bpchar_pattern_le, leftarg = char, rightarg = char, commutator = pg_catalog.~>=~, negator = pg_catalog.~>~, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.~<=~(char, char) is 'less than or equal';

-- Cyclic dependencies found

create operator pg_catalog.~>=~ (procedure = pg_catalog.bpchar_pattern_ge, leftarg = char, rightarg = char, commutator = pg_catalog.~<=~, negator = pg_catalog.~<~, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.~>=~(char, char) is 'greater than or equal';

-- Cyclic dependencies found

create operator pg_catalog.~<=~ (procedure = pg_catalog.text_pattern_le, leftarg = text, rightarg = text, commutator = pg_catalog.~>=~, negator = pg_catalog.~>~, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.~<=~(text, text) is 'less than or equal';

-- Cyclic dependencies found

create operator pg_catalog.~<~ (procedure = pg_catalog.bpchar_pattern_lt, leftarg = char, rightarg = char, commutator = pg_catalog.~>~, negator = pg_catalog.~>=~, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.~<~(char, char) is 'less than';

create operator pg_catalog.~>=~ (procedure = pg_catalog.text_pattern_ge, leftarg = text, rightarg = text, commutator = pg_catalog.~<=~, negator = pg_catalog.~<~, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.~>=~(text, text) is 'greater than or equal';

create operator pg_catalog.~>~ (procedure = pg_catalog.bpchar_pattern_gt, leftarg = char, rightarg = char, commutator = pg_catalog.~<~, negator = pg_catalog.~<=~, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.~>~(char, char) is 'greater than';

create operator pg_catalog.~<~ (procedure = pg_catalog.text_pattern_lt, leftarg = text, rightarg = text, commutator = pg_catalog.~>~, negator = pg_catalog.~>=~, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.~<~(text, text) is 'less than';

create operator pg_catalog.~>~ (procedure = pg_catalog.text_pattern_gt, leftarg = text, rightarg = text, commutator = pg_catalog.~<~, negator = pg_catalog.~<=~, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.~>~(text, text) is 'greater than';

-- Cyclic dependencies found

create operator < (procedure = geography_lt, leftarg = geography, rightarg = geography, commutator = >, negator = >=, join = contjoinsel, restrict = contsel);

alter operator <(geography, geography) owner to postgres;

-- Cyclic dependencies found

create operator > (procedure = geography_gt, leftarg = geography, rightarg = geography, commutator = <, negator = <=, join = contjoinsel, restrict = contsel);

alter operator >(geography, geography) owner to postgres;

-- Cyclic dependencies found

create operator <= (procedure = geography_le, leftarg = geography, rightarg = geography, commutator = >=, negator = >, join = contjoinsel, restrict = contsel);

alter operator <=(geography, geography) owner to postgres;

create operator >= (procedure = geography_ge, leftarg = geography, rightarg = geography, commutator = <=, negator = <, join = contjoinsel, restrict = contsel);

alter operator >=(geography, geography) owner to postgres;

-- Cyclic dependencies found

create operator < (procedure = geometry_lt, leftarg = geometry, rightarg = geometry, commutator = >, negator = >=, join = contjoinsel, restrict = contsel);

alter operator <(geometry, geometry) owner to postgres;

-- Cyclic dependencies found

create operator > (procedure = geometry_gt, leftarg = geometry, rightarg = geometry, commutator = <, negator = <=, join = contjoinsel, restrict = contsel);

alter operator >(geometry, geometry) owner to postgres;

-- Cyclic dependencies found

create operator <= (procedure = geometry_le, leftarg = geometry, rightarg = geometry, commutator = >=, negator = >, join = contjoinsel, restrict = contsel);

alter operator <=(geometry, geometry) owner to postgres;

create operator >= (procedure = geometry_ge, leftarg = geometry, rightarg = geometry, commutator = <=, negator = <, join = contjoinsel, restrict = contsel);

alter operator >=(geometry, geometry) owner to postgres;

